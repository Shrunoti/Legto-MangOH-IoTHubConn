\hypertarget{le__mem_8h}{}\section{le\+\_\+mem.\+h File Reference}
\label{le__mem_8h}\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structle__mem___pool_stats__t}{le\+\_\+mem\+\_\+\+Pool\+Stats\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct le\+\_\+mem\+\_\+\+Pool $\ast$ \hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}
\item 
typedef void($\ast$ \hyperlink{le__mem_8h_afe3d1a458511f0a2e2bcef0827306b79}{le\+\_\+mem\+\_\+\+Destructor\+\_\+t}) (void $\ast$obj\+Ptr)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \hyperlink{le__mem_8h_ab91efaa2978c9c1c7b2427d25b33241c}{le\+\_\+mem\+\_\+\+Create\+Pool} (const char $\ast$name, size\+\_\+t obj\+Size)
\item 
\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \hyperlink{le__mem_8h_a79a4321ffa0345f267eaf3b7d3d3528a}{le\+\_\+mem\+\_\+\+Expand\+Pool} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool, size\+\_\+t num\+Objects)
\item 
void $\ast$ \hyperlink{le__mem_8h_a742e4f9d621ca27493733ca781bbe187}{le\+\_\+mem\+\_\+\+Try\+Alloc} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
void $\ast$ \hyperlink{le__mem_8h_a2993bf7a9705d119c96cf80cd64a56bb}{le\+\_\+mem\+\_\+\+Assert\+Alloc} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
void $\ast$ \hyperlink{le__mem_8h_af7c289c73d4182835a26a9099f3db359}{le\+\_\+mem\+\_\+\+Force\+Alloc} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
void \hyperlink{le__mem_8h_a267485862100d8cdfefae2c328fb8b91}{le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool, size\+\_\+t num\+Objects)
\item 
void \hyperlink{le__mem_8h_a6d8e3fe430bcb81efe97b57ce30ef2de}{le\+\_\+mem\+\_\+\+Release} (void $\ast$obj\+Ptr)
\item 
void \hyperlink{le__mem_8h_a92e869f92a344d61fb44922f99fe679b}{le\+\_\+mem\+\_\+\+Add\+Ref} (void $\ast$obj\+Ptr)
\item 
void \hyperlink{le__mem_8h_a055007b38ce04bcb823e08034fd11b85}{le\+\_\+mem\+\_\+\+Set\+Destructor} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool, \hyperlink{le__mem_8h_afe3d1a458511f0a2e2bcef0827306b79}{le\+\_\+mem\+\_\+\+Destructor\+\_\+t} destructor)
\item 
void \hyperlink{le__mem_8h_ab7b41431c57c8c7b5c4ff1501fd5b772}{le\+\_\+mem\+\_\+\+Get\+Stats} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool, \hyperlink{structle__mem___pool_stats__t}{le\+\_\+mem\+\_\+\+Pool\+Stats\+\_\+t} $\ast$stats\+Ptr)
\item 
void \hyperlink{le__mem_8h_a35b7e757356764c39f0a7ede2aa242ae}{le\+\_\+mem\+\_\+\+Reset\+Stats} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__mem_8h_a721219712fb3d62988cc151a1908cb4b}{le\+\_\+mem\+\_\+\+Get\+Name} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool, char $\ast$name\+Ptr, size\+\_\+t buf\+Size)
\item 
const bool \hyperlink{le__mem_8h_a55840232147421c951714013abbab4ec}{le\+\_\+mem\+\_\+\+Is\+Sub\+Pool} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
size\+\_\+t \hyperlink{le__mem_8h_a76725588ed757ca95cdf36e5ab3aeebf}{le\+\_\+mem\+\_\+\+Get\+Object\+Count} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
size\+\_\+t \hyperlink{le__mem_8h_a0f6fbc0c886486a1e19fc43143991c66}{le\+\_\+mem\+\_\+\+Get\+Object\+Size} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
size\+\_\+t \hyperlink{le__mem_8h_ac802750b9aab7bb596004f30ce58adf0}{le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
static \hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \hyperlink{le__mem_8h_a67e004702344963aea788b1c0ca70862}{le\+\_\+mem\+\_\+\+Find\+Pool} (const char $\ast$name)
\item 
static \hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \hyperlink{le__mem_8h_a8b043fcb013deb4c58c90ca2e0ab9d16}{le\+\_\+mem\+\_\+\+Create\+Sub\+Pool} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} super\+Pool, const char $\ast$name, size\+\_\+t num\+Objects)
\item 
void \hyperlink{le__mem_8h_aa1d51a37f572c2d891cdfb625ea19f27}{le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} sub\+Pool)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Legato \hyperlink{c_memory}{Dynamic Memory Allocation A\+PI} include file.

Copyright (C) Sierra Wireless Inc. 

\subsection{Typedef Documentation}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Destructor\+\_\+t@{le\+\_\+mem\+\_\+\+Destructor\+\_\+t}}
\index{le\+\_\+mem\+\_\+\+Destructor\+\_\+t@{le\+\_\+mem\+\_\+\+Destructor\+\_\+t}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Destructor\+\_\+t}{le_mem_Destructor_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$ le\+\_\+mem\+\_\+\+Destructor\+\_\+t) (void $\ast$obj\+Ptr)}\hypertarget{le__mem_8h_afe3d1a458511f0a2e2bcef0827306b79}{}\label{le__mem_8h_afe3d1a458511f0a2e2bcef0827306b79}
Prototype for destructor functions.


\begin{DoxyParams}{Parameters}
{\em obj\+Ptr} & Pointer to the object where reference count has reached zero. After the destructor returns this object\textquotesingle{}s memory will be released back into the pool (and this pointer will become invalid).\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing.
\end{DoxyReturn}
See \hyperlink{c_memory_mem_destructors}{Destructors} for more information. \index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t@{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}
\index{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t@{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}{le_mem_PoolRef_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct le\+\_\+mem\+\_\+\+Pool$\ast$ {\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}\hypertarget{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{}\label{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}
Objects of this type are used to refer to a memory pool created using either \hyperlink{le__mem_8h_ab91efaa2978c9c1c7b2427d25b33241c}{le\+\_\+mem\+\_\+\+Create\+Pool()} or \hyperlink{le__mem_8h_a8b043fcb013deb4c58c90ca2e0ab9d16}{le\+\_\+mem\+\_\+\+Create\+Sub\+Pool()}. 

\subsection{Function Documentation}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Add\+Ref@{le\+\_\+mem\+\_\+\+Add\+Ref}}
\index{le\+\_\+mem\+\_\+\+Add\+Ref@{le\+\_\+mem\+\_\+\+Add\+Ref}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Add\+Ref(void $\ast$obj\+Ptr)}{le_mem_AddRef(void *objPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+mem\+\_\+\+Add\+Ref (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{obj\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_a92e869f92a344d61fb44922f99fe679b}{}\label{le__mem_8h_a92e869f92a344d61fb44922f99fe679b}
Increments the reference count on an object by 1.

See \hyperlink{c_memory_mem_ref_counting}{Reference Counting} for more information.

\begin{DoxyReturn}{Returns}
Nothing. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em obj\+Ptr} & Pointer to the object. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Assert\+Alloc@{le\+\_\+mem\+\_\+\+Assert\+Alloc}}
\index{le\+\_\+mem\+\_\+\+Assert\+Alloc@{le\+\_\+mem\+\_\+\+Assert\+Alloc}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Assert\+Alloc(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_AssertAlloc(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ le\+\_\+mem\+\_\+\+Assert\+Alloc (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_a2993bf7a9705d119c96cf80cd64a56bb}{}\label{le__mem_8h_a2993bf7a9705d119c96cf80cd64a56bb}
Allocates an object from a pool or logs a fatal error and terminates the process if the pool doesn\textquotesingle{}t have any free objects to allocate.

\begin{DoxyReturn}{Returns}
Pointer to the allocated object.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
On failure, the process exits, so you don\textquotesingle{}t have to worry about checking the returned pointer for validity. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & Pool from which the object is to be allocated. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Create\+Pool@{le\+\_\+mem\+\_\+\+Create\+Pool}}
\index{le\+\_\+mem\+\_\+\+Create\+Pool@{le\+\_\+mem\+\_\+\+Create\+Pool}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Create\+Pool(const char $\ast$name, size\+\_\+t obj\+Size)}{le_mem_CreatePool(const char *name, size_t objSize)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} le\+\_\+mem\+\_\+\+Create\+Pool (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{name, }
\item[{size\+\_\+t}]{obj\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__mem_8h_ab91efaa2978c9c1c7b2427d25b33241c}{}\label{le__mem_8h_ab91efaa2978c9c1c7b2427d25b33241c}
Creates an empty memory pool.

\begin{DoxyReturn}{Returns}
Reference to the memory pool object.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
On failure, the process exits, so you don\textquotesingle{}t have to worry about checking the returned reference for validity. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em name} & Name of the pool (will be copied into the Pool). \\
\hline
\mbox{\tt in}  & {\em obj\+Size} & Size of the individual objects to be allocated from this pool (in bytes), e.\+g., sizeof(\+My\+Object\+\_\+t). \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Create\+Sub\+Pool@{le\+\_\+mem\+\_\+\+Create\+Sub\+Pool}}
\index{le\+\_\+mem\+\_\+\+Create\+Sub\+Pool@{le\+\_\+mem\+\_\+\+Create\+Sub\+Pool}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Create\+Sub\+Pool(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t super\+Pool, const char $\ast$name, size\+\_\+t num\+Objects)}{le_mem_CreateSubPool(le_mem_PoolRef_t superPool, const char *name, size_t numObjects)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} le\+\_\+mem\+\_\+\+Create\+Sub\+Pool (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{super\+Pool, }
\item[{const char $\ast$}]{name, }
\item[{size\+\_\+t}]{num\+Objects}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__mem_8h_a8b043fcb013deb4c58c90ca2e0ab9d16}{}\label{le__mem_8h_a8b043fcb013deb4c58c90ca2e0ab9d16}
Creates a sub-\/pool. You can\textquotesingle{}t create sub-\/pools of sub-\/pools so do not attempt to pass a sub-\/pool in the super\+Pool parameter.

See \hyperlink{c_memory_mem_sub_pools}{Sub-\/\+Pools} for more information.

\begin{DoxyReturn}{Returns}
Reference to the sub-\/pool. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em super\+Pool} & Super-\/pool. \\
\hline
\mbox{\tt in}  & {\em name} & Name of the sub-\/pool (will be copied into the sub-\/pool). \\
\hline
\mbox{\tt in}  & {\em num\+Objects} & Number of objects to take from the super-\/pool. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool@{le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool}}
\index{le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool@{le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t sub\+Pool)}{le_mem_DeleteSubPool(le_mem_PoolRef_t subPool)}}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{sub\+Pool}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_aa1d51a37f572c2d891cdfb625ea19f27}{}\label{le__mem_8h_aa1d51a37f572c2d891cdfb625ea19f27}
Deletes a sub-\/pool.

See \hyperlink{c_memory_mem_sub_pools}{Sub-\/\+Pools} for more information.

\begin{DoxyReturn}{Returns}
Nothing. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em sub\+Pool} & Sub-\/pool to be deleted. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Expand\+Pool@{le\+\_\+mem\+\_\+\+Expand\+Pool}}
\index{le\+\_\+mem\+\_\+\+Expand\+Pool@{le\+\_\+mem\+\_\+\+Expand\+Pool}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Expand\+Pool(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool, size\+\_\+t num\+Objects)}{le_mem_ExpandPool(le_mem_PoolRef_t pool, size_t numObjects)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} le\+\_\+mem\+\_\+\+Expand\+Pool (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool, }
\item[{size\+\_\+t}]{num\+Objects}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_a79a4321ffa0345f267eaf3b7d3d3528a}{}\label{le__mem_8h_a79a4321ffa0345f267eaf3b7d3d3528a}
Expands the size of a memory pool.

\begin{DoxyReturn}{Returns}
Reference to the memory pool object (the same value passed into it).
\end{DoxyReturn}
\begin{DoxyNote}{Note}
On failure, the process exits, so you don\textquotesingle{}t have to worry about checking the returned reference for validity. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & Pool to be expanded. \\
\hline
\mbox{\tt in}  & {\em num\+Objects} & Number of objects to add to the pool. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Find\+Pool@{le\+\_\+mem\+\_\+\+Find\+Pool}}
\index{le\+\_\+mem\+\_\+\+Find\+Pool@{le\+\_\+mem\+\_\+\+Find\+Pool}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Find\+Pool(const char $\ast$name)}{le_mem_FindPool(const char *name)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} le\+\_\+mem\+\_\+\+Find\+Pool (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__mem_8h_a67e004702344963aea788b1c0ca70862}{}\label{le__mem_8h_a67e004702344963aea788b1c0ca70862}
Finds a pool based on the pool\textquotesingle{}s name.

\begin{DoxyReturn}{Returns}
Reference to the pool, or N\+U\+LL if the pool doesn\textquotesingle{}t exist. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em name} & Name of the pool. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Force\+Alloc@{le\+\_\+mem\+\_\+\+Force\+Alloc}}
\index{le\+\_\+mem\+\_\+\+Force\+Alloc@{le\+\_\+mem\+\_\+\+Force\+Alloc}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Force\+Alloc(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_ForceAlloc(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ le\+\_\+mem\+\_\+\+Force\+Alloc (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_af7c289c73d4182835a26a9099f3db359}{}\label{le__mem_8h_af7c289c73d4182835a26a9099f3db359}
Allocates an object from a pool or logs a warning and expands the pool if the pool doesn\textquotesingle{}t have any free objects to allocate.

\begin{DoxyReturn}{Returns}
Pointer to the allocated object.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
On failure, the process exits, so you don\textquotesingle{}t have to worry about checking the returned pointer for validity. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & Pool from which the object is to be allocated. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Get\+Name@{le\+\_\+mem\+\_\+\+Get\+Name}}
\index{le\+\_\+mem\+\_\+\+Get\+Name@{le\+\_\+mem\+\_\+\+Get\+Name}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Get\+Name(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool, char $\ast$name\+Ptr, size\+\_\+t buf\+Size)}{le_mem_GetName(le_mem_PoolRef_t pool, char *namePtr, size_t bufSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+mem\+\_\+\+Get\+Name (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool, }
\item[{char $\ast$}]{name\+Ptr, }
\item[{size\+\_\+t}]{buf\+Size}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_a721219712fb3d62988cc151a1908cb4b}{}\label{le__mem_8h_a721219712fb3d62988cc151a1908cb4b}
Gets the memory pool\textquotesingle{}s name, including the component name prefix.

If the pool were given the name \char`\"{}my\+Pool\char`\"{} and the component that it belongs to is called \char`\"{}my\+Component\char`\"{}, then the full pool name returned by this function would be \char`\"{}my\+Component.\+my\+Pool\char`\"{}.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if successful. L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if the name was truncated to fit in the provided buffer. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The memory pool. \\
\hline
\mbox{\tt out}  & {\em name\+Ptr} & Buffer to store the name of the memory pool. \\
\hline
\mbox{\tt in}  & {\em buf\+Size} & Size of the buffer name\+Ptr points to. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Get\+Object\+Count@{le\+\_\+mem\+\_\+\+Get\+Object\+Count}}
\index{le\+\_\+mem\+\_\+\+Get\+Object\+Count@{le\+\_\+mem\+\_\+\+Get\+Object\+Count}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Get\+Object\+Count(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_GetObjectCount(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+mem\+\_\+\+Get\+Object\+Count (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_a76725588ed757ca95cdf36e5ab3aeebf}{}\label{le__mem_8h_a76725588ed757ca95cdf36e5ab3aeebf}
Fetches the number of objects a specified pool can hold (this includes both the number of free and in-\/use objects).

\begin{DoxyReturn}{Returns}
Total number of objects. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & Pool where number of objects is to be fetched. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size@{le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size}}
\index{le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size@{le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_GetObjectFullSize(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_ac802750b9aab7bb596004f30ce58adf0}{}\label{le__mem_8h_ac802750b9aab7bb596004f30ce58adf0}
Fetches the total size of the object including all the memory overhead in a given pool (in bytes).

\begin{DoxyReturn}{Returns}
Total object memory size, in bytes. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool whose object memory size is to be fetched. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Get\+Object\+Size@{le\+\_\+mem\+\_\+\+Get\+Object\+Size}}
\index{le\+\_\+mem\+\_\+\+Get\+Object\+Size@{le\+\_\+mem\+\_\+\+Get\+Object\+Size}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Get\+Object\+Size(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_GetObjectSize(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+mem\+\_\+\+Get\+Object\+Size (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_a0f6fbc0c886486a1e19fc43143991c66}{}\label{le__mem_8h_a0f6fbc0c886486a1e19fc43143991c66}
Fetches the size of the objects in a specified pool (in bytes).

\begin{DoxyReturn}{Returns}
Object size, in bytes. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & Pool where object size is to be fetched. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Get\+Stats@{le\+\_\+mem\+\_\+\+Get\+Stats}}
\index{le\+\_\+mem\+\_\+\+Get\+Stats@{le\+\_\+mem\+\_\+\+Get\+Stats}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Get\+Stats(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool, le\+\_\+mem\+\_\+\+Pool\+Stats\+\_\+t $\ast$stats\+Ptr)}{le_mem_GetStats(le_mem_PoolRef_t pool, le_mem_PoolStats_t *statsPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+mem\+\_\+\+Get\+Stats (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool, }
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Stats\+\_\+t} $\ast$}]{stats\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_ab7b41431c57c8c7b5c4ff1501fd5b772}{}\label{le__mem_8h_ab7b41431c57c8c7b5c4ff1501fd5b772}
Fetches the statistics for a specified pool.

\begin{DoxyReturn}{Returns}
Nothing. Uses output parameter instead. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & Pool where stats are to be fetched. \\
\hline
\mbox{\tt out}  & {\em stats\+Ptr} & Pointer to where the stats will be stored. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Is\+Sub\+Pool@{le\+\_\+mem\+\_\+\+Is\+Sub\+Pool}}
\index{le\+\_\+mem\+\_\+\+Is\+Sub\+Pool@{le\+\_\+mem\+\_\+\+Is\+Sub\+Pool}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Is\+Sub\+Pool(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_IsSubPool(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool le\+\_\+mem\+\_\+\+Is\+Sub\+Pool (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_a55840232147421c951714013abbab4ec}{}\label{le__mem_8h_a55840232147421c951714013abbab4ec}
Checks if the specified pool is a sub-\/pool.

\begin{DoxyReturn}{Returns}
true if it is a sub-\/pool. false if it is not a sub-\/pool. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The memory pool. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Release@{le\+\_\+mem\+\_\+\+Release}}
\index{le\+\_\+mem\+\_\+\+Release@{le\+\_\+mem\+\_\+\+Release}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Release(void $\ast$obj\+Ptr)}{le_mem_Release(void *objPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+mem\+\_\+\+Release (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{obj\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_a6d8e3fe430bcb81efe97b57ce30ef2de}{}\label{le__mem_8h_a6d8e3fe430bcb81efe97b57ce30ef2de}
Releases an object. If the object\textquotesingle{}s reference count has reached zero, it will be destructed and its memory will be put back into the pool for later reuse.

\begin{DoxyReturn}{Returns}
Nothing.
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}

\begin{DoxyItemize}
\item {\bfseries Don\textquotesingle{}t E\+V\+ER access an object after releasing it.} It might not exist anymore.
\item If the object has a destructor accessing a data structure shared by multiple threads, ensure you hold the mutex (or take other measures to prevent races) before releasing the object. 
\end{DoxyItemize}
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em obj\+Ptr} & Pointer to the object to be released. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Reset\+Stats@{le\+\_\+mem\+\_\+\+Reset\+Stats}}
\index{le\+\_\+mem\+\_\+\+Reset\+Stats@{le\+\_\+mem\+\_\+\+Reset\+Stats}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Reset\+Stats(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_ResetStats(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+mem\+\_\+\+Reset\+Stats (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_a35b7e757356764c39f0a7ede2aa242ae}{}\label{le__mem_8h_a35b7e757356764c39f0a7ede2aa242ae}
Resets the statistics for a specified pool.

\begin{DoxyReturn}{Returns}
Nothing. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & Pool where stats are to be reset. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Set\+Destructor@{le\+\_\+mem\+\_\+\+Set\+Destructor}}
\index{le\+\_\+mem\+\_\+\+Set\+Destructor@{le\+\_\+mem\+\_\+\+Set\+Destructor}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Set\+Destructor(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool, le\+\_\+mem\+\_\+\+Destructor\+\_\+t destructor)}{le_mem_SetDestructor(le_mem_PoolRef_t pool, le_mem_Destructor_t destructor)}}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+mem\+\_\+\+Set\+Destructor (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool, }
\item[{{\bf le\+\_\+mem\+\_\+\+Destructor\+\_\+t}}]{destructor}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_a055007b38ce04bcb823e08034fd11b85}{}\label{le__mem_8h_a055007b38ce04bcb823e08034fd11b85}
Sets the destructor function for a specified pool.

See \hyperlink{c_memory_mem_destructors}{Destructors} for more information.

\begin{DoxyReturn}{Returns}
Nothing. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool. \\
\hline
\mbox{\tt in}  & {\em destructor} & Destructor function. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force@{le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force}}
\index{le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force@{le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool, size\+\_\+t num\+Objects)}{le_mem_SetNumObjsToForce(le_mem_PoolRef_t pool, size_t numObjects)}}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool, }
\item[{size\+\_\+t}]{num\+Objects}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_a267485862100d8cdfefae2c328fb8b91}{}\label{le__mem_8h_a267485862100d8cdfefae2c328fb8b91}
Sets the number of objects that are added when le\+\_\+mem\+\_\+\+Force\+Alloc expands the pool.

\begin{DoxyReturn}{Returns}
Nothing.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The default value is one. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & Pool to set the number of objects for. \\
\hline
\mbox{\tt in}  & {\em num\+Objects} & Number of objects that is added when le\+\_\+mem\+\_\+\+Force\+Alloc expands the pool. \\
\hline
\end{DoxyParams}
\index{le\+\_\+mem.\+h@{le\+\_\+mem.\+h}!le\+\_\+mem\+\_\+\+Try\+Alloc@{le\+\_\+mem\+\_\+\+Try\+Alloc}}
\index{le\+\_\+mem\+\_\+\+Try\+Alloc@{le\+\_\+mem\+\_\+\+Try\+Alloc}!le\+\_\+mem.\+h@{le\+\_\+mem.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Try\+Alloc(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_TryAlloc(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}void$\ast$ le\+\_\+mem\+\_\+\+Try\+Alloc (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{le__mem_8h_a742e4f9d621ca27493733ca781bbe187}{}\label{le__mem_8h_a742e4f9d621ca27493733ca781bbe187}
Attempts to allocate an object from a pool.

\begin{DoxyReturn}{Returns}
Pointer to the allocated object, or N\+U\+LL if the pool doesn\textquotesingle{}t have any free objects to allocate. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & Pool from which the object is to be allocated. \\
\hline
\end{DoxyParams}
