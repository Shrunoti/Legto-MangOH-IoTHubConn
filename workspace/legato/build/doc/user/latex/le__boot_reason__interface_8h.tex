\hypertarget{le__boot_reason__interface_8h}{}\section{le\+\_\+boot\+Reason\+\_\+interface.\+h File Reference}
\label{le__boot_reason__interface_8h}\index{le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}}
{\ttfamily \#include \char`\"{}legato.\+h\char`\"{}}\\*
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef void($\ast$ \hyperlink{le__boot_reason__interface_8h_a825af856b250c9544d084a4647870156}{le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Handler\+\_\+t}) (void $\ast$)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{le__boot_reason__interface_8h_a1f5131f7fdb89b64a45a6daf34b841fa}{le\+\_\+boot\+Reason\+\_\+\+Connect\+Service} (void)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__boot_reason__interface_8h_a4e91ba385d2c00e5cf96106e4a043578}{le\+\_\+boot\+Reason\+\_\+\+Try\+Connect\+Service} (void)
\item 
void \hyperlink{le__boot_reason__interface_8h_ac9280d3d3f5936b05c8ca73931500957}{le\+\_\+boot\+Reason\+\_\+\+Set\+Server\+Disconnect\+Handler} (\hyperlink{le__boot_reason__interface_8h_a825af856b250c9544d084a4647870156}{le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Handler\+\_\+t} disconnect\+Handler, void $\ast$context\+Ptr)
\item 
void \hyperlink{le__boot_reason__interface_8h_a9a9eb091fb78f4c6fc33100f4f50eebb}{le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Service} (void)
\item 
bool \hyperlink{le__boot_reason__interface_8h_a0064c81cc0aa946e4cfe9385adcc6d61}{le\+\_\+boot\+Reason\+\_\+\+Was\+Timer} (void)
\item 
bool \hyperlink{le__boot_reason__interface_8h_a46fa79309abed3032477938dc858ff0c}{le\+\_\+boot\+Reason\+\_\+\+Was\+Gpio} (uint32\+\_\+t gpio\+Num)
\item 
bool \hyperlink{le__boot_reason__interface_8h_a56eb6efc0c617d263779c1320d7e6679}{le\+\_\+boot\+Reason\+\_\+\+Was\+Adc} (uint32\+\_\+t adc\+Num)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Legato \hyperlink{c_bootReason}{Boot Reason Query} include file.

Copyright (C) Sierra Wireless Inc. 

\subsection{Typedef Documentation}
\index{le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}!le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Handler\+\_\+t@{le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Handler\+\_\+t}}
\index{le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Handler\+\_\+t@{le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Handler\+\_\+t}!le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Handler\+\_\+t}{le_bootReason_DisconnectHandler_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef void($\ast$ le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Handler\+\_\+t) (void $\ast$)}\hypertarget{le__boot_reason__interface_8h_a825af856b250c9544d084a4647870156}{}\label{le__boot_reason__interface_8h_a825af856b250c9544d084a4647870156}
Type for handler called when a server disconnects. 

\subsection{Function Documentation}
\index{le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}!le\+\_\+boot\+Reason\+\_\+\+Connect\+Service@{le\+\_\+boot\+Reason\+\_\+\+Connect\+Service}}
\index{le\+\_\+boot\+Reason\+\_\+\+Connect\+Service@{le\+\_\+boot\+Reason\+\_\+\+Connect\+Service}!le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+boot\+Reason\+\_\+\+Connect\+Service(void)}{le_bootReason_ConnectService(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+boot\+Reason\+\_\+\+Connect\+Service (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{le__boot_reason__interface_8h_a1f5131f7fdb89b64a45a6daf34b841fa}{}\label{le__boot_reason__interface_8h_a1f5131f7fdb89b64a45a6daf34b841fa}
Connect the current client thread to the service providing this A\+PI. Block until the service is available.

For each thread that wants to use this A\+PI, either Connect\+Service or Try\+Connect\+Service must be called before any other functions in this A\+PI. Normally, Connect\+Service is automatically called for the main thread, but not for any other thread. For details, see \hyperlink{apiFilesC_apiFilesC_client}{Client-\/specific Functions}.

This function is created automatically. \index{le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}!le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Service@{le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Service}}
\index{le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Service@{le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Service}!le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Service(void)}{le_bootReason_DisconnectService(void)}}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Service (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{le__boot_reason__interface_8h_a9a9eb091fb78f4c6fc33100f4f50eebb}{}\label{le__boot_reason__interface_8h_a9a9eb091fb78f4c6fc33100f4f50eebb}
Disconnect the current client thread from the service providing this A\+PI.

Normally, this function doesn\textquotesingle{}t need to be called. After this function is called, there\textquotesingle{}s no longer a connection to the service, and the functions in this A\+PI can\textquotesingle{}t be used. For details, see \hyperlink{apiFilesC_apiFilesC_client}{Client-\/specific Functions}.

This function is created automatically. \index{le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}!le\+\_\+boot\+Reason\+\_\+\+Set\+Server\+Disconnect\+Handler@{le\+\_\+boot\+Reason\+\_\+\+Set\+Server\+Disconnect\+Handler}}
\index{le\+\_\+boot\+Reason\+\_\+\+Set\+Server\+Disconnect\+Handler@{le\+\_\+boot\+Reason\+\_\+\+Set\+Server\+Disconnect\+Handler}!le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+boot\+Reason\+\_\+\+Set\+Server\+Disconnect\+Handler(le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Handler\+\_\+t disconnect\+Handler, void $\ast$context\+Ptr)}{le_bootReason_SetServerDisconnectHandler(le_bootReason_DisconnectHandler_t disconnectHandler, void *contextPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}void le\+\_\+boot\+Reason\+\_\+\+Set\+Server\+Disconnect\+Handler (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+boot\+Reason\+\_\+\+Disconnect\+Handler\+\_\+t}}]{disconnect\+Handler, }
\item[{void $\ast$}]{context\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__boot_reason__interface_8h_ac9280d3d3f5936b05c8ca73931500957}{}\label{le__boot_reason__interface_8h_ac9280d3d3f5936b05c8ca73931500957}
Set handler called when server disconnection is detected.

When a server connection is lost, call this handler then exit with L\+E\+\_\+\+F\+A\+T\+AL. If a program wants to continue without exiting, it should call longjmp() from inside the handler. \index{le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}!le\+\_\+boot\+Reason\+\_\+\+Try\+Connect\+Service@{le\+\_\+boot\+Reason\+\_\+\+Try\+Connect\+Service}}
\index{le\+\_\+boot\+Reason\+\_\+\+Try\+Connect\+Service@{le\+\_\+boot\+Reason\+\_\+\+Try\+Connect\+Service}!le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+boot\+Reason\+\_\+\+Try\+Connect\+Service(void)}{le_bootReason_TryConnectService(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+boot\+Reason\+\_\+\+Try\+Connect\+Service (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{le__boot_reason__interface_8h_a4e91ba385d2c00e5cf96106e4a043578}{}\label{le__boot_reason__interface_8h_a4e91ba385d2c00e5cf96106e4a043578}
Try to connect the current client thread to the service providing this A\+PI. Return with an error if the service is not available.

For each thread that wants to use this A\+PI, either Connect\+Service or Try\+Connect\+Service must be called before any other functions in this A\+PI. Normally, Connect\+Service is automatically called for the main thread, but not for any other thread. For details, see \hyperlink{apiFilesC_apiFilesC_client}{Client-\/specific Functions}.

This function is created automatically.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if the client connected successfully to the service.
\item L\+E\+\_\+\+U\+N\+A\+V\+A\+I\+L\+A\+B\+LE if the server is not currently offering the service to which the client is bound.
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+P\+E\+R\+M\+I\+T\+T\+ED if the client interface is not bound to any service (doesn\textquotesingle{}t have a binding).
\item L\+E\+\_\+\+C\+O\+M\+M\+\_\+\+E\+R\+R\+OR if the Service Directory cannot be reached. 
\end{DoxyItemize}
\end{DoxyReturn}
\index{le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}!le\+\_\+boot\+Reason\+\_\+\+Was\+Adc@{le\+\_\+boot\+Reason\+\_\+\+Was\+Adc}}
\index{le\+\_\+boot\+Reason\+\_\+\+Was\+Adc@{le\+\_\+boot\+Reason\+\_\+\+Was\+Adc}!le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+boot\+Reason\+\_\+\+Was\+Adc(uint32\+\_\+t adc\+Num)}{le_bootReason_WasAdc(uint32_t adcNum)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+boot\+Reason\+\_\+\+Was\+Adc (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{adc\+Num}
\end{DoxyParamCaption}
)}\hypertarget{le__boot_reason__interface_8h_a56eb6efc0c617d263779c1320d7e6679}{}\label{le__boot_reason__interface_8h_a56eb6efc0c617d263779c1320d7e6679}
Checks whether boot reason was due to the specified A\+DC having a reading above or below the configured limits.

\begin{DoxyReturn}{Returns}
true if boot reason was due to the given A\+DC or false otherwise.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The process exits if an invalid A\+DC number is passed. Check corresponding device documents for valid list of A\+DC numbers. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em adc\+Num} & A\+DC number \\
\hline
\end{DoxyParams}
\index{le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}!le\+\_\+boot\+Reason\+\_\+\+Was\+Gpio@{le\+\_\+boot\+Reason\+\_\+\+Was\+Gpio}}
\index{le\+\_\+boot\+Reason\+\_\+\+Was\+Gpio@{le\+\_\+boot\+Reason\+\_\+\+Was\+Gpio}!le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+boot\+Reason\+\_\+\+Was\+Gpio(uint32\+\_\+t gpio\+Num)}{le_bootReason_WasGpio(uint32_t gpioNum)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+boot\+Reason\+\_\+\+Was\+Gpio (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{gpio\+Num}
\end{DoxyParamCaption}
)}\hypertarget{le__boot_reason__interface_8h_a46fa79309abed3032477938dc858ff0c}{}\label{le__boot_reason__interface_8h_a46fa79309abed3032477938dc858ff0c}
Checks whether boot-\/reason was specific gpio change. G\+P\+IO number is specified in parameter.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item T\+R\+UE if boot-\/reason was specified gpio change.
\item F\+A\+L\+SE otherwise.
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The process exits if invalid gpio number is passed. Check corresponding device documents for valid list of gpio. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em gpio\+Num} & G\+P\+IO number. \\
\hline
\end{DoxyParams}
\index{le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}!le\+\_\+boot\+Reason\+\_\+\+Was\+Timer@{le\+\_\+boot\+Reason\+\_\+\+Was\+Timer}}
\index{le\+\_\+boot\+Reason\+\_\+\+Was\+Timer@{le\+\_\+boot\+Reason\+\_\+\+Was\+Timer}!le\+\_\+boot\+Reason\+\_\+interface.\+h@{le\+\_\+boot\+Reason\+\_\+interface.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+boot\+Reason\+\_\+\+Was\+Timer(void)}{le_bootReason_WasTimer(void)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+boot\+Reason\+\_\+\+Was\+Timer (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\hypertarget{le__boot_reason__interface_8h_a0064c81cc0aa946e4cfe9385adcc6d61}{}\label{le__boot_reason__interface_8h_a0064c81cc0aa946e4cfe9385adcc6d61}
Checks whether boot-\/reason was timer expiry.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item T\+R\+UE if boot-\/reason was timer expiry.
\item F\+A\+L\+SE otherwise. 
\end{DoxyItemize}
\end{DoxyReturn}
