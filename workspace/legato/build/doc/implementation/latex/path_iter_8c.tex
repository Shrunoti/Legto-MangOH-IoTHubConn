\hypertarget{path_iter_8c}{}\section{framework/liblegato/linux/path\+Iter.c File Reference}
\label{path_iter_8c}\index{framework/liblegato/linux/path\+Iter.\+c@{framework/liblegato/linux/path\+Iter.\+c}}
{\ttfamily \#include \char`\"{}legato.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}limit.\+h\char`\"{}}\\*
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct_path_iterator__t}{Path\+Iterator\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{path_iter_8c_a4ab86e7102448b00d4a7b23a07a6431a}{M\+A\+X\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES}~32
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{struct_path_iterator__t}{Path\+Iterator\+\_\+t} $\ast$ \hyperlink{path_iter_8c_ac3fb15e4a7ede25216d772b6bcf3496a}{Get\+Path\+Iter\+Ptr} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref})
\item 
static bool \hyperlink{path_iter_8c_aba8da82fe54dc735b1490e66b12db6c3}{Is\+At\+Seperator} (const char $\ast$path\+Str, size\+\_\+t path\+Size, const char $\ast$sep\+Str, size\+\_\+t sep\+Size, size\+\_\+t current\+Position)
\item 
static ssize\+\_\+t \hyperlink{path_iter_8c_a466a28b96e9eeb700ad7ab51825ef548}{Find\+Next\+Node\+Index} (const char $\ast$path\+Str, size\+\_\+t path\+Size, const char $\ast$sep\+Str, size\+\_\+t sep\+Size, size\+\_\+t start\+Point)
\item 
static ssize\+\_\+t \hyperlink{path_iter_8c_a94519cbdc96eacad5288899af7513bdd}{Find\+Prev\+Node\+Index} (const \hyperlink{struct_path_iterator__t}{Path\+Iterator\+\_\+t} $\ast$iter\+Ptr, ssize\+\_\+t start\+Point)
\item 
static bool \hyperlink{path_iter_8c_a79daeda2b90f10381bdedea01e8b262c}{Node\+Equal} (const char $\ast$path\+Str\+Ptr, const char $\ast$compare\+Ptr, size\+\_\+t compare\+Size, const char $\ast$separator\+Ptr, size\+\_\+t separator\+Size)
\item 
static bool \hyperlink{path_iter_8c_a7499735013bfcc387e4c7b1b0534abc7}{Ends\+In\+Parent\+Spec} (const \hyperlink{struct_path_iterator__t}{Path\+Iterator\+\_\+t} $\ast$iter\+Ptr)
\item 
static bool \hyperlink{path_iter_8c_a617925dad65206502ab6ef6fb2e8b510}{Ends\+With\+Separator} (const \hyperlink{struct_path_iterator__t}{Path\+Iterator\+\_\+t} $\ast$iter\+Ptr)
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{path_iter_8c_afe97246a010c2bea697404afc2a86d9d}{Reset\+Iterator} (\hyperlink{struct_path_iterator__t}{Path\+Iterator\+\_\+t} $\ast$iter\+Ptr)
\item 
static \hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_iter_8c_a20dfab5e479136b01383c7f1e8d41ab6}{Append\+Separator} (\hyperlink{struct_path_iterator__t}{Path\+Iterator\+\_\+t} $\ast$iter\+Ptr)
\item 
static \hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_iter_8c_a8b282954333012f182d43f271531e057}{Append\+Node} (\hyperlink{struct_path_iterator__t}{Path\+Iterator\+\_\+t} $\ast$iter\+Ptr, const char $\ast$new\+Segment\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{path_iter_8c_ab89601ee1ee30ba590989ede8dad248b}{path\+Iter\+\_\+\+Init} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{path_iter_8c_a73fac1b657b752b17395c66fb1ae324b}{le\+\_\+path\+Iter\+\_\+\+Create} (const char $\ast$path\+Ptr, const char $\ast$separator\+Ptr, const char $\ast$parent\+Spec\+Ptr, const char $\ast$current\+Spec\+Ptr)
\item 
\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{path_iter_8c_a35a38b307f9fdc0de82552e96a5a2d1d}{le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix} (const char $\ast$path\+Ptr)
\item 
\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{path_iter_8c_a50349a6c2afa4415d65a6efd443894d3}{le\+\_\+path\+Iter\+\_\+\+Clone} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} original\+Ref)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{path_iter_8c_a6b57267a2c0db0210aab96c66459f9a1}{le\+\_\+path\+Iter\+\_\+\+Delete} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref})
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_iter_8c_a586cd64de7f1a6797da3a17896946ee5}{le\+\_\+path\+Iter\+\_\+\+Get\+Separator} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref}, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_iter_8c_af1707a310401be209aeada07f6d0f43f}{le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref}, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_iter_8c_ac12ea9bbe193fd9239abd10a4b07feba}{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref}, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_iter_8c_a4a1c39584a779518395b41f957765283}{le\+\_\+path\+Iter\+\_\+\+Get\+Path} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref}, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_iter_8c_af4352480ab3c9ffb09e740f2899d504e}{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref})
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_iter_8c_ab1c0b90132171b3f3cf5cfb614329b13}{le\+\_\+path\+Iter\+\_\+\+Go\+To\+End} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref})
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_iter_8c_ad83a619dcc34ecf03da1859b3da2f57f}{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref})
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_iter_8c_a92a740759fe5c3b0a18e39dd8c73466b}{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref})
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_iter_8c_ab00916d853b3a869748b0195cc2a8f11}{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref}, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{path_iter_8c_a04be1341536a3e330a815171e7cdbf7a}{le\+\_\+path\+Iter\+\_\+\+Truncate} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref})
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_iter_8c_ae6aa59696c54d2523009037cc78f9725}{le\+\_\+path\+Iter\+\_\+\+Append} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref}, const char $\ast$path\+Str)
\item 
bool \hyperlink{path_iter_8c_a657f779873a2220f463f705298c1399f}{le\+\_\+path\+Iter\+\_\+\+Is\+Absolute} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref})
\item 
bool \hyperlink{path_iter_8c_ab4ceddae696158d04fdbc1802614c5d6}{le\+\_\+path\+Iter\+\_\+\+Is\+Empty} (\hyperlink{le__path_iter_8h_a0facb15e56e7ef896384eca415a7147a}{le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} \hyperlink{watchdog_8c_a77e3a5a5d413fe9ec45738ef01c65514}{iter\+Ref})
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \hyperlink{path_iter_8c_acb091d1e9e4b0a7da772cbe76c7881eb}{Path\+Iterator\+Pool} = N\+U\+LL
\item 
static \hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} \hyperlink{path_iter_8c_a615a9810b19ab1a8b971a0da57f5078c}{Path\+Iterator\+Map} = N\+U\+LL
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Implements the path iterator A\+PI.

See \hyperlink{c_pathIter}{Path Iterator A\+PI} for details.

Copyright (C) Sierra Wireless Inc. license. 

\subsection{Macro Definition Documentation}
\index{path\+Iter.\+c@{path\+Iter.\+c}!M\+A\+X\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES@{M\+A\+X\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES}}
\index{M\+A\+X\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES@{M\+A\+X\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{M\+A\+X\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES}{MAX_COMPONENT_NAME_BYTES}}]{\setlength{\rightskip}{0pt plus 5cm}\#define M\+A\+X\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES~32}\hypertarget{path_iter_8c_a4ab86e7102448b00d4a7b23a07a6431a}{}\label{path_iter_8c_a4ab86e7102448b00d4a7b23a07a6431a}
Maximum size of the various path components within the path object. 

\subsection{Function Documentation}
\index{path\+Iter.\+c@{path\+Iter.\+c}!Append\+Node@{Append\+Node}}
\index{Append\+Node@{Append\+Node}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{Append\+Node(\+Path\+Iterator\+\_\+t $\ast$iter\+Ptr, const char $\ast$new\+Segment\+Ptr)}{AppendNode(PathIterator_t *iterPtr, const char *newSegmentPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf le\+\_\+result\+\_\+t} Append\+Node (
\begin{DoxyParamCaption}
\item[{{\bf Path\+Iterator\+\_\+t} $\ast$}]{iter\+Ptr, }
\item[{const char $\ast$}]{new\+Segment\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_iter_8c_a8b282954333012f182d43f271531e057}{}\label{path_iter_8c_a8b282954333012f182d43f271531e057}
Append a node onto the end of an iterator\textquotesingle{}s path string.

This function also deals with parent and current node specs. For instance, if the new node to append is a parent specifier then the last node on the iterator\textquotesingle{}s path is removed. If a current\+Node specifier is appended onto an empty path string then it is kept at the beginning of the path, otherwise it\textquotesingle{}s thrown away.

This way you can end up with paths like\+:

./a/path/to/somewhere

But not the less sensible\+:

./a/./path/to/./somewhere

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if the append is fits within the path string. L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if the new stirng overflows the path buffer. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in,out}  & {\em iter\+Ptr} & The iterator to update. \\
\hline
\mbox{\tt in}  & {\em new\+Segment\+Ptr} & The new segment we\textquotesingle{}re writing to the path. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!Append\+Separator@{Append\+Separator}}
\index{Append\+Separator@{Append\+Separator}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{Append\+Separator(\+Path\+Iterator\+\_\+t $\ast$iter\+Ptr)}{AppendSeparator(PathIterator_t *iterPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf le\+\_\+result\+\_\+t} Append\+Separator (
\begin{DoxyParamCaption}
\item[{{\bf Path\+Iterator\+\_\+t} $\ast$}]{iter\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_iter_8c_a20dfab5e479136b01383c7f1e8d41ab6}{}\label{path_iter_8c_a20dfab5e479136b01383c7f1e8d41ab6}
Check the current path to see if it currently ends in a separator, and if not, append one.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if the trailing separator fit within the string. L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if not. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em iter\+Ptr} & The iterator to update. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!Ends\+In\+Parent\+Spec@{Ends\+In\+Parent\+Spec}}
\index{Ends\+In\+Parent\+Spec@{Ends\+In\+Parent\+Spec}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{Ends\+In\+Parent\+Spec(const Path\+Iterator\+\_\+t $\ast$iter\+Ptr)}{EndsInParentSpec(const PathIterator_t *iterPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool Ends\+In\+Parent\+Spec (
\begin{DoxyParamCaption}
\item[{const {\bf Path\+Iterator\+\_\+t} $\ast$}]{iter\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_iter_8c_a7499735013bfcc387e4c7b1b0534abc7}{}\label{path_iter_8c_a7499735013bfcc387e4c7b1b0534abc7}
Check the current path to see if it currently ends in a parent specification.

\begin{DoxyReturn}{Returns}
True if it does, false if not. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em iter\+Ptr} & The iterator to check. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!Ends\+With\+Separator@{Ends\+With\+Separator}}
\index{Ends\+With\+Separator@{Ends\+With\+Separator}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{Ends\+With\+Separator(const Path\+Iterator\+\_\+t $\ast$iter\+Ptr)}{EndsWithSeparator(const PathIterator_t *iterPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool Ends\+With\+Separator (
\begin{DoxyParamCaption}
\item[{const {\bf Path\+Iterator\+\_\+t} $\ast$}]{iter\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_iter_8c_a617925dad65206502ab6ef6fb2e8b510}{}\label{path_iter_8c_a617925dad65206502ab6ef6fb2e8b510}
Check the current path to see if it currently ends in a separator.

\begin{DoxyReturn}{Returns}
True if it does, false if not. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em iter\+Ptr} & The iterator path to read. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!Find\+Next\+Node\+Index@{Find\+Next\+Node\+Index}}
\index{Find\+Next\+Node\+Index@{Find\+Next\+Node\+Index}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{Find\+Next\+Node\+Index(const char $\ast$path\+Str, size\+\_\+t path\+Size, const char $\ast$sep\+Str, size\+\_\+t sep\+Size, size\+\_\+t start\+Point)}{FindNextNodeIndex(const char *pathStr, size_t pathSize, const char *sepStr, size_t sepSize, size_t startPoint)}}]{\setlength{\rightskip}{0pt plus 5cm}static ssize\+\_\+t Find\+Next\+Node\+Index (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Str, }
\item[{size\+\_\+t}]{path\+Size, }
\item[{const char $\ast$}]{sep\+Str, }
\item[{size\+\_\+t}]{sep\+Size, }
\item[{size\+\_\+t}]{start\+Point}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_iter_8c_a466a28b96e9eeb700ad7ab51825ef548}{}\label{path_iter_8c_a466a28b96e9eeb700ad7ab51825ef548}
Find the next start of node index in the given string, starting the search from the given position.

\begin{DoxyReturn}{Returns}
A position within the string if a next node is found. Otherwise path\+Size is returned. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Str} & The string to search. \\
\hline
\mbox{\tt in}  & {\em path\+Size} & Size of that string, in bytes. \\
\hline
\mbox{\tt in}  & {\em sep\+Str} & Path separator string to use. \\
\hline
\mbox{\tt in}  & {\em sep\+Size} & Size of the path separator in bytes. \\
\hline
\mbox{\tt in}  & {\em start\+Point} & Where to start in that search. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!Find\+Prev\+Node\+Index@{Find\+Prev\+Node\+Index}}
\index{Find\+Prev\+Node\+Index@{Find\+Prev\+Node\+Index}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{Find\+Prev\+Node\+Index(const Path\+Iterator\+\_\+t $\ast$iter\+Ptr, ssize\+\_\+t start\+Point)}{FindPrevNodeIndex(const PathIterator_t *iterPtr, ssize_t startPoint)}}]{\setlength{\rightskip}{0pt plus 5cm}static ssize\+\_\+t Find\+Prev\+Node\+Index (
\begin{DoxyParamCaption}
\item[{const {\bf Path\+Iterator\+\_\+t} $\ast$}]{iter\+Ptr, }
\item[{ssize\+\_\+t}]{start\+Point}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_iter_8c_a94519cbdc96eacad5288899af7513bdd}{}\label{path_iter_8c_a94519cbdc96eacad5288899af7513bdd}
Find the start of the previous node index in the given string. Starting this search from the given position.

\begin{DoxyReturn}{Returns}
The index of the beginning of the previous node. Or -\/1 if no node can be found. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ptr} & The iterator to search. \\
\hline
\mbox{\tt in}  & {\em start\+Point} & Where to start in that search. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!Get\+Path\+Iter\+Ptr@{Get\+Path\+Iter\+Ptr}}
\index{Get\+Path\+Iter\+Ptr@{Get\+Path\+Iter\+Ptr}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{Get\+Path\+Iter\+Ptr(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref)}{GetPathIterPtr(le_pathIter_Ref_t iterRef)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf Path\+Iterator\+\_\+t}$\ast$ Get\+Path\+Iter\+Ptr (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_iter_8c_ac3fb15e4a7ede25216d772b6bcf3496a}{}\label{path_iter_8c_ac3fb15e4a7ede25216d772b6bcf3496a}
Given an iterator safe reference, find the original object pointer. If this can not be done a fatal error is issued. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The ref to translate to a pointer. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!Is\+At\+Seperator@{Is\+At\+Seperator}}
\index{Is\+At\+Seperator@{Is\+At\+Seperator}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{Is\+At\+Seperator(const char $\ast$path\+Str, size\+\_\+t path\+Size, const char $\ast$sep\+Str, size\+\_\+t sep\+Size, size\+\_\+t current\+Position)}{IsAtSeperator(const char *pathStr, size_t pathSize, const char *sepStr, size_t sepSize, size_t currentPosition)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool Is\+At\+Seperator (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Str, }
\item[{size\+\_\+t}]{path\+Size, }
\item[{const char $\ast$}]{sep\+Str, }
\item[{size\+\_\+t}]{sep\+Size, }
\item[{size\+\_\+t}]{current\+Position}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_iter_8c_aba8da82fe54dc735b1490e66b12db6c3}{}\label{path_iter_8c_aba8da82fe54dc735b1490e66b12db6c3}
Check the string at the current postion and see if we\textquotesingle{}re currently sitting on a separator.

\begin{DoxyReturn}{Returns}
True if there is a separator at the current position, false if not. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Str} & The string to search. \\
\hline
\mbox{\tt in}  & {\em path\+Size} & Size of that string, in bytes. \\
\hline
\mbox{\tt in}  & {\em sep\+Str} & Path separator string to use. \\
\hline
\mbox{\tt in}  & {\em sep\+Size} & Size of the path separator in bytes. \\
\hline
\mbox{\tt in}  & {\em current\+Position} & The position to check. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Append@{le\+\_\+path\+Iter\+\_\+\+Append}}
\index{le\+\_\+path\+Iter\+\_\+\+Append@{le\+\_\+path\+Iter\+\_\+\+Append}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Append(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref, const char $\ast$path\+Str)}{le_pathIter_Append(le_pathIter_Ref_t iterRef, const char *pathStr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Append (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref, }
\item[{const char $\ast$}]{path\+Str}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_ae6aa59696c54d2523009037cc78f9725}{}\label{path_iter_8c_ae6aa59696c54d2523009037cc78f9725}
Take the new string path and combine it with the object\textquotesingle{}s existing path.

\begin{DoxyNote}{Note}
This function looks for the current and parent node strings and treats them specially. So, (assuming defaults,) combining the path \char`\"{}/a/b\char`\"{} with the path \char`\"{}../x\char`\"{} will give you the combined path of\+: \char`\"{}/a/x\char`\"{}.

Appending a non-\/relative path onto an existing path effectivly replaces the current path, for example, appending /a/rooted/path, onto the existing /a/seperate/path will given you the path\+: /a/rooted/path.

This will automatically reset the internal iterator to point at the end of the newly formed path. Also, this function always appends to the end of a path, ignoring the current position of the iterator.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if successful. L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if the output buffer is too small for the new string. L\+E\+\_\+\+U\+N\+D\+E\+R\+F\+L\+OW if combining the path the new path tries to traverse past the root. For example\+: \char`\"{}/a/b\char`\"{} + \char`\"{}../../../x\char`\"{} will result in L\+E\+\_\+\+U\+N\+D\+E\+R\+F\+L\+OW. However if the base path is relative, \char`\"{}a/b\char`\"{}, then the resulting string will be \char`\"{}../x\char`\"{} and a return code of L\+E\+\_\+\+OK. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The path object to write to. \\
\hline
\mbox{\tt in}  & {\em path\+Str} & The new path segment to append. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Clone@{le\+\_\+path\+Iter\+\_\+\+Clone}}
\index{le\+\_\+path\+Iter\+\_\+\+Clone@{le\+\_\+path\+Iter\+\_\+\+Clone}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Clone(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t original\+Ref)}{le_pathIter_Clone(le_pathIter_Ref_t originalRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Clone (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{original\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_a50349a6c2afa4415d65a6efd443894d3}{}\label{path_iter_8c_a50349a6c2afa4415d65a6efd443894d3}
Create a clone of an existing path iterator object.

\begin{DoxyReturn}{Returns}
A new path iterator object that is a duplicate of the original one. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em original\+Ref} & The path object to duplicate. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Create@{le\+\_\+path\+Iter\+\_\+\+Create}}
\index{le\+\_\+path\+Iter\+\_\+\+Create@{le\+\_\+path\+Iter\+\_\+\+Create}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Create(const char $\ast$path\+Ptr, const char $\ast$separator\+Ptr, const char $\ast$parent\+Spec\+Ptr, const char $\ast$current\+Spec\+Ptr)}{le_pathIter_Create(const char *pathPtr, const char *separatorPtr, const char *parentSpecPtr, const char *currentSpecPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Create (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Ptr, }
\item[{const char $\ast$}]{separator\+Ptr, }
\item[{const char $\ast$}]{parent\+Spec\+Ptr, }
\item[{const char $\ast$}]{current\+Spec\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_a73fac1b657b752b17395c66fb1ae324b}{}\label{path_iter_8c_a73fac1b657b752b17395c66fb1ae324b}
Create a new path iterator object. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Ptr} & Optional. Pointer to the inital path to use. \\
\hline
\mbox{\tt in}  & {\em separator\+Ptr} & Required. Path separator to use. The separator can not be N\+U\+LL or empty. \\
\hline
\mbox{\tt in}  & {\em parent\+Spec\+Ptr} & Optional. Used to traverse upwards in a path. Leave as N\+U\+LL or empty to not use. \\
\hline
\mbox{\tt in}  & {\em current\+Spec\+Ptr} & Optional. Used to refer to a current node. Much like how a \textquotesingle{}.\textquotesingle{} is use in a filesystem path. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix@{le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix}}
\index{le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix@{le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix(const char $\ast$path\+Ptr)}{le_pathIter_CreateForUnix(const char *pathPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Create\+For\+Unix (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_a35a38b307f9fdc0de82552e96a5a2d1d}{}\label{path_iter_8c_a35a38b307f9fdc0de82552e96a5a2d1d}
Create a new path iterator object that is pre-\/configured for Unix styled paths.

\begin{DoxyReturn}{Returns}
A new path iterator object that\textquotesingle{}s ready for iterating on Unix paths. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Ptr} & Optional. Create an iterator for this path, or start with an empty path. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Delete@{le\+\_\+path\+Iter\+\_\+\+Delete}}
\index{le\+\_\+path\+Iter\+\_\+\+Delete@{le\+\_\+path\+Iter\+\_\+\+Delete}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Delete(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref)}{le_pathIter_Delete(le_pathIter_Ref_t iterRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+path\+Iter\+\_\+\+Delete (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_a6b57267a2c0db0210aab96c66459f9a1}{}\label{path_iter_8c_a6b57267a2c0db0210aab96c66459f9a1}
Delete an iterator object and free it\textquotesingle{}s memory. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to destroy. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node@{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node}}
\index{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node@{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)}{le_pathIter_GetCurrentNode(le_pathIter_Ref_t iterRef, char *bufferPtr, size_t bufferSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Node (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref, }
\item[{char $\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t}]{buffer\+Size}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_ab00916d853b3a869748b0195cc2a8f11}{}\label{path_iter_8c_ab00916d853b3a869748b0195cc2a8f11}
Get the text for the node the iterator is pointing at.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if succesful. L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if the buffer\+Ptr is too small to hold the whole string. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to read. \\
\hline
\mbox{\tt out}  & {\em buffer\+Ptr} & The utf-\/8 formatted text buffer to write to. \\
\hline
\mbox{\tt in}  & {\em buffer\+Size} & The size in bytes of the text buffer. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier@{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier}}
\index{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier@{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)}{le_pathIter_GetCurrentSpecifier(le_pathIter_Ref_t iterRef, char *bufferPtr, size_t bufferSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Get\+Current\+Specifier (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref, }
\item[{char $\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t}]{buffer\+Size}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_ac12ea9bbe193fd9239abd10a4b07feba}{}\label{path_iter_8c_ac12ea9bbe193fd9239abd10a4b07feba}
Read the iterators string for the current node specifier. The for Unix style paths for this is \char`\"{}.\char`\"{}. If an empty string is used, then this is ignored for the purposes of appending and normalizing paths. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to read. \\
\hline
\mbox{\tt out}  & {\em buffer\+Ptr} & The string buffer to write to. \\
\hline
\mbox{\tt in}  & {\em buffer\+Size} & The size of the string buffer being written to. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier@{le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier}}
\index{le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier@{le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)}{le_pathIter_GetParentSpecifier(le_pathIter_Ref_t iterRef, char *bufferPtr, size_t bufferSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Get\+Parent\+Specifier (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref, }
\item[{char $\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t}]{buffer\+Size}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_af1707a310401be209aeada07f6d0f43f}{}\label{path_iter_8c_af1707a310401be209aeada07f6d0f43f}
Read the string that represents parent nodes in a path string. By for Unix style paths this is \char`\"{}..\char`\"{}. If an empty string is used, then it is ignored for the purposes of appending and normalizing paths. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to read. \\
\hline
\mbox{\tt out}  & {\em buffer\+Ptr} & The string buffer to write to. \\
\hline
\mbox{\tt in}  & {\em buffer\+Size} & The size of the buffer being written to. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Get\+Path@{le\+\_\+path\+Iter\+\_\+\+Get\+Path}}
\index{le\+\_\+path\+Iter\+\_\+\+Get\+Path@{le\+\_\+path\+Iter\+\_\+\+Get\+Path}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Get\+Path(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)}{le_pathIter_GetPath(le_pathIter_Ref_t iterRef, char *bufferPtr, size_t bufferSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Get\+Path (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref, }
\item[{char $\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t}]{buffer\+Size}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_a4a1c39584a779518395b41f957765283}{}\label{path_iter_8c_a4a1c39584a779518395b41f957765283}
Get a copy of the path currently contained within the iterator. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to read. \\
\hline
\mbox{\tt out}  & {\em buffer\+Ptr} & The string buffer to write to. \\
\hline
\mbox{\tt in}  & {\em buffer\+Size} & The size of the buffer being written to. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Get\+Separator@{le\+\_\+path\+Iter\+\_\+\+Get\+Separator}}
\index{le\+\_\+path\+Iter\+\_\+\+Get\+Separator@{le\+\_\+path\+Iter\+\_\+\+Get\+Separator}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Get\+Separator(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref, char $\ast$buffer\+Ptr, size\+\_\+t buffer\+Size)}{le_pathIter_GetSeparator(le_pathIter_Ref_t iterRef, char *bufferPtr, size_t bufferSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Get\+Separator (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref, }
\item[{char $\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t}]{buffer\+Size}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_a586cd64de7f1a6797da3a17896946ee5}{}\label{path_iter_8c_a586cd64de7f1a6797da3a17896946ee5}
Read the string that is being used to represent path separators in this iterator object. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to read. \\
\hline
\mbox{\tt out}  & {\em buffer\+Ptr} & The string buffer to write to. \\
\hline
\mbox{\tt in}  & {\em buffer\+Size} & The size of the buffer being written to. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Go\+To\+End@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+End}}
\index{le\+\_\+path\+Iter\+\_\+\+Go\+To\+End@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+End}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Go\+To\+End(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref)}{le_pathIter_GoToEnd(le_pathIter_Ref_t iterRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Go\+To\+End (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_ab1c0b90132171b3f3cf5cfb614329b13}{}\label{path_iter_8c_ab1c0b90132171b3f3cf5cfb614329b13}
Jump the iterator to the end of the path.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if the move was successful. L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND if the path is empty, or only contains a separator. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to update. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next}}
\index{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref)}{le_pathIter_GoToNext(le_pathIter_Ref_t iterRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Go\+To\+Next (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_ad83a619dcc34ecf03da1859b3da2f57f}{}\label{path_iter_8c_ad83a619dcc34ecf03da1859b3da2f57f}
Move to the next node in the path.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if the itrator was successful in jumping to the next node. L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND is returned if there are no more nodes to move to in the path. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to update. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev}}
\index{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref)}{le_pathIter_GoToPrev(le_pathIter_Ref_t iterRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Go\+To\+Prev (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_a92a740759fe5c3b0a18e39dd8c73466b}{}\label{path_iter_8c_a92a740759fe5c3b0a18e39dd8c73466b}
Move to the previous node in the path.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if the iterator was successfuly moved, L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND if there are no prior nodes to move to. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to update. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start}}
\index{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start@{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref)}{le_pathIter_GoToStart(le_pathIter_Ref_t iterRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+Iter\+\_\+\+Go\+To\+Start (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_af4352480ab3c9ffb09e740f2899d504e}{}\label{path_iter_8c_af4352480ab3c9ffb09e740f2899d504e}
Jump the iterator to the beginning of the path.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if the move was successful. L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND if the path is empty, or only contains a separator. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to update. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Is\+Absolute@{le\+\_\+path\+Iter\+\_\+\+Is\+Absolute}}
\index{le\+\_\+path\+Iter\+\_\+\+Is\+Absolute@{le\+\_\+path\+Iter\+\_\+\+Is\+Absolute}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Is\+Absolute(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref)}{le_pathIter_IsAbsolute(le_pathIter_Ref_t iterRef)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+path\+Iter\+\_\+\+Is\+Absolute (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_a657f779873a2220f463f705298c1399f}{}\label{path_iter_8c_a657f779873a2220f463f705298c1399f}
Is this an absolute or relative path?

\begin{DoxyReturn}{Returns}
True if the path is rooted, that is that it begins with a separator. False if the path is considered relative. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator object to read. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Is\+Empty@{le\+\_\+path\+Iter\+\_\+\+Is\+Empty}}
\index{le\+\_\+path\+Iter\+\_\+\+Is\+Empty@{le\+\_\+path\+Iter\+\_\+\+Is\+Empty}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Is\+Empty(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref)}{le_pathIter_IsEmpty(le_pathIter_Ref_t iterRef)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+path\+Iter\+\_\+\+Is\+Empty (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_ab4ceddae696158d04fdbc1802614c5d6}{}\label{path_iter_8c_ab4ceddae696158d04fdbc1802614c5d6}
Is the path object holding an empty string?

\begin{DoxyReturn}{Returns}
True if the path is empty, false if not. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em iter\+Ref} & The path object to read. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!le\+\_\+path\+Iter\+\_\+\+Truncate@{le\+\_\+path\+Iter\+\_\+\+Truncate}}
\index{le\+\_\+path\+Iter\+\_\+\+Truncate@{le\+\_\+path\+Iter\+\_\+\+Truncate}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+Iter\+\_\+\+Truncate(le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t iter\+Ref)}{le_pathIter_Truncate(le_pathIter_Ref_t iterRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+path\+Iter\+\_\+\+Truncate (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+path\+Iter\+\_\+\+Ref\+\_\+t}}]{iter\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_a04be1341536a3e330a815171e7cdbf7a}{}\label{path_iter_8c_a04be1341536a3e330a815171e7cdbf7a}
Truncate the path at the current iterator node. If the iterator is at the beginning of the path, then the whole path is cleared. If the iterator is at the end of the path, then nothing happens.

Once done, then the iterator will be pointing at the new end of the path. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iter\+Ref} & The iterator to update. \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!Node\+Equal@{Node\+Equal}}
\index{Node\+Equal@{Node\+Equal}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{Node\+Equal(const char $\ast$path\+Str\+Ptr, const char $\ast$compare\+Ptr, size\+\_\+t compare\+Size, const char $\ast$separator\+Ptr, size\+\_\+t separator\+Size)}{NodeEqual(const char *pathStrPtr, const char *comparePtr, size_t compareSize, const char *separatorPtr, size_t separatorSize)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool Node\+Equal (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Str\+Ptr, }
\item[{const char $\ast$}]{compare\+Ptr, }
\item[{size\+\_\+t}]{compare\+Size, }
\item[{const char $\ast$}]{separator\+Ptr, }
\item[{size\+\_\+t}]{separator\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_iter_8c_a79daeda2b90f10381bdedea01e8b262c}{}\label{path_iter_8c_a79daeda2b90f10381bdedea01e8b262c}
Check to see if the current node string is equal to the comparison string. Comparison stops at either the end of the source string or at the beginning of the next separator.

So, given the path string\+: \char`\"{}things/and/stuff\char`\"{} or simply \char`\"{}things\char`\"{}, compared with the string\+: \char`\"{}things\char`\"{} this function will return true.

If path string was\+: \char`\"{}thingsand/stuff\char`\"{} then the function would return false.

\begin{DoxyReturn}{Returns}
True if the node matches the compare string, false otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Str\+Ptr} & Compare this string with compare\+Str. However, ignore \\
\hline
\mbox{\tt in}  & {\em compare\+Ptr} & The name we\textquotesingle{}re comparing to the node. \\
\hline
\mbox{\tt in}  & {\em compare\+Size} & How big is the compare string? \\
\hline
\mbox{\tt in}  & {\em separator\+Ptr} & The separators in the path. \\
\hline
\mbox{\tt in}  & {\em separator\+Size} & The size of the separators \\
\hline
\end{DoxyParams}
\index{path\+Iter.\+c@{path\+Iter.\+c}!path\+Iter\+\_\+\+Init@{path\+Iter\+\_\+\+Init}}
\index{path\+Iter\+\_\+\+Init@{path\+Iter\+\_\+\+Init}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{path\+Iter\+\_\+\+Init(void)}{pathIter_Init(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} path\+Iter\+\_\+\+Init (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{path_iter_8c_ab89601ee1ee30ba590989ede8dad248b}{}\label{path_iter_8c_ab89601ee1ee30ba590989ede8dad248b}
Initialize the path subsystem\textquotesingle{}s internal memory pools. This function is ment to be called from Legato\textquotesingle{}s internal init. \index{path\+Iter.\+c@{path\+Iter.\+c}!Reset\+Iterator@{Reset\+Iterator}}
\index{Reset\+Iterator@{Reset\+Iterator}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{Reset\+Iterator(\+Path\+Iterator\+\_\+t $\ast$iter\+Ptr)}{ResetIterator(PathIterator_t *iterPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Reset\+Iterator (
\begin{DoxyParamCaption}
\item[{{\bf Path\+Iterator\+\_\+t} $\ast$}]{iter\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_iter_8c_afe97246a010c2bea697404afc2a86d9d}{}\label{path_iter_8c_afe97246a010c2bea697404afc2a86d9d}
Reset the iterator indicies to their proper positions. With start index at the beginning, last and current at the end. 
\begin{DoxyParams}{Parameters}
{\em iter\+Ptr} & The iterator to reset. \\
\hline
\end{DoxyParams}


\subsection{Variable Documentation}
\index{path\+Iter.\+c@{path\+Iter.\+c}!Path\+Iterator\+Map@{Path\+Iterator\+Map}}
\index{Path\+Iterator\+Map@{Path\+Iterator\+Map}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{Path\+Iterator\+Map}{PathIteratorMap}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} Path\+Iterator\+Map = N\+U\+LL\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_iter_8c_a615a9810b19ab1a8b971a0da57f5078c}{}\label{path_iter_8c_a615a9810b19ab1a8b971a0da57f5078c}
Map of object refs to help validate external accesses to this A\+PI. \index{path\+Iter.\+c@{path\+Iter.\+c}!Path\+Iterator\+Pool@{Path\+Iterator\+Pool}}
\index{Path\+Iterator\+Pool@{Path\+Iterator\+Pool}!path\+Iter.\+c@{path\+Iter.\+c}}
\subsubsection[{\texorpdfstring{Path\+Iterator\+Pool}{PathIteratorPool}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} Path\+Iterator\+Pool = N\+U\+LL\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_iter_8c_acb091d1e9e4b0a7da772cbe76c7881eb}{}\label{path_iter_8c_acb091d1e9e4b0a7da772cbe76c7881eb}
Pool of path iterators. 