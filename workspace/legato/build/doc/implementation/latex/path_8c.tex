\hypertarget{path_8c}{}\section{framework/liblegato/linux/path.c File Reference}
\label{path_8c}\index{framework/liblegato/linux/path.\+c@{framework/liblegato/linux/path.\+c}}
{\ttfamily \#include \char`\"{}legato.\+h\char`\"{}}\\*
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static size\+\_\+t \hyperlink{path_8c_a6207d785a2b0406b4152bb9b266b49d1}{Find\+Next\+Path\+Char\+Index} (const char $\ast$str, const char $\ast$sep\+Ptr)
\item 
static size\+\_\+t \hyperlink{path_8c_ac01a2d335ee4fefe1e5e0d2897bd70f6}{Find\+Trailing\+Separator\+Index} (const char $\ast$str, const char $\ast$sep\+Ptr)
\item 
static size\+\_\+t \hyperlink{path_8c_a6d9e1b4334e976e9615fd724903b3664}{Get\+End\+Of\+Last\+Substr} (const char $\ast$str\+Ptr, const char $\ast$sub\+Str\+Ptr, size\+\_\+t end\+Index)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_8c_a0b0ff4c06db44de9bf4f40b9f5388785}{le\+\_\+path\+\_\+\+Get\+Dir} (const char $\ast$path\+Ptr, const char $\ast$separator\+Ptr, char $\ast$dir\+Ptr, size\+\_\+t dir\+Buff\+Size)
\item 
char $\ast$ \hyperlink{path_8c_aa58d208512dd5b9b2dc0ea6d5c963c25}{le\+\_\+path\+\_\+\+Get\+Basename\+Ptr} (const char $\ast$path\+Ptr, const char $\ast$separator\+Ptr)
\item 
static bool \hyperlink{path_8c_ad21811cefd17e5fb5bd7f05d5a021242}{Remove\+Duplicate\+Trailing\+Sep} (char $\ast$path\+Ptr, const char $\ast$separator\+Ptr, size\+\_\+t $\ast$len\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{path_8c_a5f0eb2e4882a70c5767cd325b8c5db23}{le\+\_\+path\+\_\+\+Concat} (const char $\ast$separator\+Ptr, char $\ast$path\+Ptr, size\+\_\+t path\+Size,...)
\item 
static bool \hyperlink{path_8c_acbe4fce285f67bbe00f7e7bb76e30f04}{Has\+Trailing\+Separator} (const char $\ast$path\+Ptr, const char $\ast$separator\+Ptr)
\item 
bool \hyperlink{path_8c_a7956881b55456ebfb69bf1e1d682d21d}{le\+\_\+path\+\_\+\+Is\+Subpath} (const char $\ast$path1\+Ptr, const char $\ast$path2\+Ptr, const char $\ast$separator\+Ptr)
\item 
bool \hyperlink{path_8c_a2fa2feacfb29b308d1b35cdfaa5b1716}{le\+\_\+path\+\_\+\+Is\+Equivalent} (const char $\ast$path1\+Ptr, const char $\ast$path2\+Ptr, const char $\ast$separator\+Ptr)
\item 
char $\ast$ \hyperlink{path_8c_a40d01b5a092fc0028bc46c129b9ae5c5}{le\+\_\+path\+\_\+\+Find\+Trailing} (const char $\ast$path\+Ptr, const char $\ast$ext\+Ptr)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Implements the path A\+PI.

Separators can be one or more characters. Path objects treat consecutive separators in a path as a single separator. Paths that begin with one or more separators are considered absolute paths.

Copyright (C) Sierra Wireless Inc. license. 

\subsection{Function Documentation}
\index{path.\+c@{path.\+c}!Find\+Next\+Path\+Char\+Index@{Find\+Next\+Path\+Char\+Index}}
\index{Find\+Next\+Path\+Char\+Index@{Find\+Next\+Path\+Char\+Index}!path.\+c@{path.\+c}}
\subsubsection[{\texorpdfstring{Find\+Next\+Path\+Char\+Index(const char $\ast$str, const char $\ast$sep\+Ptr)}{FindNextPathCharIndex(const char *str, const char *sepPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static size\+\_\+t Find\+Next\+Path\+Char\+Index (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{str, }
\item[{const char $\ast$}]{sep\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_8c_a6207d785a2b0406b4152bb9b266b49d1}{}\label{path_8c_a6207d785a2b0406b4152bb9b266b49d1}
Finds the index of the next character that is not a separator in the str.

\begin{DoxyReturn}{Returns}
The index of the first character that is not a separator. This might be the null-\/terminator. 
\end{DoxyReturn}
\index{path.\+c@{path.\+c}!Find\+Trailing\+Separator\+Index@{Find\+Trailing\+Separator\+Index}}
\index{Find\+Trailing\+Separator\+Index@{Find\+Trailing\+Separator\+Index}!path.\+c@{path.\+c}}
\subsubsection[{\texorpdfstring{Find\+Trailing\+Separator\+Index(const char $\ast$str, const char $\ast$sep\+Ptr)}{FindTrailingSeparatorIndex(const char *str, const char *sepPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static size\+\_\+t Find\+Trailing\+Separator\+Index (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{str, }
\item[{const char $\ast$}]{sep\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_8c_ac01a2d335ee4fefe1e5e0d2897bd70f6}{}\label{path_8c_ac01a2d335ee4fefe1e5e0d2897bd70f6}
Finds the index of the trailing separators.

\begin{DoxyReturn}{Returns}
The index of the first trailing separator. The index of the N\+U\+L\+L-\/terminator if there are no trailing separators. 
\end{DoxyReturn}
\index{path.\+c@{path.\+c}!Get\+End\+Of\+Last\+Substr@{Get\+End\+Of\+Last\+Substr}}
\index{Get\+End\+Of\+Last\+Substr@{Get\+End\+Of\+Last\+Substr}!path.\+c@{path.\+c}}
\subsubsection[{\texorpdfstring{Get\+End\+Of\+Last\+Substr(const char $\ast$str\+Ptr, const char $\ast$sub\+Str\+Ptr, size\+\_\+t end\+Index)}{GetEndOfLastSubstr(const char *strPtr, const char *subStrPtr, size_t endIndex)}}]{\setlength{\rightskip}{0pt plus 5cm}static size\+\_\+t Get\+End\+Of\+Last\+Substr (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{str\+Ptr, }
\item[{const char $\ast$}]{sub\+Str\+Ptr, }
\item[{size\+\_\+t}]{end\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_8c_a6d9e1b4334e976e9615fd724903b3664}{}\label{path_8c_a6d9e1b4334e976e9615fd724903b3664}
Searches backwards in str starting at end\+Index for sub\+Ptr and returns the index of the character following the end of the substr.

\begin{DoxyReturn}{Returns}
The index of character following the end of the sub\+Ptr. Zero is returned if the sub\+Ptr is not found. 
\end{DoxyReturn}
\index{path.\+c@{path.\+c}!Has\+Trailing\+Separator@{Has\+Trailing\+Separator}}
\index{Has\+Trailing\+Separator@{Has\+Trailing\+Separator}!path.\+c@{path.\+c}}
\subsubsection[{\texorpdfstring{Has\+Trailing\+Separator(const char $\ast$path\+Ptr, const char $\ast$separator\+Ptr)}{HasTrailingSeparator(const char *pathPtr, const char *separatorPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool Has\+Trailing\+Separator (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Ptr, }
\item[{const char $\ast$}]{separator\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_8c_acbe4fce285f67bbe00f7e7bb76e30f04}{}\label{path_8c_acbe4fce285f67bbe00f7e7bb76e30f04}
Checks if path has a trailing separator.

\begin{DoxyReturn}{Returns}
true if path ends with a separator. false otherwise. 
\end{DoxyReturn}
\index{path.\+c@{path.\+c}!le\+\_\+path\+\_\+\+Concat@{le\+\_\+path\+\_\+\+Concat}}
\index{le\+\_\+path\+\_\+\+Concat@{le\+\_\+path\+\_\+\+Concat}!path.\+c@{path.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+\_\+\+Concat(const char $\ast$separator\+Ptr, char $\ast$path\+Ptr, size\+\_\+t path\+Size,...)}{le_path_Concat(const char *separatorPtr, char *pathPtr, size_t pathSize,...)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+\_\+\+Concat (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{separator\+Ptr, }
\item[{char $\ast$}]{path\+Ptr, }
\item[{size\+\_\+t}]{path\+Size, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{path_8c_a5f0eb2e4882a70c5767cd325b8c5db23}{}\label{path_8c_a5f0eb2e4882a70c5767cd325b8c5db23}
Concatenates multiple path segments together.

Concatenates the path in the path\+Ptr buffer with all path segments and stores the result in the path\+Ptr. Ensures that where path segments are joined there is only one separator between them. Duplicate trailing separators in the resultant path are also dropped.

If there is not enough space in path\+Ptr for all segments, as many characters from the segments that will fit in the buffer will be copied and L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW will be returned. Partial U\+T\+F-\/8 characters and partial separators will never be copied.

\begin{DoxyWarning}{Warning}
The (char$\ast$)N\+U\+LL at the end of the list of path segments is mandatory. If this N\+U\+LL is omitted the behaviour is undefined.
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if successful. L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if there was not enough buffer space in path\+Ptr for all segments. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em separator\+Ptr} & Separator string. \\
\hline
\mbox{\tt in,out}  & {\em path\+Ptr} & Buffer containing the first segment and where the resultant path will be stored. \\
\hline
\mbox{\tt in}  & {\em path\+Size} & Buffer size. \\
\hline
\end{DoxyParams}
\index{path.\+c@{path.\+c}!le\+\_\+path\+\_\+\+Find\+Trailing@{le\+\_\+path\+\_\+\+Find\+Trailing}}
\index{le\+\_\+path\+\_\+\+Find\+Trailing@{le\+\_\+path\+\_\+\+Find\+Trailing}!path.\+c@{path.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+\_\+\+Find\+Trailing(const char $\ast$path\+Ptr, const char $\ast$ext\+Ptr)}{le_path_FindTrailing(const char *pathPtr, const char *extPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ le\+\_\+path\+\_\+\+Find\+Trailing (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Ptr, }
\item[{const char $\ast$}]{ext\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{path_8c_a40d01b5a092fc0028bc46c129b9ae5c5}{}\label{path_8c_a40d01b5a092fc0028bc46c129b9ae5c5}
Checks if a path has a particular trailing substring. For example, path

path\+Ptr = /path/to/file.txt

contains a trailing substring

ext\+Ptr = .txt

\begin{DoxyReturn}{Returns}
pointer to existing trailing susbstring within path, or N\+U\+LL otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Ptr} & Path string. \\
\hline
\mbox{\tt in}  & {\em ext\+Ptr} & Trailing substring. \\
\hline
\end{DoxyParams}
\index{path.\+c@{path.\+c}!le\+\_\+path\+\_\+\+Get\+Basename\+Ptr@{le\+\_\+path\+\_\+\+Get\+Basename\+Ptr}}
\index{le\+\_\+path\+\_\+\+Get\+Basename\+Ptr@{le\+\_\+path\+\_\+\+Get\+Basename\+Ptr}!path.\+c@{path.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+\_\+\+Get\+Basename\+Ptr(const char $\ast$path\+Ptr, const char $\ast$separator\+Ptr)}{le_path_GetBasenamePtr(const char *pathPtr, const char *separatorPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ le\+\_\+path\+\_\+\+Get\+Basename\+Ptr (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Ptr, }
\item[{const char $\ast$}]{separator\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{path_8c_aa58d208512dd5b9b2dc0ea6d5c963c25}{}\label{path_8c_aa58d208512dd5b9b2dc0ea6d5c963c25}
Gets a pointer to the basename (the last node in the path). This function gets the basename by simply returning a pointer to the character following the last separator.

\begin{DoxyReturn}{Returns}
A pointer to the character following the last separator. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Ptr} & The path string. \\
\hline
\mbox{\tt in}  & {\em separator\+Ptr} & The separator string. \\
\hline
\end{DoxyParams}
\index{path.\+c@{path.\+c}!le\+\_\+path\+\_\+\+Get\+Dir@{le\+\_\+path\+\_\+\+Get\+Dir}}
\index{le\+\_\+path\+\_\+\+Get\+Dir@{le\+\_\+path\+\_\+\+Get\+Dir}!path.\+c@{path.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+\_\+\+Get\+Dir(const char $\ast$path\+Ptr, const char $\ast$separator\+Ptr, char $\ast$dir\+Ptr, size\+\_\+t dir\+Buff\+Size)}{le_path_GetDir(const char *pathPtr, const char *separatorPtr, char *dirPtr, size_t dirBuffSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+\_\+\+Get\+Dir (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Ptr, }
\item[{const char $\ast$}]{separator\+Ptr, }
\item[{char $\ast$}]{dir\+Ptr, }
\item[{size\+\_\+t}]{dir\+Buff\+Size}
\end{DoxyParamCaption}
)}\hypertarget{path_8c_a0b0ff4c06db44de9bf4f40b9f5388785}{}\label{path_8c_a0b0ff4c06db44de9bf4f40b9f5388785}
Gets the directory, which is the entire path up to and including the last separator.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if succesful. L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if the dir\+Ptr buffer is too small. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Ptr} & The path string. \\
\hline
\mbox{\tt in}  & {\em separator\+Ptr} & The separator string. \\
\hline
\mbox{\tt out}  & {\em dir\+Ptr} & The buffer to store the directory string. \\
\hline
\mbox{\tt in}  & {\em dir\+Buff\+Size} & The size of the directory buffer in bytes. \\
\hline
\end{DoxyParams}
\index{path.\+c@{path.\+c}!le\+\_\+path\+\_\+\+Is\+Equivalent@{le\+\_\+path\+\_\+\+Is\+Equivalent}}
\index{le\+\_\+path\+\_\+\+Is\+Equivalent@{le\+\_\+path\+\_\+\+Is\+Equivalent}!path.\+c@{path.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+\_\+\+Is\+Equivalent(const char $\ast$path1\+Ptr, const char $\ast$path2\+Ptr, const char $\ast$separator\+Ptr)}{le_path_IsEquivalent(const char *path1Ptr, const char *path2Ptr, const char *separatorPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+path\+\_\+\+Is\+Equivalent (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path1\+Ptr, }
\item[{const char $\ast$}]{path2\+Ptr, }
\item[{const char $\ast$}]{separator\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{path_8c_a2fa2feacfb29b308d1b35cdfaa5b1716}{}\label{path_8c_a2fa2feacfb29b308d1b35cdfaa5b1716}
Checks if path1 and path2 are equivalent, ignoring trailing separators. For example, all the following paths are equivalent.

/a/b/c /a/b/c/ /a/b/c///

\begin{DoxyReturn}{Returns}
true if path1 is equivalent to path2. false otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path1\+Ptr} & Path 1 string. \\
\hline
\mbox{\tt in}  & {\em path2\+Ptr} & Path 2 string. \\
\hline
\mbox{\tt in}  & {\em separator\+Ptr} & Separator string. \\
\hline
\end{DoxyParams}
\index{path.\+c@{path.\+c}!le\+\_\+path\+\_\+\+Is\+Subpath@{le\+\_\+path\+\_\+\+Is\+Subpath}}
\index{le\+\_\+path\+\_\+\+Is\+Subpath@{le\+\_\+path\+\_\+\+Is\+Subpath}!path.\+c@{path.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+\_\+\+Is\+Subpath(const char $\ast$path1\+Ptr, const char $\ast$path2\+Ptr, const char $\ast$separator\+Ptr)}{le_path_IsSubpath(const char *path1Ptr, const char *path2Ptr, const char *separatorPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+path\+\_\+\+Is\+Subpath (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path1\+Ptr, }
\item[{const char $\ast$}]{path2\+Ptr, }
\item[{const char $\ast$}]{separator\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{path_8c_a7956881b55456ebfb69bf1e1d682d21d}{}\label{path_8c_a7956881b55456ebfb69bf1e1d682d21d}
Checks if path2 is a subpath of path1. That is path2 has the same starting nodes as path2. For example, path2 is a subpath of path1 if\+:

path1 = /a/b/c path2 = /a/b/c/d/e

\begin{DoxyReturn}{Returns}
true if path2 is a subpath of path1. false otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path1\+Ptr} & Path 1 string. \\
\hline
\mbox{\tt in}  & {\em path2\+Ptr} & Path 2 string. \\
\hline
\mbox{\tt in}  & {\em separator\+Ptr} & Separator string. \\
\hline
\end{DoxyParams}
\index{path.\+c@{path.\+c}!Remove\+Duplicate\+Trailing\+Sep@{Remove\+Duplicate\+Trailing\+Sep}}
\index{Remove\+Duplicate\+Trailing\+Sep@{Remove\+Duplicate\+Trailing\+Sep}!path.\+c@{path.\+c}}
\subsubsection[{\texorpdfstring{Remove\+Duplicate\+Trailing\+Sep(char $\ast$path\+Ptr, const char $\ast$separator\+Ptr, size\+\_\+t $\ast$len\+Ptr)}{RemoveDuplicateTrailingSep(char *pathPtr, const char *separatorPtr, size_t *lenPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool Remove\+Duplicate\+Trailing\+Sep (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{path\+Ptr, }
\item[{const char $\ast$}]{separator\+Ptr, }
\item[{size\+\_\+t $\ast$}]{len\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{path_8c_ad21811cefd17e5fb5bd7f05d5a021242}{}\label{path_8c_ad21811cefd17e5fb5bd7f05d5a021242}
Remove duplicate trailing separators from the path. If there are multiple trailing separators then all trailing separators except one are removed. If there are no trailing separators then nothing is changed.

\begin{DoxyReturn}{Returns}
true if duplicate trailing separators were successfully removed or there was already only a single trailing separator. false if there are no trailing separators in the path. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Ptr} & The path string. \\
\hline
\mbox{\tt in}  & {\em separator\+Ptr} & The separator string. \\
\hline
\mbox{\tt out}  & {\em len\+Ptr} & The resultant strings length. \\
\hline
\end{DoxyParams}
