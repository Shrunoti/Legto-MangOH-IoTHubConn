\hypertarget{le__path_8h}{}\section{framework/include/le\+\_\+path.h File Reference}
\label{le__path_8h}\index{framework/include/le\+\_\+path.\+h@{framework/include/le\+\_\+path.\+h}}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__path_8h_a0b0ff4c06db44de9bf4f40b9f5388785}{le\+\_\+path\+\_\+\+Get\+Dir} (const char $\ast$path\+Ptr, const char $\ast$separator\+Ptr, char $\ast$dir\+Ptr, size\+\_\+t dir\+Buff\+Size)
\item 
char $\ast$ \hyperlink{le__path_8h_aa58d208512dd5b9b2dc0ea6d5c963c25}{le\+\_\+path\+\_\+\+Get\+Basename\+Ptr} (const char $\ast$path\+Ptr, const char $\ast$separator\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__path_8h_a5f0eb2e4882a70c5767cd325b8c5db23}{le\+\_\+path\+\_\+\+Concat} (const char $\ast$separator\+Ptr, char $\ast$path\+Ptr, size\+\_\+t path\+Size,...)
\item 
bool \hyperlink{le__path_8h_a7956881b55456ebfb69bf1e1d682d21d}{le\+\_\+path\+\_\+\+Is\+Subpath} (const char $\ast$path1\+Ptr, const char $\ast$path2\+Ptr, const char $\ast$separator\+Ptr)
\item 
bool \hyperlink{le__path_8h_a2fa2feacfb29b308d1b35cdfaa5b1716}{le\+\_\+path\+\_\+\+Is\+Equivalent} (const char $\ast$path1\+Ptr, const char $\ast$path2\+Ptr, const char $\ast$separator\+Ptr)
\item 
char $\ast$ \hyperlink{le__path_8h_a40d01b5a092fc0028bc46c129b9ae5c5}{le\+\_\+path\+\_\+\+Find\+Trailing} (const char $\ast$path\+Ptr, const char $\ast$ext\+Ptr)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Legato \hyperlink{c_path}{Path A\+PI} include file.

Copyright (C) Sierra Wireless Inc. license. 

\subsection{Function Documentation}
\index{le\+\_\+path.\+h@{le\+\_\+path.\+h}!le\+\_\+path\+\_\+\+Concat@{le\+\_\+path\+\_\+\+Concat}}
\index{le\+\_\+path\+\_\+\+Concat@{le\+\_\+path\+\_\+\+Concat}!le\+\_\+path.\+h@{le\+\_\+path.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+\_\+\+Concat(const char $\ast$separator\+Ptr, char $\ast$path\+Ptr, size\+\_\+t path\+Size,...)}{le_path_Concat(const char *separatorPtr, char *pathPtr, size_t pathSize,...)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+\_\+\+Concat (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{separator\+Ptr, }
\item[{char $\ast$}]{path\+Ptr, }
\item[{size\+\_\+t}]{path\+Size, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{le__path_8h_a5f0eb2e4882a70c5767cd325b8c5db23}{}\label{le__path_8h_a5f0eb2e4882a70c5767cd325b8c5db23}
Concatenates multiple path segments together.

Concatenates the path in the path\+Ptr buffer with all path segments and stores the result in the path\+Ptr. Ensures that where path segments are joined there is only one separator between them. Duplicate trailing separators in the resultant path are also dropped.

If there is not enough space in path\+Ptr for all segments, as many characters from the segments that will fit in the buffer will be copied and L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW will be returned. Partial U\+T\+F-\/8 characters and partial separators will never be copied.

\begin{DoxyWarning}{Warning}
The (char$\ast$)N\+U\+LL at the end of the list of path segments is mandatory. If this N\+U\+LL is omitted the behaviour is undefined.
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if successful. L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if there was not enough buffer space in path\+Ptr for all segments. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em separator\+Ptr} & Separator string. \\
\hline
\mbox{\tt in,out}  & {\em path\+Ptr} & Buffer containing the first segment and where the resultant path will be stored. \\
\hline
\mbox{\tt in}  & {\em path\+Size} & Buffer size. \\
\hline
\end{DoxyParams}
\index{le\+\_\+path.\+h@{le\+\_\+path.\+h}!le\+\_\+path\+\_\+\+Find\+Trailing@{le\+\_\+path\+\_\+\+Find\+Trailing}}
\index{le\+\_\+path\+\_\+\+Find\+Trailing@{le\+\_\+path\+\_\+\+Find\+Trailing}!le\+\_\+path.\+h@{le\+\_\+path.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+\_\+\+Find\+Trailing(const char $\ast$path\+Ptr, const char $\ast$ext\+Ptr)}{le_path_FindTrailing(const char *pathPtr, const char *extPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ le\+\_\+path\+\_\+\+Find\+Trailing (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Ptr, }
\item[{const char $\ast$}]{ext\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__path_8h_a40d01b5a092fc0028bc46c129b9ae5c5}{}\label{le__path_8h_a40d01b5a092fc0028bc46c129b9ae5c5}
Checks if a path has a particular trailing substring. For example, path

path\+Ptr = /path/to/file.txt

contains a trailing substring

ext\+Ptr = .txt

\begin{DoxyReturn}{Returns}
pointer to existing trailing susbstring within path, or N\+U\+LL otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Ptr} & Path string. \\
\hline
\mbox{\tt in}  & {\em ext\+Ptr} & Trailing substring. \\
\hline
\end{DoxyParams}
\index{le\+\_\+path.\+h@{le\+\_\+path.\+h}!le\+\_\+path\+\_\+\+Get\+Basename\+Ptr@{le\+\_\+path\+\_\+\+Get\+Basename\+Ptr}}
\index{le\+\_\+path\+\_\+\+Get\+Basename\+Ptr@{le\+\_\+path\+\_\+\+Get\+Basename\+Ptr}!le\+\_\+path.\+h@{le\+\_\+path.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+\_\+\+Get\+Basename\+Ptr(const char $\ast$path\+Ptr, const char $\ast$separator\+Ptr)}{le_path_GetBasenamePtr(const char *pathPtr, const char *separatorPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ le\+\_\+path\+\_\+\+Get\+Basename\+Ptr (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Ptr, }
\item[{const char $\ast$}]{separator\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__path_8h_aa58d208512dd5b9b2dc0ea6d5c963c25}{}\label{le__path_8h_aa58d208512dd5b9b2dc0ea6d5c963c25}
Gets a pointer to the basename (the last node in the path). This function gets the basename by returning a pointer to the character following the last separator.

\begin{DoxyReturn}{Returns}
Pointer to the character following the last separator.
\end{DoxyReturn}
Gets a pointer to the basename (the last node in the path). This function gets the basename by simply returning a pointer to the character following the last separator.

\begin{DoxyReturn}{Returns}
A pointer to the character following the last separator. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Ptr} & The path string. \\
\hline
\mbox{\tt in}  & {\em separator\+Ptr} & The separator string. \\
\hline
\end{DoxyParams}
\index{le\+\_\+path.\+h@{le\+\_\+path.\+h}!le\+\_\+path\+\_\+\+Get\+Dir@{le\+\_\+path\+\_\+\+Get\+Dir}}
\index{le\+\_\+path\+\_\+\+Get\+Dir@{le\+\_\+path\+\_\+\+Get\+Dir}!le\+\_\+path.\+h@{le\+\_\+path.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+\_\+\+Get\+Dir(const char $\ast$path\+Ptr, const char $\ast$separator\+Ptr, char $\ast$dir\+Ptr, size\+\_\+t dir\+Buff\+Size)}{le_path_GetDir(const char *pathPtr, const char *separatorPtr, char *dirPtr, size_t dirBuffSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+path\+\_\+\+Get\+Dir (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Ptr, }
\item[{const char $\ast$}]{separator\+Ptr, }
\item[{char $\ast$}]{dir\+Ptr, }
\item[{size\+\_\+t}]{dir\+Buff\+Size}
\end{DoxyParamCaption}
)}\hypertarget{le__path_8h_a0b0ff4c06db44de9bf4f40b9f5388785}{}\label{le__path_8h_a0b0ff4c06db44de9bf4f40b9f5388785}
Gets the directory, which is the entire path up to and including the last separator.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if succesful. L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if the dir\+Ptr buffer is too small. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Ptr} & The path string. \\
\hline
\mbox{\tt in}  & {\em separator\+Ptr} & The separator string. \\
\hline
\mbox{\tt out}  & {\em dir\+Ptr} & The buffer to store the directory string. \\
\hline
\mbox{\tt in}  & {\em dir\+Buff\+Size} & The size of the directory buffer in bytes. \\
\hline
\end{DoxyParams}
\index{le\+\_\+path.\+h@{le\+\_\+path.\+h}!le\+\_\+path\+\_\+\+Is\+Equivalent@{le\+\_\+path\+\_\+\+Is\+Equivalent}}
\index{le\+\_\+path\+\_\+\+Is\+Equivalent@{le\+\_\+path\+\_\+\+Is\+Equivalent}!le\+\_\+path.\+h@{le\+\_\+path.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+\_\+\+Is\+Equivalent(const char $\ast$path1\+Ptr, const char $\ast$path2\+Ptr, const char $\ast$separator\+Ptr)}{le_path_IsEquivalent(const char *path1Ptr, const char *path2Ptr, const char *separatorPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+path\+\_\+\+Is\+Equivalent (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path1\+Ptr, }
\item[{const char $\ast$}]{path2\+Ptr, }
\item[{const char $\ast$}]{separator\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__path_8h_a2fa2feacfb29b308d1b35cdfaa5b1716}{}\label{le__path_8h_a2fa2feacfb29b308d1b35cdfaa5b1716}
Checks if path1 and path2 are equivalent, ignoring trailing separators. For example, all the following paths are equivalent.

/a/b/c /a/b/c/ /a/b/c///

\begin{DoxyReturn}{Returns}
true if path1 is equivalent to path2. false otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path1\+Ptr} & Path 1 string. \\
\hline
\mbox{\tt in}  & {\em path2\+Ptr} & Path 2 string. \\
\hline
\mbox{\tt in}  & {\em separator\+Ptr} & Separator string. \\
\hline
\end{DoxyParams}
\index{le\+\_\+path.\+h@{le\+\_\+path.\+h}!le\+\_\+path\+\_\+\+Is\+Subpath@{le\+\_\+path\+\_\+\+Is\+Subpath}}
\index{le\+\_\+path\+\_\+\+Is\+Subpath@{le\+\_\+path\+\_\+\+Is\+Subpath}!le\+\_\+path.\+h@{le\+\_\+path.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+path\+\_\+\+Is\+Subpath(const char $\ast$path1\+Ptr, const char $\ast$path2\+Ptr, const char $\ast$separator\+Ptr)}{le_path_IsSubpath(const char *path1Ptr, const char *path2Ptr, const char *separatorPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+path\+\_\+\+Is\+Subpath (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path1\+Ptr, }
\item[{const char $\ast$}]{path2\+Ptr, }
\item[{const char $\ast$}]{separator\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__path_8h_a7956881b55456ebfb69bf1e1d682d21d}{}\label{le__path_8h_a7956881b55456ebfb69bf1e1d682d21d}
Checks if path2 is a subpath of path1. That is path2 has the same starting nodes as path2. For example, path2 is a subpath of path1 if\+:

path1 = /a/b/c path2 = /a/b/c/d/e

\begin{DoxyReturn}{Returns}
true if path2 is a subpath of path1. false otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path1\+Ptr} & Path 1 string. \\
\hline
\mbox{\tt in}  & {\em path2\+Ptr} & Path 2 string. \\
\hline
\mbox{\tt in}  & {\em separator\+Ptr} & Separator string. \\
\hline
\end{DoxyParams}
