\hypertarget{namespaceparse_tree}{}\section{parse\+Tree Namespace Reference}
\label{namespaceparse_tree}\index{parse\+Tree@{parse\+Tree}}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structparse_tree_1_1_adef_file__t}{Adef\+File\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_app__t}{App\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_binding__t}{Binding\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_bundled_dir__t}{Bundled\+Dir\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_bundled_file__t}{Bundled\+File\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_cdef_file__t}{Cdef\+File\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_command__t}{Command\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_complex_section__t}{Complex\+Section\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_compound_item__t}{Compound\+Item\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_compound_item_list__t}{Compound\+Item\+List\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_content__t}{Content\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_def_file__t}{Def\+File\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_def_file_fragment__t}{Def\+File\+Fragment\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_env_var__t}{Env\+Var\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_executable__t}{Executable\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_extern_api_interface__t}{Extern\+Api\+Interface\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_mdef_file__t}{Mdef\+File\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_module__t}{Module\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_module_param__t}{Module\+Param\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_pool__t}{Pool\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_provided_api__t}{Provided\+Api\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_required_api__t}{Required\+Api\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_required_config_tree__t}{Required\+Config\+Tree\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_required_device__t}{Required\+Device\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_required_dir__t}{Required\+Dir\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_required_file__t}{Required\+File\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_run_process__t}{Run\+Process\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_sdef_file__t}{Sdef\+File\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_simple_section__t}{Simple\+Section\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_token__t}{Token\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_token_list__t}{Token\+List\+\_\+t}
\item 
struct \hyperlink{structparse_tree_1_1_token_list_section__t}{Token\+List\+Section\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structparse_tree_1_1_token_list__t}{Token\+List\+\_\+t} $\ast$ \hyperlink{namespaceparse_tree_a0963bfb44c05e1a51526921851f6510d}{Create\+Token\+List} (\hyperlink{structparse_tree_1_1_content__t_a45cc4a193beac87a2045a2f6b6870d1b}{Content\+\_\+t\+::\+Type\+\_\+t} content\+Type, \hyperlink{structparse_tree_1_1_token__t}{Token\+\_\+t} $\ast$first\+Token\+Ptr)
\item 
const \hyperlink{structparse_tree_1_1_simple_section__t}{Simple\+Section\+\_\+t} $\ast$ \hyperlink{namespaceparse_tree_aebd61e4868b274451e536881994e723b}{To\+Simple\+Section\+Ptr} (const \hyperlink{structparse_tree_1_1_content__t}{Content\+\_\+t} $\ast$content\+Item\+Ptr)
\item 
const \hyperlink{structparse_tree_1_1_token_list_section__t}{Token\+List\+Section\+\_\+t} $\ast$ \hyperlink{namespaceparse_tree_a0871ea3647e557df3fe1a779d47e579a}{To\+Token\+List\+Section\+Ptr} (const \hyperlink{structparse_tree_1_1_content__t}{Content\+\_\+t} $\ast$content\+Item\+Ptr)
\item 
const \hyperlink{structparse_tree_1_1_complex_section__t}{Complex\+Section\+\_\+t} $\ast$ \hyperlink{namespaceparse_tree_a190e5cd3f3b3240c53c58316186510b7}{To\+Complex\+Section\+Ptr} (const \hyperlink{structparse_tree_1_1_content__t}{Content\+\_\+t} $\ast$content\+Item\+Ptr)
\item 
const \hyperlink{structparse_tree_1_1_token_list__t}{Token\+List\+\_\+t} $\ast$ \hyperlink{namespaceparse_tree_a51a9485e3b99120976837970a1e461f8}{To\+Token\+List\+Ptr} (const \hyperlink{structparse_tree_1_1_content__t}{Content\+\_\+t} $\ast$content\+Item\+Ptr)
\item 
const \hyperlink{structparse_tree_1_1_compound_item_list__t}{Compound\+Item\+List\+\_\+t} $\ast$ \hyperlink{namespaceparse_tree_aaf48a0d53e9cbb87c733bf14be208f43}{To\+Compound\+Item\+List\+Ptr} (const \hyperlink{structparse_tree_1_1_content__t}{Content\+\_\+t} $\ast$content\+Item\+Ptr)
\item 
std\+::string \hyperlink{namespaceparse_tree_a30b566d7dfddf328f3f1c87723c2c693}{Do\+Substitution} (const std\+::string \&original\+String, const \hyperlink{structparse_tree_1_1_content__t}{parse\+Tree\+::\+Content\+\_\+t} $\ast$content\+Ptr=N\+U\+LL, std\+::set$<$ std\+::string $>$ $\ast$used\+Vars\+Ptr=N\+U\+LL)
\item 
std\+::string \hyperlink{namespaceparse_tree_a5cd61007054e0ad9019197c9aaad47a8}{Do\+Substitution} (const \hyperlink{structparse_tree_1_1_token__t}{Token\+\_\+t} $\ast$token\+Ptr, std\+::set$<$ std\+::string $>$ $\ast$used\+Vars\+Ptr=N\+U\+LL)
\item 
static bool \hyperlink{namespaceparse_tree_a7ebf69255296060028bb97815b9d6e14}{Is\+Valid\+First\+Char} (char check)
\item 
static bool \hyperlink{namespaceparse_tree_aa7b75069f3e5c90c816402a071c502ef}{Is\+Valid\+Char} (char check)
\item 
static size\+\_\+t \hyperlink{namespaceparse_tree_afb1767f79f562f030f87d31de2d7c243}{Find\+First\+Not\+Name\+Char} (const std\+::string \&original, size\+\_\+t begin)
\item 
static std\+::string \hyperlink{namespaceparse_tree_aab1c28a72e7c4ed2fe319da6abb6c048}{Extract\+Var\+Name} (const std\+::string \&original, size\+\_\+t begin, size\+\_\+t count)
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{namespaceparse_tree_a51f6ab1ef8e594d9c4b7604a6bacba01}{Eval\+Var} (std\+::string \&processed, const std\+::string \&original, const std\+::string \&var\+Name, std\+::set$<$ std\+::string $>$ $\ast$used\+Vars\+Ptr)
\item 
static size\+\_\+t \hyperlink{namespaceparse_tree_a6c9863715769b02d607b23e1542fa70e}{Handle\+Bracket\+Var} (const std\+::string \&original, std\+::string \&processed, size\+\_\+t begin, std\+::set$<$ std\+::string $>$ $\ast$used\+Vars\+Ptr)
\item 
static size\+\_\+t \hyperlink{namespaceparse_tree_a344bccc0ae017fa3e804a6dc454c0db2}{Handle\+Var} (const std\+::string \&original, std\+::string \&processed, size\+\_\+t begin, std\+::set$<$ std\+::string $>$ $\ast$used\+Vars\+Ptr)
\item 
static std\+::string \hyperlink{namespaceparse_tree_a33fa4585478bf3976a0aa24c251eb70e}{Do\+Substitution} (const std\+::string \&original, std\+::set$<$ std\+::string $>$ $\ast$used\+Vars\+Ptr)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{parse\+Tree@{parse\+Tree}!Create\+Token\+List@{Create\+Token\+List}}
\index{Create\+Token\+List@{Create\+Token\+List}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{Create\+Token\+List(\+Content\+\_\+t\+::\+Type\+\_\+t content\+Type, Token\+\_\+t $\ast$first\+Token\+Ptr)}{CreateTokenList(Content_t::Type_t contentType, Token_t *firstTokenPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Token\+List\+\_\+t} $\ast$ parse\+Tree\+::\+Create\+Token\+List (
\begin{DoxyParamCaption}
\item[{{\bf Content\+\_\+t\+::\+Type\+\_\+t}}]{content\+Type, }
\item[{{\bf Token\+\_\+t} $\ast$}]{first\+Token\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{namespaceparse_tree_a0963bfb44c05e1a51526921851f6510d}{}\label{namespaceparse_tree_a0963bfb44c05e1a51526921851f6510d}
Creates a new \hyperlink{structparse_tree_1_1_token_list__t}{Token\+List\+\_\+t} object of a given type.

\begin{DoxyReturn}{Returns}
a pointer to the new object. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em content\+Type} & The type of object to create. \\
\hline
{\em first\+Token\+Ptr} & Pointer to the first token in this part of the parse tree. \\
\hline
\end{DoxyParams}
\index{parse\+Tree@{parse\+Tree}!Do\+Substitution@{Do\+Substitution}}
\index{Do\+Substitution@{Do\+Substitution}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{Do\+Substitution(const std\+::string \&original\+String, const parse\+Tree\+::\+Content\+\_\+t $\ast$content\+Ptr=\+N\+U\+L\+L, std\+::set$<$ std\+::string $>$ $\ast$used\+Vars\+Ptr=\+N\+U\+L\+L)}{DoSubstitution(const std::string &originalString, const parseTree::Content_t *contentPtr=NULL, std::set< std::string > *usedVarsPtr=NULL)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string parse\+Tree\+::\+Do\+Substitution (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{original\+String, }
\item[{const {\bf parse\+Tree\+::\+Content\+\_\+t} $\ast$}]{content\+Ptr = {\ttfamily NULL}, }
\item[{std\+::set$<$ std\+::string $>$ $\ast$}]{used\+Vars\+Ptr = {\ttfamily NULL}}
\end{DoxyParamCaption}
)}\hypertarget{namespaceparse_tree_a30b566d7dfddf328f3f1c87723c2c693}{}\label{namespaceparse_tree_a30b566d7dfddf328f3f1c87723c2c693}
Look for environment variables (specified as \char`\"{}\$\+V\+A\+R\+\_\+\+N\+A\+M\+E\char`\"{} or \char`\"{}\$\{\+V\+A\+R\+\_\+\+N\+A\+M\+E\}\char`\"{}) in a given string and replace with environment variable contents.

This version of the function differs from Do\+Substitution in that variables like C\+U\+R\+D\+IR are handled relative to the content the string came from.

\begin{DoxyReturn}{Returns}
The converted string. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em used\+Vars\+Ptr} & If not null, returns a list of all variable names used in this substitution. \\
\hline
\end{DoxyParams}
\index{parse\+Tree@{parse\+Tree}!Do\+Substitution@{Do\+Substitution}}
\index{Do\+Substitution@{Do\+Substitution}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{Do\+Substitution(const Token\+\_\+t $\ast$token\+Ptr, std\+::set$<$ std\+::string $>$ $\ast$used\+Vars\+Ptr=\+N\+U\+L\+L)}{DoSubstitution(const Token_t *tokenPtr, std::set< std::string > *usedVarsPtr=NULL)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string parse\+Tree\+::\+Do\+Substitution (
\begin{DoxyParamCaption}
\item[{const {\bf Token\+\_\+t} $\ast$}]{token\+Ptr, }
\item[{std\+::set$<$ std\+::string $>$ $\ast$}]{used\+Vars\+Ptr = {\ttfamily NULL}}
\end{DoxyParamCaption}
)}\hypertarget{namespaceparse_tree_a5cd61007054e0ad9019197c9aaad47a8}{}\label{namespaceparse_tree_a5cd61007054e0ad9019197c9aaad47a8}
Exactly like the previous version of Do\+Substitution, except the context and the text are both automatically extracted from the token pointer.

\begin{DoxyReturn}{Returns}
The converted string. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em used\+Vars\+Ptr} & If not null, returns a list of all variable names used in this substitution. \\
\hline
\end{DoxyParams}
\index{parse\+Tree@{parse\+Tree}!Do\+Substitution@{Do\+Substitution}}
\index{Do\+Substitution@{Do\+Substitution}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{Do\+Substitution(const std\+::string \&original, std\+::set$<$ std\+::string $>$ $\ast$used\+Vars\+Ptr)}{DoSubstitution(const std::string &original, std::set< std::string > *usedVarsPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static std\+::string parse\+Tree\+::\+Do\+Substitution (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{original, }
\item[{std\+::set$<$ std\+::string $>$ $\ast$}]{used\+Vars\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{namespaceparse_tree_a33fa4585478bf3976a0aa24c251eb70e}{}\label{namespaceparse_tree_a33fa4585478bf3976a0aa24c251eb70e}
Look for environment variables (specified as \char`\"{}\$\+V\+A\+R\+\_\+\+N\+A\+M\+E\char`\"{} or \char`\"{}\$\{\+V\+A\+R\+\_\+\+N\+A\+M\+E\}\char`\"{}) in a given string and replace with environment variable contents.

\begin{DoxyReturn}{Returns}
The converted string. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em original} & Original string to subsitute variables in. \\
\hline
{\em used\+Vars\+Ptr} & If not null, record any variables found in original. \\
\hline
\end{DoxyParams}
\index{parse\+Tree@{parse\+Tree}!Eval\+Var@{Eval\+Var}}
\index{Eval\+Var@{Eval\+Var}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{Eval\+Var(std\+::string \&processed, const std\+::string \&original, const std\+::string \&var\+Name, std\+::set$<$ std\+::string $>$ $\ast$used\+Vars\+Ptr)}{EvalVar(std::string &processed, const std::string &original, const std::string &varName, std::set< std::string > *usedVarsPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} parse\+Tree\+::\+Eval\+Var (
\begin{DoxyParamCaption}
\item[{std\+::string \&}]{processed, }
\item[{const std\+::string \&}]{original, }
\item[{const std\+::string \&}]{var\+Name, }
\item[{std\+::set$<$ std\+::string $>$ $\ast$}]{used\+Vars\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{namespaceparse_tree_a51f6ab1ef8e594d9c4b7604a6bacba01}{}\label{namespaceparse_tree_a51f6ab1ef8e594d9c4b7604a6bacba01}
Given an environment variable name. Read it from the environment, make a note of the name, and append that var\textquotesingle{}s value into the output string.

Throw an exception if the name is empty. 
\begin{DoxyParams}{Parameters}
{\em processed} & The string we will dump the var value into. \\
\hline
{\em original} & The original string we pulled the name from. \\
\hline
{\em var\+Name} & The name of the varable we extracted. \\
\hline
{\em used\+Vars\+Ptr} & Record the found name in this set, if not null. \\
\hline
\end{DoxyParams}
\index{parse\+Tree@{parse\+Tree}!Extract\+Var\+Name@{Extract\+Var\+Name}}
\index{Extract\+Var\+Name@{Extract\+Var\+Name}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{Extract\+Var\+Name(const std\+::string \&original, size\+\_\+t begin, size\+\_\+t count)}{ExtractVarName(const std::string &original, size_t begin, size_t count)}}]{\setlength{\rightskip}{0pt plus 5cm}static std\+::string parse\+Tree\+::\+Extract\+Var\+Name (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{original, }
\item[{size\+\_\+t}]{begin, }
\item[{size\+\_\+t}]{count}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{namespaceparse_tree_aab1c28a72e7c4ed2fe319da6abb6c048}{}\label{namespaceparse_tree_aab1c28a72e7c4ed2fe319da6abb6c048}
Copy the name string out of the original string. Through an exception if an illegal char is found.

\begin{DoxyReturn}{Returns}
The name string extracted from the original. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em original} & Extract the variable name from this string. \\
\hline
{\em begin} & Start copying here. \\
\hline
{\em count} & Only copy this many chars. \\
\hline
\end{DoxyParams}
\index{parse\+Tree@{parse\+Tree}!Find\+First\+Not\+Name\+Char@{Find\+First\+Not\+Name\+Char}}
\index{Find\+First\+Not\+Name\+Char@{Find\+First\+Not\+Name\+Char}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{Find\+First\+Not\+Name\+Char(const std\+::string \&original, size\+\_\+t begin)}{FindFirstNotNameChar(const std::string &original, size_t begin)}}]{\setlength{\rightskip}{0pt plus 5cm}static size\+\_\+t parse\+Tree\+::\+Find\+First\+Not\+Name\+Char (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{original, }
\item[{size\+\_\+t}]{begin}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{namespaceparse_tree_afb1767f79f562f030f87d31de2d7c243}{}\label{namespaceparse_tree_afb1767f79f562f030f87d31de2d7c243}
Search the string from the beggining location and stop when an invalid character is found.

\begin{DoxyReturn}{Returns}
The position of the last valid character. 
\end{DoxyReturn}
\index{parse\+Tree@{parse\+Tree}!Handle\+Bracket\+Var@{Handle\+Bracket\+Var}}
\index{Handle\+Bracket\+Var@{Handle\+Bracket\+Var}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{Handle\+Bracket\+Var(const std\+::string \&original, std\+::string \&processed, size\+\_\+t begin, std\+::set$<$ std\+::string $>$ $\ast$used\+Vars\+Ptr)}{HandleBracketVar(const std::string &original, std::string &processed, size_t begin, std::set< std::string > *usedVarsPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static size\+\_\+t parse\+Tree\+::\+Handle\+Bracket\+Var (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{original, }
\item[{std\+::string \&}]{processed, }
\item[{size\+\_\+t}]{begin, }
\item[{std\+::set$<$ std\+::string $>$ $\ast$}]{used\+Vars\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{namespaceparse_tree_a6c9863715769b02d607b23e1542fa70e}{}\label{namespaceparse_tree_a6c9863715769b02d607b23e1542fa70e}
The calling function has found a bracketed var name at the location specified by \textquotesingle{}begin\textquotesingle{}. Extract the name, stopping at a closing bracket. Throw an exception if an illegal character is found within the name.

Once the name is read, look up it\textquotesingle{}s value and place this value into the output string.

\begin{DoxyReturn}{Returns}
Number of characters consumed in the original string. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em original} & The string to extract a var name from. \\
\hline
{\em processed} & The string we will dump the var value into. \\
\hline
{\em begin} & Start name extraction from here. \\
\hline
{\em used\+Vars\+Ptr} & Record the found name in this set, if not null. \\
\hline
\end{DoxyParams}
\index{parse\+Tree@{parse\+Tree}!Handle\+Var@{Handle\+Var}}
\index{Handle\+Var@{Handle\+Var}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{Handle\+Var(const std\+::string \&original, std\+::string \&processed, size\+\_\+t begin, std\+::set$<$ std\+::string $>$ $\ast$used\+Vars\+Ptr)}{HandleVar(const std::string &original, std::string &processed, size_t begin, std::set< std::string > *usedVarsPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static size\+\_\+t parse\+Tree\+::\+Handle\+Var (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{original, }
\item[{std\+::string \&}]{processed, }
\item[{size\+\_\+t}]{begin, }
\item[{std\+::set$<$ std\+::string $>$ $\ast$}]{used\+Vars\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{namespaceparse_tree_a344bccc0ae017fa3e804a6dc454c0db2}{}\label{namespaceparse_tree_a344bccc0ae017fa3e804a6dc454c0db2}
The calling function has found a var name at the location specified by begin in the original string. Read the full var name, stopping at either the end of the string or a non-\/name character.

Once the name is read, look up it\textquotesingle{}s value and place this value into the output string.

\begin{DoxyReturn}{Returns}
Number of characters consumed in the original string. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em original} & The string to extract a var name from. \\
\hline
{\em processed} & The string we will dump the var value into. \\
\hline
{\em begin} & Start name extraction from here. \\
\hline
{\em used\+Vars\+Ptr} & Record the found name in this set, if not null. \\
\hline
\end{DoxyParams}
\index{parse\+Tree@{parse\+Tree}!Is\+Valid\+Char@{Is\+Valid\+Char}}
\index{Is\+Valid\+Char@{Is\+Valid\+Char}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{Is\+Valid\+Char(char check)}{IsValidChar(char check)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool parse\+Tree\+::\+Is\+Valid\+Char (
\begin{DoxyParamCaption}
\item[{char}]{check}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{namespaceparse_tree_aa7b75069f3e5c90c816402a071c502ef}{}\label{namespaceparse_tree_aa7b75069f3e5c90c816402a071c502ef}
Check if the given character is a valid name character, this function is slightly less restrictive than Is\+Valid\+First\+Char.

\begin{DoxyReturn}{Returns}
A true if valid, false otherwise. 
\end{DoxyReturn}
\index{parse\+Tree@{parse\+Tree}!Is\+Valid\+First\+Char@{Is\+Valid\+First\+Char}}
\index{Is\+Valid\+First\+Char@{Is\+Valid\+First\+Char}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{Is\+Valid\+First\+Char(char check)}{IsValidFirstChar(char check)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool parse\+Tree\+::\+Is\+Valid\+First\+Char (
\begin{DoxyParamCaption}
\item[{char}]{check}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{namespaceparse_tree_a7ebf69255296060028bb97815b9d6e14}{}\label{namespaceparse_tree_a7ebf69255296060028bb97815b9d6e14}
Check if the given character is a invalid start of name character.

\begin{DoxyReturn}{Returns}
A true if valid, false otherwise. 
\end{DoxyReturn}
\index{parse\+Tree@{parse\+Tree}!To\+Complex\+Section\+Ptr@{To\+Complex\+Section\+Ptr}}
\index{To\+Complex\+Section\+Ptr@{To\+Complex\+Section\+Ptr}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{To\+Complex\+Section\+Ptr(const Content\+\_\+t $\ast$content\+Item\+Ptr)}{ToComplexSectionPtr(const Content_t *contentItemPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Complex\+Section\+\_\+t} $\ast$ parse\+Tree\+::\+To\+Complex\+Section\+Ptr (
\begin{DoxyParamCaption}
\item[{const {\bf Content\+\_\+t} $\ast$}]{content\+Item\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{namespaceparse_tree_a190e5cd3f3b3240c53c58316186510b7}{}\label{namespaceparse_tree_a190e5cd3f3b3240c53c58316186510b7}
Converts from a pointer to a \hyperlink{structparse_tree_1_1_content__t}{Content\+\_\+t} into a pointer to a \hyperlink{structparse_tree_1_1_complex_section__t}{Complex\+Section\+\_\+t}.

\begin{DoxyReturn}{Returns}
The same pointer, but with the type converted.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classmk_1_1_exception__t}{mk\+::\+Exception\+\_\+t}} & if the conversion is invalid. \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{Parameters}
{\em content\+Item\+Ptr} & The pointer to convert. \\
\hline
\end{DoxyParams}
\index{parse\+Tree@{parse\+Tree}!To\+Compound\+Item\+List\+Ptr@{To\+Compound\+Item\+List\+Ptr}}
\index{To\+Compound\+Item\+List\+Ptr@{To\+Compound\+Item\+List\+Ptr}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{To\+Compound\+Item\+List\+Ptr(const Content\+\_\+t $\ast$content\+Item\+Ptr)}{ToCompoundItemListPtr(const Content_t *contentItemPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Compound\+Item\+List\+\_\+t} $\ast$ parse\+Tree\+::\+To\+Compound\+Item\+List\+Ptr (
\begin{DoxyParamCaption}
\item[{const {\bf Content\+\_\+t} $\ast$}]{content\+Item\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{namespaceparse_tree_aaf48a0d53e9cbb87c733bf14be208f43}{}\label{namespaceparse_tree_aaf48a0d53e9cbb87c733bf14be208f43}
Converts from a pointer to a \hyperlink{structparse_tree_1_1_content__t}{Content\+\_\+t} into a pointer to a \hyperlink{structparse_tree_1_1_compound_item_list__t}{Compound\+Item\+List\+\_\+t}.

\begin{DoxyReturn}{Returns}
The same pointer, but with the type converted.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classmk_1_1_exception__t}{mk\+::\+Exception\+\_\+t}} & if the conversion is invalid. \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{Parameters}
{\em content\+Item\+Ptr} & The pointer to convert. \\
\hline
\end{DoxyParams}
\index{parse\+Tree@{parse\+Tree}!To\+Simple\+Section\+Ptr@{To\+Simple\+Section\+Ptr}}
\index{To\+Simple\+Section\+Ptr@{To\+Simple\+Section\+Ptr}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{To\+Simple\+Section\+Ptr(const Content\+\_\+t $\ast$content\+Item\+Ptr)}{ToSimpleSectionPtr(const Content_t *contentItemPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Simple\+Section\+\_\+t} $\ast$ parse\+Tree\+::\+To\+Simple\+Section\+Ptr (
\begin{DoxyParamCaption}
\item[{const {\bf Content\+\_\+t} $\ast$}]{content\+Item\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{namespaceparse_tree_aebd61e4868b274451e536881994e723b}{}\label{namespaceparse_tree_aebd61e4868b274451e536881994e723b}
Converts from a pointer to a \hyperlink{structparse_tree_1_1_content__t}{Content\+\_\+t} into a pointer to a \hyperlink{structparse_tree_1_1_simple_section__t}{Simple\+Section\+\_\+t}.

\begin{DoxyReturn}{Returns}
The same pointer, but with the type converted.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classmk_1_1_exception__t}{mk\+::\+Exception\+\_\+t}} & if the conversion is invalid. \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{Parameters}
{\em content\+Item\+Ptr} & The pointer to convert. \\
\hline
\end{DoxyParams}
\index{parse\+Tree@{parse\+Tree}!To\+Token\+List\+Ptr@{To\+Token\+List\+Ptr}}
\index{To\+Token\+List\+Ptr@{To\+Token\+List\+Ptr}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{To\+Token\+List\+Ptr(const Content\+\_\+t $\ast$content\+Item\+Ptr)}{ToTokenListPtr(const Content_t *contentItemPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Token\+List\+\_\+t} $\ast$ parse\+Tree\+::\+To\+Token\+List\+Ptr (
\begin{DoxyParamCaption}
\item[{const {\bf Content\+\_\+t} $\ast$}]{content\+Item\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{namespaceparse_tree_a51a9485e3b99120976837970a1e461f8}{}\label{namespaceparse_tree_a51a9485e3b99120976837970a1e461f8}
Converts from a pointer to a \hyperlink{structparse_tree_1_1_content__t}{Content\+\_\+t} into a pointer to a \hyperlink{structparse_tree_1_1_token_list__t}{Token\+List\+\_\+t}.

\begin{DoxyReturn}{Returns}
The same pointer, but with the type converted.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classmk_1_1_exception__t}{mk\+::\+Exception\+\_\+t}} & if the conversion is invalid. \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{Parameters}
{\em content\+Item\+Ptr} & The pointer to convert. \\
\hline
\end{DoxyParams}
\index{parse\+Tree@{parse\+Tree}!To\+Token\+List\+Section\+Ptr@{To\+Token\+List\+Section\+Ptr}}
\index{To\+Token\+List\+Section\+Ptr@{To\+Token\+List\+Section\+Ptr}!parse\+Tree@{parse\+Tree}}
\subsubsection[{\texorpdfstring{To\+Token\+List\+Section\+Ptr(const Content\+\_\+t $\ast$content\+Item\+Ptr)}{ToTokenListSectionPtr(const Content_t *contentItemPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Token\+List\+Section\+\_\+t} $\ast$ parse\+Tree\+::\+To\+Token\+List\+Section\+Ptr (
\begin{DoxyParamCaption}
\item[{const {\bf Content\+\_\+t} $\ast$}]{content\+Item\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{namespaceparse_tree_a0871ea3647e557df3fe1a779d47e579a}{}\label{namespaceparse_tree_a0871ea3647e557df3fe1a779d47e579a}
Converts from a pointer to a \hyperlink{structparse_tree_1_1_content__t}{Content\+\_\+t} into a pointer to a \hyperlink{structparse_tree_1_1_simple_section__t}{Simple\+Section\+\_\+t}.

\begin{DoxyReturn}{Returns}
The same pointer, but with the type converted.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classmk_1_1_exception__t}{mk\+::\+Exception\+\_\+t}} & if the conversion is invalid. \\
\hline
\end{DoxyExceptions}

\begin{DoxyParams}{Parameters}
{\em content\+Item\+Ptr} & The pointer to convert. \\
\hline
\end{DoxyParams}
