\hypertarget{utf8_8c}{}\section{framework/liblegato/utf8.c File Reference}
\label{utf8_8c}\index{framework/liblegato/utf8.\+c@{framework/liblegato/utf8.\+c}}
{\ttfamily \#include \char`\"{}legato.\+h\char`\"{}}\\*
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{utf8_8c_a610e2e352029e4a5b25955b3c82e08f4}{I\+S\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}(lead\+Byte)~( (lead\+Byte \& 0x80) == 0x00 )
\item 
\#define \hyperlink{utf8_8c_a48eb074139de77aba60850be6e881d5e}{I\+S\+\_\+\+T\+W\+O\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}(lead\+Byte)~( (lead\+Byte \& 0x\+E0) == 0x\+C0 )
\item 
\#define \hyperlink{utf8_8c_a816fd7f4756986bd4f2dc2a2b2bdd3a2}{I\+S\+\_\+\+T\+H\+R\+E\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}(lead\+Byte)~( (lead\+Byte \& 0x\+F0) == 0x\+E0 )
\item 
\#define \hyperlink{utf8_8c_a67a776b023e8da08e30f1f36df21a70d}{I\+S\+\_\+\+F\+O\+U\+R\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}(lead\+Byte)~( (lead\+Byte \& 0x\+F8) == 0x\+F0 )
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
ssize\+\_\+t \hyperlink{utf8_8c_af8f61f1aa523b03d02d6a89cb61449e2}{le\+\_\+utf8\+\_\+\+Num\+Chars} (const char $\ast$string)
\item 
size\+\_\+t \hyperlink{utf8_8c_a2541a26cade8cef93db889194a430008}{le\+\_\+utf8\+\_\+\+Num\+Bytes} (const char $\ast$string)
\item 
size\+\_\+t \hyperlink{utf8_8c_acf29bce77181131dc39b6ff2101b817c}{le\+\_\+utf8\+\_\+\+Num\+Bytes\+In\+Char} (const char first\+Byte)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{utf8_8c_aa5ae72c01396c106fdf3b4741ead7477}{le\+\_\+utf8\+\_\+\+Copy} (char $\ast$dest\+Str, const char $\ast$src\+Str, const size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{utf8_8c_ade7dfb60b18574dc62c49b86c025579b}{le\+\_\+utf8\+\_\+\+Append} (char $\ast$dest\+Str, const char $\ast$src\+Str, const size\+\_\+t dest\+Size, size\+\_\+t $\ast$dest\+Str\+Len\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{utf8_8c_a6a8d87c8096a43244f6c77598bd1fb82}{le\+\_\+utf8\+\_\+\+Copy\+Up\+To\+Sub\+Str} (char $\ast$dest\+Str, const char $\ast$src\+Str, const char $\ast$sub\+Str, const size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)
\item 
bool \hyperlink{utf8_8c_acffd959e1c6dcf9841217c1c0f6d09e5}{le\+\_\+utf8\+\_\+\+Is\+Format\+Correct} (const char $\ast$string)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{utf8_8c_a680a92fafea1ed72dedb80b52be32a06}{le\+\_\+utf8\+\_\+\+Parse\+Int} (int $\ast$value\+Ptr, const char $\ast$arg)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{utf8_8c_a3b4db65916b5d7d41ba0b1a5595aabd5}{le\+\_\+utf8\+\_\+\+Encode\+Unicode\+Code\+Point} (uint32\+\_\+t code\+Point, char $\ast$out, size\+\_\+t $\ast$out\+Size)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{utf8_8c_a5f590886916f55f68b518ccd3ac932ca}{le\+\_\+utf8\+\_\+\+Decode\+Unicode\+Code\+Point} (const char $\ast$src, size\+\_\+t $\ast$byte\+Length, uint32\+\_\+t $\ast$code\+Point)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Copyright (C) Sierra Wireless Inc. 

\subsection{Macro Definition Documentation}
\index{utf8.\+c@{utf8.\+c}!I\+S\+\_\+\+F\+O\+U\+R\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR@{I\+S\+\_\+\+F\+O\+U\+R\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}}
\index{I\+S\+\_\+\+F\+O\+U\+R\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR@{I\+S\+\_\+\+F\+O\+U\+R\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{I\+S\+\_\+\+F\+O\+U\+R\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}{IS_FOUR_BYTE_CHAR}}]{\setlength{\rightskip}{0pt plus 5cm}\#define I\+S\+\_\+\+F\+O\+U\+R\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR(
\begin{DoxyParamCaption}
\item[{}]{lead\+Byte}
\end{DoxyParamCaption}
)~( (lead\+Byte \& 0x\+F8) == 0x\+F0 )}\hypertarget{utf8_8c_a67a776b023e8da08e30f1f36df21a70d}{}\label{utf8_8c_a67a776b023e8da08e30f1f36df21a70d}
\index{utf8.\+c@{utf8.\+c}!I\+S\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR@{I\+S\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}}
\index{I\+S\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR@{I\+S\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{I\+S\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}{IS_SINGLE_BYTE_CHAR}}]{\setlength{\rightskip}{0pt plus 5cm}\#define I\+S\+\_\+\+S\+I\+N\+G\+L\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR(
\begin{DoxyParamCaption}
\item[{}]{lead\+Byte}
\end{DoxyParamCaption}
)~( (lead\+Byte \& 0x80) == 0x00 )}\hypertarget{utf8_8c_a610e2e352029e4a5b25955b3c82e08f4}{}\label{utf8_8c_a610e2e352029e4a5b25955b3c82e08f4}
\index{utf8.\+c@{utf8.\+c}!I\+S\+\_\+\+T\+H\+R\+E\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR@{I\+S\+\_\+\+T\+H\+R\+E\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}}
\index{I\+S\+\_\+\+T\+H\+R\+E\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR@{I\+S\+\_\+\+T\+H\+R\+E\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{I\+S\+\_\+\+T\+H\+R\+E\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}{IS_THREE_BYTE_CHAR}}]{\setlength{\rightskip}{0pt plus 5cm}\#define I\+S\+\_\+\+T\+H\+R\+E\+E\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR(
\begin{DoxyParamCaption}
\item[{}]{lead\+Byte}
\end{DoxyParamCaption}
)~( (lead\+Byte \& 0x\+F0) == 0x\+E0 )}\hypertarget{utf8_8c_a816fd7f4756986bd4f2dc2a2b2bdd3a2}{}\label{utf8_8c_a816fd7f4756986bd4f2dc2a2b2bdd3a2}
\index{utf8.\+c@{utf8.\+c}!I\+S\+\_\+\+T\+W\+O\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR@{I\+S\+\_\+\+T\+W\+O\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}}
\index{I\+S\+\_\+\+T\+W\+O\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR@{I\+S\+\_\+\+T\+W\+O\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{I\+S\+\_\+\+T\+W\+O\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR}{IS_TWO_BYTE_CHAR}}]{\setlength{\rightskip}{0pt plus 5cm}\#define I\+S\+\_\+\+T\+W\+O\+\_\+\+B\+Y\+T\+E\+\_\+\+C\+H\+AR(
\begin{DoxyParamCaption}
\item[{}]{lead\+Byte}
\end{DoxyParamCaption}
)~( (lead\+Byte \& 0x\+E0) == 0x\+C0 )}\hypertarget{utf8_8c_a48eb074139de77aba60850be6e881d5e}{}\label{utf8_8c_a48eb074139de77aba60850be6e881d5e}


\subsection{Function Documentation}
\index{utf8.\+c@{utf8.\+c}!le\+\_\+utf8\+\_\+\+Append@{le\+\_\+utf8\+\_\+\+Append}}
\index{le\+\_\+utf8\+\_\+\+Append@{le\+\_\+utf8\+\_\+\+Append}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+utf8\+\_\+\+Append(char $\ast$dest\+Str, const char $\ast$src\+Str, const size\+\_\+t dest\+Size, size\+\_\+t $\ast$dest\+Str\+Len\+Ptr)}{le_utf8_Append(char *destStr, const char *srcStr, const size_t destSize, size_t *destStrLenPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+utf8\+\_\+\+Append (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{dest\+Str, }
\item[{const char $\ast$}]{src\+Str, }
\item[{const size\+\_\+t}]{dest\+Size, }
\item[{size\+\_\+t $\ast$}]{dest\+Str\+Len\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{utf8_8c_ade7dfb60b18574dc62c49b86c025579b}{}\label{utf8_8c_ade7dfb60b18574dc62c49b86c025579b}
Appends src\+Str to dest\+Str by copying characters from src\+Str to the end of dest\+Str. The src\+Str must be in U\+T\+F-\/8 format. The number of bytes in the resultant dest\+Str (not including the N\+U\+L\+L-\/terminator) is returned in dest\+Str\+Len\+Ptr.

A null-\/character is always added to the end of dest\+Str after all src\+Str characters have been copied.

This function will copy as many characters as possible from src\+Str to dest\+Str while ensuring that the resultant string (including the null-\/character) will fit within the destination buffer.

U\+T\+F-\/8 characters may be more than one byte long and this function will only copy whole characters not partial characters.

The destination string will always be Null-\/terminated, unless dest\+Size is zero.

If dest\+Str and src\+Str overlap the behaviour of this function is undefined.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if src\+Str was completely copied to the dest\+Str.
\item L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if src\+Str was truncated when it was copied to dest\+Str. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em dest\+Str} & The destination string. \\
\hline
\mbox{\tt in}  & {\em src\+Str} & The U\+T\+F-\/8 source string. \\
\hline
\mbox{\tt in}  & {\em dest\+Size} & Size of the destination buffer in bytes. \\
\hline
\mbox{\tt out}  & {\em dest\+Str\+Len\+Ptr} & The number of bytes in the resultant destination string (not including the N\+U\+L\+L-\/terminator). This parameter can be set to N\+U\+LL if the destination string size is not needed. \\
\hline
\end{DoxyParams}
\index{utf8.\+c@{utf8.\+c}!le\+\_\+utf8\+\_\+\+Copy@{le\+\_\+utf8\+\_\+\+Copy}}
\index{le\+\_\+utf8\+\_\+\+Copy@{le\+\_\+utf8\+\_\+\+Copy}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+utf8\+\_\+\+Copy(char $\ast$dest\+Str, const char $\ast$src\+Str, const size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)}{le_utf8_Copy(char *destStr, const char *srcStr, const size_t destSize, size_t *numBytesPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+utf8\+\_\+\+Copy (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{dest\+Str, }
\item[{const char $\ast$}]{src\+Str, }
\item[{const size\+\_\+t}]{dest\+Size, }
\item[{size\+\_\+t $\ast$}]{num\+Bytes\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{utf8_8c_aa5ae72c01396c106fdf3b4741ead7477}{}\label{utf8_8c_aa5ae72c01396c106fdf3b4741ead7477}
This function copies the string in src\+Str to the start of dest\+Str and returns the number of bytes copied (not including the N\+U\+L\+L-\/terminator) in num\+Bytes\+Ptr. Null can be passed into num\+Bytes\+Ptr if the number of bytes copied is not needed. The src\+Str must be in U\+T\+F-\/8 format.

If the size of src\+Str is less than or equal to the destination buffer size then the entire src\+Str will be copied including the null-\/character. The rest of the destination buffer is not modified.

If the size of src\+Str is larger than the destination buffer then the maximum number of characters (from src\+Str) plus a null-\/character that will fit in the destination buffer is copied.

U\+T\+F-\/8 characters may be more than one byte long and this function will only copy whole characters not partial characters. Therefore, even if src\+Str is larger than the destination buffer the copied characters may not fill the entire destination buffer because the last character copied may not align exactly with the end of the destination buffer.

The destination string will always be Null-\/terminated, unless dest\+Size is zero.

If dest\+Str and src\+Str overlap the behaviour of this function is undefined.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if src\+Str was completely copied to the dest\+Str.
\item L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if src\+Str was truncated when it was copied to dest\+Str. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em dest\+Str} & The destination where the src\+Str is to be copied. \\
\hline
\mbox{\tt in}  & {\em src\+Str} & The U\+T\+F-\/8 source string. \\
\hline
\mbox{\tt in}  & {\em dest\+Size} & Size of the destination buffer in bytes. \\
\hline
\mbox{\tt out}  & {\em num\+Bytes\+Ptr} & The number of bytes copied not including the N\+U\+L\+L-\/terminator. This parameter can be set to N\+U\+LL if the number of bytes copied is not needed. \\
\hline
\end{DoxyParams}
\index{utf8.\+c@{utf8.\+c}!le\+\_\+utf8\+\_\+\+Copy\+Up\+To\+Sub\+Str@{le\+\_\+utf8\+\_\+\+Copy\+Up\+To\+Sub\+Str}}
\index{le\+\_\+utf8\+\_\+\+Copy\+Up\+To\+Sub\+Str@{le\+\_\+utf8\+\_\+\+Copy\+Up\+To\+Sub\+Str}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+utf8\+\_\+\+Copy\+Up\+To\+Sub\+Str(char $\ast$dest\+Str, const char $\ast$src\+Str, const char $\ast$sub\+Str, const size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)}{le_utf8_CopyUpToSubStr(char *destStr, const char *srcStr, const char *subStr, const size_t destSize, size_t *numBytesPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+utf8\+\_\+\+Copy\+Up\+To\+Sub\+Str (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{dest\+Str, }
\item[{const char $\ast$}]{src\+Str, }
\item[{const char $\ast$}]{sub\+Str, }
\item[{const size\+\_\+t}]{dest\+Size, }
\item[{size\+\_\+t $\ast$}]{num\+Bytes\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{utf8_8c_a6a8d87c8096a43244f6c77598bd1fb82}{}\label{utf8_8c_a6a8d87c8096a43244f6c77598bd1fb82}
Copies all characters from the src\+Str to dest\+Str up to the first occurrence of sub\+Str. The sub\+Str is not copied and instead a null-\/terminator is added to the dest\+Str. The number of bytes copied (not including the null-\/terminator) is returned in num\+Bytes\+Ptr.

The src\+Str and sub\+Str must be in null-\/terminated U\+T\+F-\/8 strings.

The destination string will always be null-\/terminated.

If sub\+Str is not found in the src\+Str then this function behaves just like \hyperlink{utf8_8c_aa5ae72c01396c106fdf3b4741ead7477}{le\+\_\+utf8\+\_\+\+Copy()}.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if src\+Str was completely copied to the dest\+Str.
\item L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if src\+Str was truncated when it was copied to dest\+Str. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em dest\+Str} & The destination where the src\+Str is to be copied. \\
\hline
\mbox{\tt in}  & {\em src\+Str} & The U\+T\+F-\/8 source string. \\
\hline
\mbox{\tt in}  & {\em sub\+Str} & The sub-\/string to copy up to. \\
\hline
\mbox{\tt in}  & {\em dest\+Size} & Size of the destination buffer in bytes. \\
\hline
\mbox{\tt out}  & {\em num\+Bytes\+Ptr} & The number of bytes copied not including the N\+U\+L\+L-\/terminator. This parameter can be set to N\+U\+LL if the number of bytes copied is not needed. \\
\hline
\end{DoxyParams}
\index{utf8.\+c@{utf8.\+c}!le\+\_\+utf8\+\_\+\+Decode\+Unicode\+Code\+Point@{le\+\_\+utf8\+\_\+\+Decode\+Unicode\+Code\+Point}}
\index{le\+\_\+utf8\+\_\+\+Decode\+Unicode\+Code\+Point@{le\+\_\+utf8\+\_\+\+Decode\+Unicode\+Code\+Point}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+utf8\+\_\+\+Decode\+Unicode\+Code\+Point(const char $\ast$src, size\+\_\+t $\ast$byte\+Length, uint32\+\_\+t $\ast$code\+Point)}{le_utf8_DecodeUnicodeCodePoint(const char *src, size_t *byteLength, uint32_t *codePoint)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+utf8\+\_\+\+Decode\+Unicode\+Code\+Point (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{src, }
\item[{size\+\_\+t $\ast$}]{byte\+Length, }
\item[{uint32\+\_\+t $\ast$}]{code\+Point}
\end{DoxyParamCaption}
)}\hypertarget{utf8_8c_a5f590886916f55f68b518ccd3ac932ca}{}\label{utf8_8c_a5f590886916f55f68b518ccd3ac932ca}
Decode the first unicode code point from the U\+T\+F-\/8 string src.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK on success
\item L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER if byte\+Length points to 0
\item L\+E\+\_\+\+U\+N\+D\+E\+R\+F\+L\+OW if src appears to be the beginning of a U\+T\+F-\/8 character which extends beyond the end of the string as specified by byte\+Length.
\item L\+E\+\_\+\+F\+O\+R\+M\+A\+T\+\_\+\+E\+R\+R\+OR if src is not valid U\+T\+F-\/8 encoded string data.
\item L\+E\+\_\+\+O\+U\+T\+\_\+\+O\+F\+\_\+\+R\+A\+N\+GE if src encodes a four byte character whose value is greater than what is permitted in U\+T\+F-\/8.
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Not all code point values are valid unicode. This function does not validate whether the code point is valid unicode. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em src} & U\+T\+F-\/8 encoded data to extract a code point from. \\
\hline
\mbox{\tt in,out}  & {\em byte\+Length} & As an input parameter, the value pointed to represents the number of bytes in src. As an output parameter, the value pointed to is the number of bytes from src that were consumed to decode the code point (in the case of an L\+E\+\_\+\+OK return value) or the number of bytes that would have been consumed had src been long enough (in the case of an L\+E\+\_\+\+U\+N\+D\+E\+R\+F\+L\+OW return value). \\
\hline
\mbox{\tt out}  & {\em code\+Point} & Code point that was decoded from src. This value is only valid when the function returns L\+E\+\_\+\+OK. \\
\hline
\end{DoxyParams}
\index{utf8.\+c@{utf8.\+c}!le\+\_\+utf8\+\_\+\+Encode\+Unicode\+Code\+Point@{le\+\_\+utf8\+\_\+\+Encode\+Unicode\+Code\+Point}}
\index{le\+\_\+utf8\+\_\+\+Encode\+Unicode\+Code\+Point@{le\+\_\+utf8\+\_\+\+Encode\+Unicode\+Code\+Point}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+utf8\+\_\+\+Encode\+Unicode\+Code\+Point(uint32\+\_\+t code\+Point, char $\ast$out, size\+\_\+t $\ast$out\+Size)}{le_utf8_EncodeUnicodeCodePoint(uint32_t codePoint, char *out, size_t *outSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+utf8\+\_\+\+Encode\+Unicode\+Code\+Point (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{code\+Point, }
\item[{char $\ast$}]{out, }
\item[{size\+\_\+t $\ast$}]{out\+Size}
\end{DoxyParamCaption}
)}\hypertarget{utf8_8c_a3b4db65916b5d7d41ba0b1a5595aabd5}{}\label{utf8_8c_a3b4db65916b5d7d41ba0b1a5595aabd5}
Encode a unicode code point as U\+T\+F-\/8 into a buffer.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK on success
\item L\+E\+\_\+\+O\+U\+T\+\_\+\+O\+F\+\_\+\+R\+A\+N\+GE if the code point supplied is outside the range of unicode code points
\item L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if the out buffer is not large enough to store the U\+T\+F-\/8 encoding of the code point
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Not all code point values are valid unicode. This function does not validate whether the code point is valid unicode. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em code\+Point} & Code point to encode as U\+T\+F-\/8. \\
\hline
\mbox{\tt out}  & {\em out} & Buffer to store the U\+T\+F-\/8 encoded value in. \\
\hline
\mbox{\tt in,out}  & {\em out\+Size} & As an input, this value is interpreted as the size of the out buffer. As an output, it is updated to hold the size of the U\+T\+F-\/8 encoded value (in the case of an L\+E\+\_\+\+OK return value) or size that would be required to encode the code point (in the case or an L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW return value). \\
\hline
\end{DoxyParams}
\index{utf8.\+c@{utf8.\+c}!le\+\_\+utf8\+\_\+\+Is\+Format\+Correct@{le\+\_\+utf8\+\_\+\+Is\+Format\+Correct}}
\index{le\+\_\+utf8\+\_\+\+Is\+Format\+Correct@{le\+\_\+utf8\+\_\+\+Is\+Format\+Correct}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+utf8\+\_\+\+Is\+Format\+Correct(const char $\ast$string)}{le_utf8_IsFormatCorrect(const char *string)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+utf8\+\_\+\+Is\+Format\+Correct (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{string}
\end{DoxyParamCaption}
)}\hypertarget{utf8_8c_acffd959e1c6dcf9841217c1c0f6d09e5}{}\label{utf8_8c_acffd959e1c6dcf9841217c1c0f6d09e5}
Checks to see if the string is indeed a U\+T\+F-\/8 encoded, null-\/terminated string.

\begin{DoxyReturn}{Returns}
true if the format is correct or false otherwise 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em string} & The string. \\
\hline
\end{DoxyParams}
\index{utf8.\+c@{utf8.\+c}!le\+\_\+utf8\+\_\+\+Num\+Bytes@{le\+\_\+utf8\+\_\+\+Num\+Bytes}}
\index{le\+\_\+utf8\+\_\+\+Num\+Bytes@{le\+\_\+utf8\+\_\+\+Num\+Bytes}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+utf8\+\_\+\+Num\+Bytes(const char $\ast$string)}{le_utf8_NumBytes(const char *string)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+utf8\+\_\+\+Num\+Bytes (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{string}
\end{DoxyParamCaption}
)}\hypertarget{utf8_8c_a2541a26cade8cef93db889194a430008}{}\label{utf8_8c_a2541a26cade8cef93db889194a430008}
This function returns the number of bytes in string (not including the null-\/terminator).

\begin{DoxyReturn}{Returns}
The number of bytes in string (not including the null-\/terminator). 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em string} & The string. \\
\hline
\end{DoxyParams}
\index{utf8.\+c@{utf8.\+c}!le\+\_\+utf8\+\_\+\+Num\+Bytes\+In\+Char@{le\+\_\+utf8\+\_\+\+Num\+Bytes\+In\+Char}}
\index{le\+\_\+utf8\+\_\+\+Num\+Bytes\+In\+Char@{le\+\_\+utf8\+\_\+\+Num\+Bytes\+In\+Char}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+utf8\+\_\+\+Num\+Bytes\+In\+Char(const char first\+Byte)}{le_utf8_NumBytesInChar(const char firstByte)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+utf8\+\_\+\+Num\+Bytes\+In\+Char (
\begin{DoxyParamCaption}
\item[{const char}]{first\+Byte}
\end{DoxyParamCaption}
)}\hypertarget{utf8_8c_acf29bce77181131dc39b6ff2101b817c}{}\label{utf8_8c_acf29bce77181131dc39b6ff2101b817c}
Returns the number of bytes in the character that starts with a given byte.

\begin{DoxyReturn}{Returns}
Number of bytes in the character, or 0 if the byte provided is not a valid starting byte. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first\+Byte} & The first byte in the character. \\
\hline
\end{DoxyParams}
\index{utf8.\+c@{utf8.\+c}!le\+\_\+utf8\+\_\+\+Num\+Chars@{le\+\_\+utf8\+\_\+\+Num\+Chars}}
\index{le\+\_\+utf8\+\_\+\+Num\+Chars@{le\+\_\+utf8\+\_\+\+Num\+Chars}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+utf8\+\_\+\+Num\+Chars(const char $\ast$string)}{le_utf8_NumChars(const char *string)}}]{\setlength{\rightskip}{0pt plus 5cm}ssize\+\_\+t le\+\_\+utf8\+\_\+\+Num\+Chars (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{string}
\end{DoxyParamCaption}
)}\hypertarget{utf8_8c_af8f61f1aa523b03d02d6a89cb61449e2}{}\label{utf8_8c_af8f61f1aa523b03d02d6a89cb61449e2}
This function returns the number of characters in string.

U\+T\+F-\/8 encoded characters may be larger than 1 byte so the number of characters is not necessarily equal to the the number of bytes in the string.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item Number of characters in string if successful.
\item L\+E\+\_\+\+F\+O\+R\+M\+A\+T\+\_\+\+E\+R\+R\+OR if the string is not U\+T\+F-\/8. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em string} & Pointer to the string. \\
\hline
\end{DoxyParams}
\index{utf8.\+c@{utf8.\+c}!le\+\_\+utf8\+\_\+\+Parse\+Int@{le\+\_\+utf8\+\_\+\+Parse\+Int}}
\index{le\+\_\+utf8\+\_\+\+Parse\+Int@{le\+\_\+utf8\+\_\+\+Parse\+Int}!utf8.\+c@{utf8.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+utf8\+\_\+\+Parse\+Int(int $\ast$value\+Ptr, const char $\ast$arg)}{le_utf8_ParseInt(int *valuePtr, const char *arg)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+utf8\+\_\+\+Parse\+Int (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{value\+Ptr, }
\item[{const char $\ast$}]{arg}
\end{DoxyParamCaption}
)}\hypertarget{utf8_8c_a680a92fafea1ed72dedb80b52be32a06}{}\label{utf8_8c_a680a92fafea1ed72dedb80b52be32a06}
Parse an integer value from a string.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK = Success.
\item L\+E\+\_\+\+F\+O\+R\+M\+A\+T\+\_\+\+E\+R\+R\+OR = The argument string was not an integer value.
\item L\+E\+\_\+\+O\+U\+T\+\_\+\+O\+F\+\_\+\+R\+A\+N\+GE = Value is too large to be stored in an int variable. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em value\+Ptr} & Ptr to where the value will be stored if successful. \\
\hline
\mbox{\tt in}  & {\em arg} & The string to parse. \\
\hline
\end{DoxyParams}
