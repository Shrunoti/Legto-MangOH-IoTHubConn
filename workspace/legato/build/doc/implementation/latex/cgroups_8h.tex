\hypertarget{cgroups_8h}{}\section{framework/liblegato/linux/cgroups.h File Reference}
\label{cgroups_8h}\index{framework/liblegato/linux/cgroups.\+h@{framework/liblegato/linux/cgroups.\+h}}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77c}{cgrp\+\_\+\+Sub\+Sys\+\_\+t} \{ \hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77ca6cfa769c26998032f2a4329d89dcc969}{C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+C\+PU} = 0, 
\hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77cae31e665a64f789a3d7b2c095f295cabb}{C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+M\+EM}, 
\hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77ca0c790090ba7ac7ecd5ea550bc19ce292}{C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+F\+R\+E\+E\+ZE}, 
\hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77cad0de2d0cb1e87e79de36cbdbbc3503d3}{C\+G\+R\+P\+\_\+\+N\+U\+M\+\_\+\+S\+U\+B\+S\+Y\+S\+T\+E\+MS}
 \}
\item 
enum \hyperlink{cgroups_8h_a4195cb6b70449bb93493a6226f97d7ce}{cgrp\+\_\+\+Freeze\+State\+\_\+t} \{ \hyperlink{cgroups_8h_a4195cb6b70449bb93493a6226f97d7cea94f91d6150c57f9640d21c3894296d37}{C\+G\+R\+P\+\_\+\+F\+R\+O\+Z\+EN} = 0, 
\hyperlink{cgroups_8h_a4195cb6b70449bb93493a6226f97d7cea6f6c61acc46ef95eb9e378a6070693c8}{C\+G\+R\+P\+\_\+\+T\+H\+A\+W\+ED}
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{cgroups_8h_a8735d2e07614a24397d740f30243bdff}{cgrp\+\_\+\+Init} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{cgroups_8h_a160b66801eaad9d32c2e8ae11befc304}{cgrp\+\_\+\+Create} (\hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77c}{cgrp\+\_\+\+Sub\+Sys\+\_\+t} subsystem, const char $\ast$cgroup\+Name\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{cgroups_8h_ab16293818696bec9ee17c741e70153f0}{cgrp\+\_\+\+Add\+Proc} (\hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77c}{cgrp\+\_\+\+Sub\+Sys\+\_\+t} subsystem, const char $\ast$cgroup\+Name\+Ptr, pid\+\_\+t pid\+To\+Add)
\item 
ssize\+\_\+t \hyperlink{cgroups_8h_a1b0c1fa94dbb1626bb47f85f822ef58d}{cgrp\+\_\+\+Get\+Thread\+List} (\hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77c}{cgrp\+\_\+\+Sub\+Sys\+\_\+t} subsystem, const char $\ast$cgroup\+Name\+Ptr, pid\+\_\+t $\ast$tid\+List\+Ptr, size\+\_\+t max\+Tids)
\item 
ssize\+\_\+t \hyperlink{cgroups_8h_af2eb43d67a99b474e4c6a484b444f81b}{cgrp\+\_\+\+Get\+Processes\+List} (\hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77c}{cgrp\+\_\+\+Sub\+Sys\+\_\+t} subsystem, const char $\ast$cgroup\+Name\+Ptr, pid\+\_\+t $\ast$id\+List\+Ptr, size\+\_\+t max\+Ids)
\item 
ssize\+\_\+t \hyperlink{cgroups_8h_a49aeee12bf5f7b8adeff02764103d9df}{cgrp\+\_\+\+Send\+Sig} (\hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77c}{cgrp\+\_\+\+Sub\+Sys\+\_\+t} subsystem, const char $\ast$cgroup\+Name\+Ptr, int sig)
\item 
bool \hyperlink{cgroups_8h_af5b46d738fa7ccc3b917b5b29368892d}{cgrp\+\_\+\+Is\+Empty} (\hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77c}{cgrp\+\_\+\+Sub\+Sys\+\_\+t} subsystem, const char $\ast$cgroup\+Name\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{cgroups_8h_af811323b51196a31f2417b54e02e79d3}{cgrp\+\_\+\+Delete} (\hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77c}{cgrp\+\_\+\+Sub\+Sys\+\_\+t} subsystem, const char $\ast$cgroup\+Name\+Ptr)
\item 
const char $\ast$ \hyperlink{cgroups_8h_a133106fb988771994e749b8d27bf7f12}{cgrp\+\_\+\+Sub\+Sys\+Name} (\hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77c}{cgrp\+\_\+\+Sub\+Sys\+\_\+t} subsystem)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{cgroups_8h_ad83dc21bd1c3901bbce4315ab37ee7e6}{cgrp\+\_\+cpu\+\_\+\+Set\+Share} (const char $\ast$cgroup\+Name\+Ptr, size\+\_\+t share)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{cgroups_8h_a3c04562acf22ce2cdef0738b509c1dbd}{cgrp\+\_\+mem\+\_\+\+Set\+Limit} (const char $\ast$cgroup\+Name\+Ptr, size\+\_\+t limit)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{cgroups_8h_a2607ffaf6eb2e2588d6b91d631c6f66d}{cgrp\+\_\+frz\+\_\+\+Freeze} (const char $\ast$cgroup\+Name\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{cgroups_8h_a3c491bdd4e05c125397fe66b655eb12d}{cgrp\+\_\+frz\+\_\+\+Thaw} (const char $\ast$cgroup\+Name\+Ptr)
\item 
\hyperlink{cgroups_8h_a4195cb6b70449bb93493a6226f97d7ce}{cgrp\+\_\+\+Freeze\+State\+\_\+t} \hyperlink{cgroups_8h_ad53ddc667632d27dc19d1efc0b617d03}{cgrp\+\_\+frz\+\_\+\+Get\+State} (const char $\ast$cgroup\+Name\+Ptr)
\item 
ssize\+\_\+t \hyperlink{cgroups_8h_a183413112024ffa9813f1f87d268f6a4}{cgrp\+\_\+\+Get\+Mem\+Used} (const char $\ast$cgroup\+Name\+Ptr)
\item 
ssize\+\_\+t \hyperlink{cgroups_8h_ae9dc8c45c6be255a140bb1f5838eccff}{cgrp\+\_\+\+Get\+Max\+Mem\+Used} (const char $\ast$cgroup\+Name\+Ptr)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\hyperlink{cgroups_8h_c_cgrp_layout}{Hierarchy Layout} ~\newline
 \hyperlink{cgroups_8h_c_cgrp_init}{Initialization} ~\newline
 \hyperlink{cgroups_8h_c_cgrp_create}{Creating cgroups} ~\newline
 \hyperlink{cgroups_8h_c_cgrp_settingAttributes}{Setting cgroup Attributes} ~\newline
 \hyperlink{cgroups_8h_c_cgrp_addingProcesses}{Adding Processes to a cgroup} ~\newline
 \hyperlink{cgroups_8h_c_cgrp_delete}{Deleting cgroups} ~\newline
 \hyperlink{cgroups_8h_c_cgrp_threadSafety}{Thread Safety} ~\newline


Cgroups, short for control groups, is a Linux kernel feature that allows hierarchal groupings of processes. Each group can then be configured with specific attributes that apply to the entire group. Control groups should not be confused with process groups as this is a different concept.

A cgroup can contain other sub-\/groups and can be arranged in a tree structure similar to directories in a file system. However, unlike a file system cgroups can have multiple roots. These separate cgroup trees are called hierarchies. For example, a system\textquotesingle{}s cgroups could be arranged in the following manner\+:

\begin{DoxyVerb}                   Hierarchy1                      Hierarchy2
                     /    \                          /     \
                group1    group2                 group1    group2
                /    \                                         \
          subgroup1  subgroup2                             subgroup1
\end{DoxyVerb}


Attributes that a cgroup can have are available through kernel sub-\/systems. For example, the memory sub-\/system can be used to set the memory limit for all processes in a cgroup. A hierarchy must have at least one sub-\/system attached to it and in general a sub-\/system can only be attached to a single hierarchy.

A process can only be a part of one cgroup in each hierarchy. Having separate hierarchies allows for more flexible control of cgroups.

In practice cgroups are used mainly for limiting system resources.\hypertarget{cgroups_8h_c_cgrp_layout}{}\subsection{Hierarchy Layout}\label{cgroups_8h_c_cgrp_layout}
In this implementation of cgroups each sub-\/system is attached to its own hierarchy. In other words there is a one-\/to-\/one mapping of hierarchy and sub-\/systems so the terms hierarchy and sub-\/system will be used interchangeably henceforth.\hypertarget{cgroups_8h_c_cgrp_init}{}\subsection{Initialization}\label{cgroups_8h_c_cgrp_init}
On system start-\/up the \hyperlink{cgroups_8h_a8735d2e07614a24397d740f30243bdff}{cgrp\+\_\+\+Init()} function must be called to setup the hierarchies. Cgroups are by default non-\/persistent so \hyperlink{cgroups_8h_a8735d2e07614a24397d740f30243bdff}{cgrp\+\_\+\+Init()} must called every time the system starts.\hypertarget{cgroups_8h_c_cgrp_create}{}\subsection{Creating cgroups}\label{cgroups_8h_c_cgrp_create}
To create a cgroup for a sub-\/system call \hyperlink{cgroups_8h_a160b66801eaad9d32c2e8ae11befc304}{cgrp\+\_\+\+Create()}.\hypertarget{cgroups_8h_c_cgrp_settingAttributes}{}\subsection{Setting cgroup Attributes}\label{cgroups_8h_c_cgrp_settingAttributes}
Cgroups created for a specific sub-\/system can only set attributes specific to that sub-\/system. For example\+:


\begin{DoxyCode}
\textcolor{comment}{// cgroup created for the cpu sub-system.}
\hyperlink{cgroups_8c_a160b66801eaad9d32c2e8ae11befc304}{cgrp\_Create}(\hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77ca6cfa769c26998032f2a4329d89dcc969}{CGRP\_SUBSYS\_CPU}, \textcolor{stringliteral}{"MyApp"});

\textcolor{comment}{// cgroup created for the memory sub-system with the same name.  This is a separate cgroup}
\textcolor{comment}{// but it can have the same name because it is in a different hierarchy.}
\hyperlink{cgroups_8c_a160b66801eaad9d32c2e8ae11befc304}{cgrp\_Create}(\hyperlink{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77cae31e665a64f789a3d7b2c095f295cabb}{CGRP\_SUBSYS\_MEM}, \textcolor{stringliteral}{"MyApp"});

\textcolor{comment}{// Set the cpu share for the cgroup in the cpu sub-system to half of the default value.}
\hyperlink{cgroups_8c_ad83dc21bd1c3901bbce4315ab37ee7e6}{cgrp\_cpu\_SetShare}(\textcolor{stringliteral}{"MyApp"}, 512);

\textcolor{comment}{// Set the memory limit for the cgroup in the memory sub-system.}
\hyperlink{cgroups_8c_a3c04562acf22ce2cdef0738b509c1dbd}{cgrp\_mem\_SetLimit}(\textcolor{stringliteral}{"MyApp"}, 100);
\end{DoxyCode}
\hypertarget{cgroups_8h_c_cgrp_addingProcesses}{}\subsection{Adding Processes to a cgroup}\label{cgroups_8h_c_cgrp_addingProcesses}
Processes can be added to a cgroup, by P\+ID, using \hyperlink{cgroups_8h_ab16293818696bec9ee17c741e70153f0}{cgrp\+\_\+\+Add\+Proc()}. If a process already belonging to a cgroup is added to another cgroup in the same hierarchy, the process is moved but not copied to the second cgroup, because processes can only be in one cgroup per hierarchy.

Processes that are forked by other processes always inherit the cgroup of their parent.

When a process dies it is automatically removed from all cgroups it belongs to.\hypertarget{cgroups_8h_c_cgrp_delete}{}\subsection{Deleting cgroups}\label{cgroups_8h_c_cgrp_delete}
To delete a cgroup call \hyperlink{cgroups_8h_af811323b51196a31f2417b54e02e79d3}{cgrp\+\_\+\+Delete()}. Cgroups can only be deleted if they do not contain any processes.\hypertarget{cgroups_8h_c_cgrp_threadSafety}{}\subsection{Thread Safety}\label{cgroups_8h_c_cgrp_threadSafety}
The functions in this A\+PI are not thread safe. Other synchronization methods must be used to control concurrent access to the cgroups.

Copyright (C) Sierra Wireless Inc. 

\subsection{Enumeration Type Documentation}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+\+Freeze\+State\+\_\+t@{cgrp\+\_\+\+Freeze\+State\+\_\+t}}
\index{cgrp\+\_\+\+Freeze\+State\+\_\+t@{cgrp\+\_\+\+Freeze\+State\+\_\+t}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+\+Freeze\+State\+\_\+t}{cgrp_FreezeState_t}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf cgrp\+\_\+\+Freeze\+State\+\_\+t}}\hypertarget{cgroups_8h_a4195cb6b70449bb93493a6226f97d7ce}{}\label{cgroups_8h_a4195cb6b70449bb93493a6226f97d7ce}
Cgroup freeze state. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{C\+G\+R\+P\+\_\+\+F\+R\+O\+Z\+EN@{C\+G\+R\+P\+\_\+\+F\+R\+O\+Z\+EN}!cgroups.\+h@{cgroups.\+h}}\index{cgroups.\+h@{cgroups.\+h}!C\+G\+R\+P\+\_\+\+F\+R\+O\+Z\+EN@{C\+G\+R\+P\+\_\+\+F\+R\+O\+Z\+EN}}\item[{\em 
C\+G\+R\+P\+\_\+\+F\+R\+O\+Z\+EN\hypertarget{cgroups_8h_a4195cb6b70449bb93493a6226f97d7cea94f91d6150c57f9640d21c3894296d37}{}\label{cgroups_8h_a4195cb6b70449bb93493a6226f97d7cea94f91d6150c57f9640d21c3894296d37}
}]All tasks in the cgroup are frozen. \index{C\+G\+R\+P\+\_\+\+T\+H\+A\+W\+ED@{C\+G\+R\+P\+\_\+\+T\+H\+A\+W\+ED}!cgroups.\+h@{cgroups.\+h}}\index{cgroups.\+h@{cgroups.\+h}!C\+G\+R\+P\+\_\+\+T\+H\+A\+W\+ED@{C\+G\+R\+P\+\_\+\+T\+H\+A\+W\+ED}}\item[{\em 
C\+G\+R\+P\+\_\+\+T\+H\+A\+W\+ED\hypertarget{cgroups_8h_a4195cb6b70449bb93493a6226f97d7cea6f6c61acc46ef95eb9e378a6070693c8}{}\label{cgroups_8h_a4195cb6b70449bb93493a6226f97d7cea6f6c61acc46ef95eb9e378a6070693c8}
}]All tasks in the cgroup are not frozen. \end{description}
\end{Desc}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+\+Sub\+Sys\+\_\+t@{cgrp\+\_\+\+Sub\+Sys\+\_\+t}}
\index{cgrp\+\_\+\+Sub\+Sys\+\_\+t@{cgrp\+\_\+\+Sub\+Sys\+\_\+t}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+\+Sub\+Sys\+\_\+t}{cgrp_SubSys_t}}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf cgrp\+\_\+\+Sub\+Sys\+\_\+t}}\hypertarget{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77c}{}\label{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77c}
Cgroup sub-\/systems. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+C\+PU@{C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+C\+PU}!cgroups.\+h@{cgroups.\+h}}\index{cgroups.\+h@{cgroups.\+h}!C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+C\+PU@{C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+C\+PU}}\item[{\em 
C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+C\+PU\hypertarget{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77ca6cfa769c26998032f2a4329d89dcc969}{}\label{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77ca6cfa769c26998032f2a4329d89dcc969}
}]C\+PU sub-\/system. \index{C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+M\+EM@{C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+M\+EM}!cgroups.\+h@{cgroups.\+h}}\index{cgroups.\+h@{cgroups.\+h}!C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+M\+EM@{C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+M\+EM}}\item[{\em 
C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+M\+EM\hypertarget{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77cae31e665a64f789a3d7b2c095f295cabb}{}\label{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77cae31e665a64f789a3d7b2c095f295cabb}
}]Memory sub-\/system. \index{C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+F\+R\+E\+E\+ZE@{C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+F\+R\+E\+E\+ZE}!cgroups.\+h@{cgroups.\+h}}\index{cgroups.\+h@{cgroups.\+h}!C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+F\+R\+E\+E\+ZE@{C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+F\+R\+E\+E\+ZE}}\item[{\em 
C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+F\+R\+E\+E\+ZE\hypertarget{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77ca0c790090ba7ac7ecd5ea550bc19ce292}{}\label{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77ca0c790090ba7ac7ecd5ea550bc19ce292}
}]Freezer sub-\/system. \index{C\+G\+R\+P\+\_\+\+N\+U\+M\+\_\+\+S\+U\+B\+S\+Y\+S\+T\+E\+MS@{C\+G\+R\+P\+\_\+\+N\+U\+M\+\_\+\+S\+U\+B\+S\+Y\+S\+T\+E\+MS}!cgroups.\+h@{cgroups.\+h}}\index{cgroups.\+h@{cgroups.\+h}!C\+G\+R\+P\+\_\+\+N\+U\+M\+\_\+\+S\+U\+B\+S\+Y\+S\+T\+E\+MS@{C\+G\+R\+P\+\_\+\+N\+U\+M\+\_\+\+S\+U\+B\+S\+Y\+S\+T\+E\+MS}}\item[{\em 
C\+G\+R\+P\+\_\+\+N\+U\+M\+\_\+\+S\+U\+B\+S\+Y\+S\+T\+E\+MS\hypertarget{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77cad0de2d0cb1e87e79de36cbdbbc3503d3}{}\label{cgroups_8h_ad2eee571b4d42dc6b59514081d9de77cad0de2d0cb1e87e79de36cbdbbc3503d3}
}]Number of sub-\/systems. Must be the last item in this enum. \end{description}
\end{Desc}


\subsection{Function Documentation}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+\+Add\+Proc@{cgrp\+\_\+\+Add\+Proc}}
\index{cgrp\+\_\+\+Add\+Proc@{cgrp\+\_\+\+Add\+Proc}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+\+Add\+Proc(cgrp\+\_\+\+Sub\+Sys\+\_\+t subsystem, const char $\ast$cgroup\+Name\+Ptr, pid\+\_\+t pid\+To\+Add)}{cgrp_AddProc(cgrp_SubSys_t subsystem, const char *cgroupNamePtr, pid_t pidToAdd)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} cgrp\+\_\+\+Add\+Proc (
\begin{DoxyParamCaption}
\item[{{\bf cgrp\+\_\+\+Sub\+Sys\+\_\+t}}]{subsystem, }
\item[{const char $\ast$}]{cgroup\+Name\+Ptr, }
\item[{pid\+\_\+t}]{pid\+To\+Add}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_ab16293818696bec9ee17c741e70153f0}{}\label{cgroups_8h_ab16293818696bec9ee17c741e70153f0}
Adds a process to a cgroup.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if successful. L\+E\+\_\+\+O\+U\+T\+\_\+\+O\+F\+\_\+\+R\+A\+N\+GE if the process doesn\textquotesingle{}t exist. L\+E\+\_\+\+F\+A\+U\+LT if there was some other error. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em subsystem} & Sub-\/system of the cgroup. \\
\hline
{\em cgroup\+Name\+Ptr} & Name of the cgroup to add the process to. \\
\hline
{\em pid\+To\+Add} & P\+ID of the process to add. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+cpu\+\_\+\+Set\+Share@{cgrp\+\_\+cpu\+\_\+\+Set\+Share}}
\index{cgrp\+\_\+cpu\+\_\+\+Set\+Share@{cgrp\+\_\+cpu\+\_\+\+Set\+Share}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+cpu\+\_\+\+Set\+Share(const char $\ast$cgroup\+Name\+Ptr, size\+\_\+t share)}{cgrp_cpu_SetShare(const char *cgroupNamePtr, size_t share)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} cgrp\+\_\+cpu\+\_\+\+Set\+Share (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{cgroup\+Name\+Ptr, }
\item[{size\+\_\+t}]{share}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_ad83dc21bd1c3901bbce4315ab37ee7e6}{}\label{cgroups_8h_ad83dc21bd1c3901bbce4315ab37ee7e6}
Sets the cpu share of a cgroup.

Cpu share is used to calculate the cpu percentage for a process relative to all other processes in the system. Newly created cgroups and processes not belonging to a cgroup are given a default value of 1024. The actual percentage of the cpu given to a process is calculated as\+:

(share value of process) / (sum of shares from all processes contending for the cpu)

All processes within a cgroup share the available cpu share for that cgroup.

For example\+:

cgroupA is configured with the default share value, 1024. cgroupB is configured with 512 as its share value. cgroupC is configured with 2048 as its share value.

cgroupA has one process running. cgroupB has two processes running. cgroupC has one process running.

Assuming that all processes in cgroupA, cgroupB and cgroupC are running and not blocked waiting for some I/O or timer event and that another system process is also running.

Sum of all shares (including the one system process) is 1024 + 512 + 2048 + 1024 = 4608

The process in cgroupA will get 1024/4608 = 22\% of the cpu. The two processes in cgroupB will share 512/4608 = 11\% of the cpu, each process getting 5.\+5\%. The process in cgroupC will get 2048/4608 = 44\% of the cpu. The system process will get 1024/4608 = 22\% of the cpu.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if successful. L\+E\+\_\+\+F\+A\+U\+LT if there was an error. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em cgroup\+Name\+Ptr} & Name of the cgroup to set the share for. \\
\hline
{\em share} & Share value to set. See the function header for more details. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+\+Create@{cgrp\+\_\+\+Create}}
\index{cgrp\+\_\+\+Create@{cgrp\+\_\+\+Create}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+\+Create(cgrp\+\_\+\+Sub\+Sys\+\_\+t subsystem, const char $\ast$cgroup\+Name\+Ptr)}{cgrp_Create(cgrp_SubSys_t subsystem, const char *cgroupNamePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} cgrp\+\_\+\+Create (
\begin{DoxyParamCaption}
\item[{{\bf cgrp\+\_\+\+Sub\+Sys\+\_\+t}}]{subsystem, }
\item[{const char $\ast$}]{cgroup\+Name\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_a160b66801eaad9d32c2e8ae11befc304}{}\label{cgroups_8h_a160b66801eaad9d32c2e8ae11befc304}
Creates a cgroup with the specified name in the specified sub-\/system. If the cgroup already exists this function has no effect.

Sub-\/groups can be created by providing a path as the name. For example, cgrp\+\_\+\+Create(C\+G\+R\+P\+\_\+\+S\+U\+B\+S\+Y\+S\+\_\+\+C\+PU, \char`\"{}\+Students/\+Undergrads\char`\"{}); will create a cgroup called \char`\"{}\+Undergrads\char`\"{} that is a sub-\/group of \char`\"{}\+Students\char`\"{}. Note that all parent groups must first exist before a sub-\/group can be created.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if successful. L\+E\+\_\+\+D\+U\+P\+L\+I\+C\+A\+TE if the cgroup already exists. L\+E\+\_\+\+F\+A\+U\+LT if there was an error. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em subsystem} & Sub-\/system the cgroup belongs to. \\
\hline
{\em cgroup\+Name\+Ptr} & Name of the cgroup to create. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+\+Delete@{cgrp\+\_\+\+Delete}}
\index{cgrp\+\_\+\+Delete@{cgrp\+\_\+\+Delete}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+\+Delete(cgrp\+\_\+\+Sub\+Sys\+\_\+t subsystem, const char $\ast$cgroup\+Name\+Ptr)}{cgrp_Delete(cgrp_SubSys_t subsystem, const char *cgroupNamePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} cgrp\+\_\+\+Delete (
\begin{DoxyParamCaption}
\item[{{\bf cgrp\+\_\+\+Sub\+Sys\+\_\+t}}]{subsystem, }
\item[{const char $\ast$}]{cgroup\+Name\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_af811323b51196a31f2417b54e02e79d3}{}\label{cgroups_8h_af811323b51196a31f2417b54e02e79d3}
Deletes a cgroup.

\begin{DoxyNote}{Note}
A cgroup can only be removed when there are no processes in the group. Ensure there are no processes in a cgroup (by killing the processes) before attempting to delete it.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if the cgroup was successfully deleted. L\+E\+\_\+\+B\+U\+SY if the cgroup could not be deleted because there are still processes in the cgroup. L\+E\+\_\+\+F\+A\+U\+LT if there was some other error. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em subsystem} & Sub-\/system of the cgroup. \\
\hline
{\em cgroup\+Name\+Ptr} & Name of the cgroup to delete. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+frz\+\_\+\+Freeze@{cgrp\+\_\+frz\+\_\+\+Freeze}}
\index{cgrp\+\_\+frz\+\_\+\+Freeze@{cgrp\+\_\+frz\+\_\+\+Freeze}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+frz\+\_\+\+Freeze(const char $\ast$cgroup\+Name\+Ptr)}{cgrp_frz_Freeze(const char *cgroupNamePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} cgrp\+\_\+frz\+\_\+\+Freeze (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{cgroup\+Name\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_a2607ffaf6eb2e2588d6b91d631c6f66d}{}\label{cgroups_8h_a2607ffaf6eb2e2588d6b91d631c6f66d}
Freezes all the tasks in a cgroup. This is an asynchronous function call that returns immediately at which point the freeze state of the cgroup may not be updated yet. Check the current state of the cgroup using \hyperlink{cgroups_8h_ad53ddc667632d27dc19d1efc0b617d03}{cgrp\+\_\+frz\+\_\+\+Get\+State()}. Once a cgroup is frozen all tasks in the cgroup are prevented from being scheduled by the kernel.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if successful. L\+E\+\_\+\+F\+A\+U\+LT if there was an error. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cgroup\+Name\+Ptr} & Name of the cgroup. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+frz\+\_\+\+Get\+State@{cgrp\+\_\+frz\+\_\+\+Get\+State}}
\index{cgrp\+\_\+frz\+\_\+\+Get\+State@{cgrp\+\_\+frz\+\_\+\+Get\+State}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+frz\+\_\+\+Get\+State(const char $\ast$cgroup\+Name\+Ptr)}{cgrp_frz_GetState(const char *cgroupNamePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf cgrp\+\_\+\+Freeze\+State\+\_\+t} cgrp\+\_\+frz\+\_\+\+Get\+State (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{cgroup\+Name\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_ad53ddc667632d27dc19d1efc0b617d03}{}\label{cgroups_8h_ad53ddc667632d27dc19d1efc0b617d03}
Gets the freeze state of the cgroup.

\begin{DoxyReturn}{Returns}
Freeze state of the cgroup if successful. L\+E\+\_\+\+F\+A\+U\+LT if there was an error. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cgroup\+Name\+Ptr} & Name of the cgroup. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+frz\+\_\+\+Thaw@{cgrp\+\_\+frz\+\_\+\+Thaw}}
\index{cgrp\+\_\+frz\+\_\+\+Thaw@{cgrp\+\_\+frz\+\_\+\+Thaw}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+frz\+\_\+\+Thaw(const char $\ast$cgroup\+Name\+Ptr)}{cgrp_frz_Thaw(const char *cgroupNamePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} cgrp\+\_\+frz\+\_\+\+Thaw (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{cgroup\+Name\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_a3c491bdd4e05c125397fe66b655eb12d}{}\label{cgroups_8h_a3c491bdd4e05c125397fe66b655eb12d}
Thaws all the tasks in a cgroup. This is an asynchronous function call that returns immediately at which point the freeze state of the cgroup may not be updated yet. Check the current state of the cgroup using \hyperlink{cgroups_8h_ad53ddc667632d27dc19d1efc0b617d03}{cgrp\+\_\+frz\+\_\+\+Get\+State()}. Once a cgroup is thawed all tasks in the cgroup are permitted to be scheduled by the kernel.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if successful. L\+E\+\_\+\+F\+A\+U\+LT if there was an error. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cgroup\+Name\+Ptr} & Name of the cgroup. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+\+Get\+Max\+Mem\+Used@{cgrp\+\_\+\+Get\+Max\+Mem\+Used}}
\index{cgrp\+\_\+\+Get\+Max\+Mem\+Used@{cgrp\+\_\+\+Get\+Max\+Mem\+Used}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+\+Get\+Max\+Mem\+Used(const char $\ast$cgroup\+Name\+Ptr)}{cgrp_GetMaxMemUsed(const char *cgroupNamePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}ssize\+\_\+t cgrp\+\_\+\+Get\+Max\+Mem\+Used (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{cgroup\+Name\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_ae9dc8c45c6be255a140bb1f5838eccff}{}\label{cgroups_8h_ae9dc8c45c6be255a140bb1f5838eccff}
Gets the imum amount of memory used in bytes by a cgroup. \begin{DoxyReturn}{Returns}
Maximum number of bytes used at any time up to now by this cgroup. L\+E\+\_\+\+F\+A\+U\+LT if there was an error.
\end{DoxyReturn}
Gets the maximum amount of memory used in bytes by a cgroup. \begin{DoxyReturn}{Returns}
Maximum number of bytes used at any time up to now by this cgroup. L\+E\+\_\+\+F\+A\+U\+LT if there was an error. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cgroup\+Name\+Ptr} & Name of the cgroup. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+\+Get\+Mem\+Used@{cgrp\+\_\+\+Get\+Mem\+Used}}
\index{cgrp\+\_\+\+Get\+Mem\+Used@{cgrp\+\_\+\+Get\+Mem\+Used}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+\+Get\+Mem\+Used(const char $\ast$cgroup\+Name\+Ptr)}{cgrp_GetMemUsed(const char *cgroupNamePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}ssize\+\_\+t cgrp\+\_\+\+Get\+Mem\+Used (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{cgroup\+Name\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_a183413112024ffa9813f1f87d268f6a4}{}\label{cgroups_8h_a183413112024ffa9813f1f87d268f6a4}
Gets the amount of memory used in bytes by a cgroup

\begin{DoxyReturn}{Returns}
Number of bytes in use by the cgroup. L\+E\+\_\+\+F\+A\+U\+LT if there was an error. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cgroup\+Name\+Ptr} & Name of the cgroup. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+\+Get\+Processes\+List@{cgrp\+\_\+\+Get\+Processes\+List}}
\index{cgrp\+\_\+\+Get\+Processes\+List@{cgrp\+\_\+\+Get\+Processes\+List}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+\+Get\+Processes\+List(cgrp\+\_\+\+Sub\+Sys\+\_\+t subsystem, const char $\ast$cgroup\+Name\+Ptr, pid\+\_\+t $\ast$id\+List\+Ptr, size\+\_\+t max\+Ids)}{cgrp_GetProcessesList(cgrp_SubSys_t subsystem, const char *cgroupNamePtr, pid_t *idListPtr, size_t maxIds)}}]{\setlength{\rightskip}{0pt plus 5cm}ssize\+\_\+t cgrp\+\_\+\+Get\+Processes\+List (
\begin{DoxyParamCaption}
\item[{{\bf cgrp\+\_\+\+Sub\+Sys\+\_\+t}}]{subsystem, }
\item[{const char $\ast$}]{cgroup\+Name\+Ptr, }
\item[{pid\+\_\+t $\ast$}]{pid\+List\+Ptr, }
\item[{size\+\_\+t}]{max\+Pids}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_af2eb43d67a99b474e4c6a484b444f81b}{}\label{cgroups_8h_af2eb43d67a99b474e4c6a484b444f81b}
Gets a list of threads that are in a cgroup. The number of threads in the cgroup may be larger than max\+Tids, in which case tid\+List\+Ptr will be filled with the first max\+Tids T\+I\+Ds.

\begin{DoxyReturn}{Returns}
The number of threads that are in the cgroup if successful. L\+E\+\_\+\+F\+A\+U\+LT if there was some other error.
\end{DoxyReturn}
Gets a list of processes that are in a cgroup. The number of processes in the cgroup may be larger than max\+Pids, in which case pid\+List\+Ptr will be filled with the first max\+Pids P\+I\+Ds.

\begin{DoxyReturn}{Returns}
The number of threads that are in the cgroup if successful. L\+E\+\_\+\+F\+A\+U\+LT if there was some other error. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em subsystem} & Sub-\/system of the cgroup. \\
\hline
\mbox{\tt in}  & {\em cgroup\+Name\+Ptr} & Name of the cgroup. \\
\hline
\mbox{\tt out}  & {\em pid\+List\+Ptr} & Buffer that will contain the list of P\+I\+Ds. \\
\hline
\mbox{\tt in}  & {\em max\+Pids} & The maximum number of pids pid\+List\+Ptr can hold. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+\+Get\+Thread\+List@{cgrp\+\_\+\+Get\+Thread\+List}}
\index{cgrp\+\_\+\+Get\+Thread\+List@{cgrp\+\_\+\+Get\+Thread\+List}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+\+Get\+Thread\+List(cgrp\+\_\+\+Sub\+Sys\+\_\+t subsystem, const char $\ast$cgroup\+Name\+Ptr, pid\+\_\+t $\ast$tid\+List\+Ptr, size\+\_\+t max\+Tids)}{cgrp_GetThreadList(cgrp_SubSys_t subsystem, const char *cgroupNamePtr, pid_t *tidListPtr, size_t maxTids)}}]{\setlength{\rightskip}{0pt plus 5cm}ssize\+\_\+t cgrp\+\_\+\+Get\+Thread\+List (
\begin{DoxyParamCaption}
\item[{{\bf cgrp\+\_\+\+Sub\+Sys\+\_\+t}}]{subsystem, }
\item[{const char $\ast$}]{cgroup\+Name\+Ptr, }
\item[{pid\+\_\+t $\ast$}]{tid\+List\+Ptr, }
\item[{size\+\_\+t}]{max\+Tids}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_a1b0c1fa94dbb1626bb47f85f822ef58d}{}\label{cgroups_8h_a1b0c1fa94dbb1626bb47f85f822ef58d}
Gets a list of threads that are in a cgroup. The number of threads in the cgroup may be larger than max\+Tids, in which case tid\+List\+Ptr will be filled with the first max\+Tids T\+I\+Ds.

\begin{DoxyReturn}{Returns}
The number of threads that are in the cgroup if successful. L\+E\+\_\+\+F\+A\+U\+LT if there was some other error. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em subsystem} & Sub-\/system of the cgroup. \\
\hline
\mbox{\tt in}  & {\em cgroup\+Name\+Ptr} & Name of the cgroup. \\
\hline
\mbox{\tt out}  & {\em tid\+List\+Ptr} & Buffer that will contain the list of T\+I\+Ds. \\
\hline
\mbox{\tt in}  & {\em max\+Tids} & The maximum number of tids tid\+List\+Ptr can hold. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+\+Init@{cgrp\+\_\+\+Init}}
\index{cgrp\+\_\+\+Init@{cgrp\+\_\+\+Init}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+\+Init(void)}{cgrp_Init(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} cgrp\+\_\+\+Init (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_a8735d2e07614a24397d740f30243bdff}{}\label{cgroups_8h_a8735d2e07614a24397d740f30243bdff}
Initializes cgroups for the system. Sets up a hierarchy for each supported subsystem.

\begin{DoxyNote}{Note}
Should be called once for the entire system, subsequent calls to this function will have no effect. Must be called before any of the other functions in this A\+PI is called.

Failures will cause the calling process to exit. 
\end{DoxyNote}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+\+Is\+Empty@{cgrp\+\_\+\+Is\+Empty}}
\index{cgrp\+\_\+\+Is\+Empty@{cgrp\+\_\+\+Is\+Empty}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+\+Is\+Empty(cgrp\+\_\+\+Sub\+Sys\+\_\+t subsystem, const char $\ast$cgroup\+Name\+Ptr)}{cgrp_IsEmpty(cgrp_SubSys_t subsystem, const char *cgroupNamePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool cgrp\+\_\+\+Is\+Empty (
\begin{DoxyParamCaption}
\item[{{\bf cgrp\+\_\+\+Sub\+Sys\+\_\+t}}]{subsystem, }
\item[{const char $\ast$}]{cgroup\+Name\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_af5b46d738fa7ccc3b917b5b29368892d}{}\label{cgroups_8h_af5b46d738fa7ccc3b917b5b29368892d}
Checks if the specified cgroup is empty of all processes.

\begin{DoxyReturn}{Returns}
true if the specified cgroup has no processes in it. false if there are processes in the specified cgroup. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em subsystem} & Sub-\/system of the cgroup. \\
\hline
\mbox{\tt in}  & {\em cgroup\+Name\+Ptr} & Name of the cgroup. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+mem\+\_\+\+Set\+Limit@{cgrp\+\_\+mem\+\_\+\+Set\+Limit}}
\index{cgrp\+\_\+mem\+\_\+\+Set\+Limit@{cgrp\+\_\+mem\+\_\+\+Set\+Limit}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+mem\+\_\+\+Set\+Limit(const char $\ast$cgroup\+Name\+Ptr, size\+\_\+t limit)}{cgrp_mem_SetLimit(const char *cgroupNamePtr, size_t limit)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} cgrp\+\_\+mem\+\_\+\+Set\+Limit (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{cgroup\+Name\+Ptr, }
\item[{size\+\_\+t}]{limit}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_a3c04562acf22ce2cdef0738b509c1dbd}{}\label{cgroups_8h_a3c04562acf22ce2cdef0738b509c1dbd}
Sets the memory limit for a cgroup.

\begin{DoxyNote}{Note}
All processes in a cgroup share the available memory for that cgroup.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if successful. L\+E\+\_\+\+F\+A\+U\+LT if there was an error. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em cgroup\+Name\+Ptr} & Name of the cgroup to set the limit for. \\
\hline
{\em limit} & Memory limit in kilobytes. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+\+Send\+Sig@{cgrp\+\_\+\+Send\+Sig}}
\index{cgrp\+\_\+\+Send\+Sig@{cgrp\+\_\+\+Send\+Sig}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+\+Send\+Sig(cgrp\+\_\+\+Sub\+Sys\+\_\+t subsystem, const char $\ast$cgroup\+Name\+Ptr, int sig)}{cgrp_SendSig(cgrp_SubSys_t subsystem, const char *cgroupNamePtr, int sig)}}]{\setlength{\rightskip}{0pt plus 5cm}ssize\+\_\+t cgrp\+\_\+\+Send\+Sig (
\begin{DoxyParamCaption}
\item[{{\bf cgrp\+\_\+\+Sub\+Sys\+\_\+t}}]{subsystem, }
\item[{const char $\ast$}]{cgroup\+Name\+Ptr, }
\item[{int}]{sig}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_a49aeee12bf5f7b8adeff02764103d9df}{}\label{cgroups_8h_a49aeee12bf5f7b8adeff02764103d9df}
Sends the specified signal to all the processes in the specified cgroup.

\begin{DoxyReturn}{Returns}
The number of P\+I\+Ds that are in the cgroup. L\+E\+\_\+\+F\+A\+U\+LT if there an error. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em subsystem} & Sub-\/system of the cgroup. \\
\hline
\mbox{\tt in}  & {\em cgroup\+Name\+Ptr} & Name of the cgroup. \\
\hline
\mbox{\tt in}  & {\em sig} & The signal to send. \\
\hline
\end{DoxyParams}
\index{cgroups.\+h@{cgroups.\+h}!cgrp\+\_\+\+Sub\+Sys\+Name@{cgrp\+\_\+\+Sub\+Sys\+Name}}
\index{cgrp\+\_\+\+Sub\+Sys\+Name@{cgrp\+\_\+\+Sub\+Sys\+Name}!cgroups.\+h@{cgroups.\+h}}
\subsubsection[{\texorpdfstring{cgrp\+\_\+\+Sub\+Sys\+Name(cgrp\+\_\+\+Sub\+Sys\+\_\+t subsystem)}{cgrp_SubSysName(cgrp_SubSys_t subsystem)}}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ cgrp\+\_\+\+Sub\+Sys\+Name (
\begin{DoxyParamCaption}
\item[{{\bf cgrp\+\_\+\+Sub\+Sys\+\_\+t}}]{subsystem}
\end{DoxyParamCaption}
)}\hypertarget{cgroups_8h_a133106fb988771994e749b8d27bf7f12}{}\label{cgroups_8h_a133106fb988771994e749b8d27bf7f12}
Gets the name of sub-\/system.

\begin{DoxyNote}{Note}
Do not attempt to modify the returned name in place. If you need to make modifications copy the name into your own buffer.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
The name of the sub-\/system. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em subsystem} & Sub-\/system. \\
\hline
\end{DoxyParams}
