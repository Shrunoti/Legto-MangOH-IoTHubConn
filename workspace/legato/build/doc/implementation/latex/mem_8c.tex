\hypertarget{mem_8c}{}\section{framework/liblegato/linux/mem.c File Reference}
\label{mem_8c}\index{framework/liblegato/linux/mem.\+c@{framework/liblegato/linux/mem.\+c}}
{\ttfamily \#include \char`\"{}legato.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}mem.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}limit.\+h\char`\"{}}\\*
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct_mem_block__t}{Mem\+Block\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{mem_8c_a553a390cf8175201f0232d121ff7349e}{U\+S\+E\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+ND}
\item 
\#define \hyperlink{mem_8c_a25d84e49c5b14fc304ad83826e3172ae}{F\+I\+L\+L\+\_\+\+D\+E\+L\+E\+T\+E\+D\+\_\+\+A\+N\+D\+\_\+\+C\+H\+E\+C\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+ED}
\item 
\#define \hyperlink{mem_8c_ae307f86eca9d86b8b6dcdf119849f3f3}{N\+U\+M\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+W\+O\+R\+DS}~8
\item 
\#define \hyperlink{mem_8c_ad07c8efc76499f4cbdd7af8b00e20520}{G\+U\+A\+R\+D\+\_\+\+W\+O\+RD}~((uint32\+\_\+t)0x\+D\+E\+A\+D\+B\+E\+E\+F)
\item 
\#define \hyperlink{mem_8c_ac6cee95dddfd4bc13e546fca9bcde2de}{G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+S\+I\+ZE}~(sizeof(\hyperlink{mem_8c_ad07c8efc76499f4cbdd7af8b00e20520}{G\+U\+A\+R\+D\+\_\+\+W\+O\+RD}) $\ast$ \hyperlink{mem_8c_ae307f86eca9d86b8b6dcdf119849f3f3}{N\+U\+M\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+W\+O\+R\+DS})
\item 
\#define \hyperlink{mem_8c_a554085ed0200922085de2e2d7d23c1c5}{M\+A\+X\+\_\+\+P\+O\+O\+L\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES}~(\hyperlink{limit_8h_a87b04c282499850049caa466ceb9fc87}{L\+I\+M\+I\+T\+\_\+\+M\+A\+X\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+N\+A\+M\+E\+\_\+\+L\+EN} + 1 + \hyperlink{limit_8h_a089f06d273b054f909c21c092d4b3918}{L\+I\+M\+I\+T\+\_\+\+M\+A\+X\+\_\+\+M\+E\+M\+\_\+\+P\+O\+O\+L\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES})
\item 
\#define \hyperlink{mem_8c_a0bccc174e7790dec3a9a397acb57551c}{D\+E\+F\+A\+U\+L\+T\+\_\+\+S\+U\+B\+\_\+\+P\+O\+O\+L\+S\+\_\+\+P\+O\+O\+L\+\_\+\+S\+I\+ZE}~8
\item 
\#define \hyperlink{mem_8c_afbd6c74ccfe3cb2b7407e8b901b6021c}{D\+E\+F\+A\+U\+L\+T\+\_\+\+N\+U\+M\+\_\+\+B\+L\+O\+C\+K\+S\+\_\+\+T\+O\+\_\+\+F\+O\+R\+CE}~1
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structle__dls___list__t}{le\+\_\+dls\+\_\+\+List\+\_\+t} $\ast$ \hyperlink{mem_8c_afdb1825411be8731a7ead8332bf72870}{mem\+\_\+\+Get\+Pool\+List} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
size\+\_\+t $\ast$$\ast$ \hyperlink{mem_8c_ad2e07f90603768e498dbbf2e865a55e6}{mem\+\_\+\+Get\+Pool\+List\+Chg\+Cnt\+Ref} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_a63692d3983734584a66f2ca4db563ad6}{Lock} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_abba239500052c40aac456def0f18e855}{Unlock} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_a7d003f2aba1a7b26488cac1d3f5e5f60}{Init\+Guard\+Bands} (\hyperlink{struct_mem_block__t}{Mem\+Block\+\_\+t} $\ast$block\+Header\+Ptr)
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_a4104978a8ba67d5a204d7519dc063afb}{Check\+Guard\+Bands} (\hyperlink{struct_mem_block__t}{Mem\+Block\+\_\+t} $\ast$block\+Header\+Ptr)
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_a0020e0c8e8e14110d61f4b381339549c}{Init\+Pool} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool, const char $\ast$component\+Name, const char $\ast$name, size\+\_\+t obj\+Size)
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_a07696371106b316322cb7c5e0d0df667}{Move\+Blocks} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} dest\+Pool, \hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} src\+Pool, size\+\_\+t num\+Blocks)
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_af7b9d472a5ed999c72746458a13b1006}{Init\+Block} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool, \hyperlink{struct_mem_block__t}{Mem\+Block\+\_\+t} $\ast$new\+Block\+Ptr)
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_ac9385e393f829976870cd3357873c5ce}{Add\+Blocks} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool, size\+\_\+t num\+Blocks)
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_ae8df42e68ff1614e29e1ffc713713eec}{Verify\+Uniqueness\+Of\+Name} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} new\+Pool)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_a0cc72256d8e8462693609e28557da1f2}{mem\+\_\+\+Init} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \hyperlink{mem_8c_a3b1e3ef3e1f8a02fb4cb5b99a1cd33fe}{\+\_\+le\+\_\+mem\+\_\+\+Create\+Pool} (const char $\ast$component\+Name, const char $\ast$name, size\+\_\+t obj\+Size)
\item 
\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \hyperlink{mem_8c_a79a4321ffa0345f267eaf3b7d3d3528a}{le\+\_\+mem\+\_\+\+Expand\+Pool} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool, size\+\_\+t num\+Objects)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{mem_8c_a742e4f9d621ca27493733ca781bbe187}{le\+\_\+mem\+\_\+\+Try\+Alloc} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{mem_8c_a2993bf7a9705d119c96cf80cd64a56bb}{le\+\_\+mem\+\_\+\+Assert\+Alloc} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{mem_8c_af7c289c73d4182835a26a9099f3db359}{le\+\_\+mem\+\_\+\+Force\+Alloc} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_a267485862100d8cdfefae2c328fb8b91}{le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool, size\+\_\+t num\+Objects)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_a6d8e3fe430bcb81efe97b57ce30ef2de}{le\+\_\+mem\+\_\+\+Release} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$obj\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_a92e869f92a344d61fb44922f99fe679b}{le\+\_\+mem\+\_\+\+Add\+Ref} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$obj\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_a055007b38ce04bcb823e08034fd11b85}{le\+\_\+mem\+\_\+\+Set\+Destructor} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool, \hyperlink{le__mem_8h_afe3d1a458511f0a2e2bcef0827306b79}{le\+\_\+mem\+\_\+\+Destructor\+\_\+t} destructor)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_ab7b41431c57c8c7b5c4ff1501fd5b772}{le\+\_\+mem\+\_\+\+Get\+Stats} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool, \hyperlink{structle__mem___pool_stats__t}{le\+\_\+mem\+\_\+\+Pool\+Stats\+\_\+t} $\ast$stats\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_a35b7e757356764c39f0a7ede2aa242ae}{le\+\_\+mem\+\_\+\+Reset\+Stats} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{mem_8c_a721219712fb3d62988cc151a1908cb4b}{le\+\_\+mem\+\_\+\+Get\+Name} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool, char $\ast$name\+Ptr, size\+\_\+t buf\+Size)
\item 
const bool \hyperlink{mem_8c_a55840232147421c951714013abbab4ec}{le\+\_\+mem\+\_\+\+Is\+Sub\+Pool} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
size\+\_\+t \hyperlink{mem_8c_a76725588ed757ca95cdf36e5ab3aeebf}{le\+\_\+mem\+\_\+\+Get\+Object\+Count} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
size\+\_\+t \hyperlink{mem_8c_a0f6fbc0c886486a1e19fc43143991c66}{le\+\_\+mem\+\_\+\+Get\+Object\+Size} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
size\+\_\+t \hyperlink{mem_8c_ac802750b9aab7bb596004f30ce58adf0}{le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool)
\item 
\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \hyperlink{mem_8c_a6396dd1271b70ddf56babec57e28a9f9}{\+\_\+le\+\_\+mem\+\_\+\+Find\+Pool} (const char $\ast$component\+Name, const char $\ast$name)
\item 
\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \hyperlink{mem_8c_a7251ebb965fa014ff17fc359a7c99098}{\+\_\+le\+\_\+mem\+\_\+\+Create\+Sub\+Pool} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} super\+Pool, const char $\ast$component\+Name, const char $\ast$name, size\+\_\+t num\+Objects)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{mem_8c_aa1d51a37f572c2d891cdfb625ea19f27}{le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool} (\hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} sub\+Pool)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{structle__dls___list__t}{le\+\_\+dls\+\_\+\+List\+\_\+t} \hyperlink{mem_8c_a8315b1db3bf541e8ec9bd778d6c79ece}{Pool\+List} = \hyperlink{le__doubly_linked_list_8h_a68f28b61cdfd004591f24730b4d5a740}{L\+E\+\_\+\+D\+L\+S\+\_\+\+L\+I\+S\+T\+\_\+\+I\+N\+IT}
\item 
static size\+\_\+t \hyperlink{mem_8c_a0346ee884fa56835886bec6a26df6ef1}{Pool\+List\+Change\+Count} = 0
\item 
static size\+\_\+t $\ast$ \hyperlink{mem_8c_a4ce410269d11155528cc966d70ab1957}{Pool\+List\+Change\+Count\+Ref} = \&\hyperlink{mem_8c_a0346ee884fa56835886bec6a26df6ef1}{Pool\+List\+Change\+Count}
\item 
static \hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \hyperlink{mem_8c_a2a7f46f6824d7c5e925d5b1761ad99f4}{Sub\+Pools\+Pool}
\item 
static pthread\+\_\+mutex\+\_\+t \hyperlink{mem_8c_abc03085ccf7c38e092cdf06bf6b98ea6}{Mutex} = P\+T\+H\+R\+E\+A\+D\+\_\+\+M\+U\+T\+E\+X\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+ER
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This module maintains a local list of memory pools that contain all memory pools created in this process. Each memory pool contains a collection of fixed-\/size memory blocks, each of which contains a single user object, plus some overhead. Since each memory block contains one user object, the number of blocks and objects in a memory pool are always the same.

Memory for the memory blocks (including the user object) is allocated from system memory when a memory pool is expanded. Memory blocks are never released back to system memory. Instead, when they are \char`\"{}free\char`\"{}, they are kept on their pool\textquotesingle{}s \char`\"{}free list\char`\"{}. The free list is O(1) for both insertion and removal. It is treated as a stack, in that blocks are popped from the head of the free list when they are allocated and pushed back onto the head of the free list when they are deallocated. The hope is that this will speed things up by utilizing the cache better when there are a lot of allocations interleaved with releases.

Sub-\/pools behave exactly like memory pools except in the way that they are created, expanded and deleted.

A sub-\/pool must be created using the le\+\_\+mem\+\_\+\+Create\+Sub\+Pool function rather than the le\+\_\+mem\+\_\+\+Create\+Pool function. When a sub-\/pool is created the memory for the sub-\/pool is allocated from the local memory pool of sub-\/pools. The created sub-\/pool is then added to the local list of pools.

The super-\/pool for a sub-\/pool must be one of the memory pools created with le\+\_\+mem\+\_\+\+Create\+Pool. In other words sub-\/pools of sub-\/pools are not allowed.

Unlike a memory pool, which cannot be deleted, a sub-\/pool can be deleted. When a sub-\/pool is deleted the sub-\/pool\textquotesingle{}s blocks are released back into the super-\/pool. However, it is an error to delete a sub-\/pool while there are still blocks allocated from it. The sub-\/pool itself is then removed from the list of pools and released back into the pool of sub-\/pools.

\subsection*{G\+U\+A\+RD B\+A\+N\+DS }

A debugging feature can be enabled at compile-\/time by defining the macro \char`\"{}\+U\+S\+E\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\char`\"{}. This inserts chunks of memory into each memory block both before and after the user object part. These chunks of memory, called \char`\"{}guard bands\char`\"{}, are filled with a special pattern that is unlikely to occur in normal data. Whenever a block is allocated or released, the guard bands are checked for corruption and any corruption is reported.

Copyright (C) Sierra Wireless Inc. 

\subsection{Macro Definition Documentation}
\index{mem.\+c@{mem.\+c}!D\+E\+F\+A\+U\+L\+T\+\_\+\+N\+U\+M\+\_\+\+B\+L\+O\+C\+K\+S\+\_\+\+T\+O\+\_\+\+F\+O\+R\+CE@{D\+E\+F\+A\+U\+L\+T\+\_\+\+N\+U\+M\+\_\+\+B\+L\+O\+C\+K\+S\+\_\+\+T\+O\+\_\+\+F\+O\+R\+CE}}
\index{D\+E\+F\+A\+U\+L\+T\+\_\+\+N\+U\+M\+\_\+\+B\+L\+O\+C\+K\+S\+\_\+\+T\+O\+\_\+\+F\+O\+R\+CE@{D\+E\+F\+A\+U\+L\+T\+\_\+\+N\+U\+M\+\_\+\+B\+L\+O\+C\+K\+S\+\_\+\+T\+O\+\_\+\+F\+O\+R\+CE}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{D\+E\+F\+A\+U\+L\+T\+\_\+\+N\+U\+M\+\_\+\+B\+L\+O\+C\+K\+S\+\_\+\+T\+O\+\_\+\+F\+O\+R\+CE}{DEFAULT_NUM_BLOCKS_TO_FORCE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define D\+E\+F\+A\+U\+L\+T\+\_\+\+N\+U\+M\+\_\+\+B\+L\+O\+C\+K\+S\+\_\+\+T\+O\+\_\+\+F\+O\+R\+CE~1}\hypertarget{mem_8c_afbd6c74ccfe3cb2b7407e8b901b6021c}{}\label{mem_8c_afbd6c74ccfe3cb2b7407e8b901b6021c}
The default number of blocks to expand by when the le\+\_\+mem\+\_\+\+Force\+Alloc expands the memory pool. \index{mem.\+c@{mem.\+c}!D\+E\+F\+A\+U\+L\+T\+\_\+\+S\+U\+B\+\_\+\+P\+O\+O\+L\+S\+\_\+\+P\+O\+O\+L\+\_\+\+S\+I\+ZE@{D\+E\+F\+A\+U\+L\+T\+\_\+\+S\+U\+B\+\_\+\+P\+O\+O\+L\+S\+\_\+\+P\+O\+O\+L\+\_\+\+S\+I\+ZE}}
\index{D\+E\+F\+A\+U\+L\+T\+\_\+\+S\+U\+B\+\_\+\+P\+O\+O\+L\+S\+\_\+\+P\+O\+O\+L\+\_\+\+S\+I\+ZE@{D\+E\+F\+A\+U\+L\+T\+\_\+\+S\+U\+B\+\_\+\+P\+O\+O\+L\+S\+\_\+\+P\+O\+O\+L\+\_\+\+S\+I\+ZE}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{D\+E\+F\+A\+U\+L\+T\+\_\+\+S\+U\+B\+\_\+\+P\+O\+O\+L\+S\+\_\+\+P\+O\+O\+L\+\_\+\+S\+I\+ZE}{DEFAULT_SUB_POOLS_POOL_SIZE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define D\+E\+F\+A\+U\+L\+T\+\_\+\+S\+U\+B\+\_\+\+P\+O\+O\+L\+S\+\_\+\+P\+O\+O\+L\+\_\+\+S\+I\+ZE~8}\hypertarget{mem_8c_a0bccc174e7790dec3a9a397acb57551c}{}\label{mem_8c_a0bccc174e7790dec3a9a397acb57551c}
The default number of Sub Pool objects in the Sub Pools Pool. \begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000045}{Todo}]Make this configurable. \end{DoxyRefDesc}
\index{mem.\+c@{mem.\+c}!F\+I\+L\+L\+\_\+\+D\+E\+L\+E\+T\+E\+D\+\_\+\+A\+N\+D\+\_\+\+C\+H\+E\+C\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+ED@{F\+I\+L\+L\+\_\+\+D\+E\+L\+E\+T\+E\+D\+\_\+\+A\+N\+D\+\_\+\+C\+H\+E\+C\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+ED}}
\index{F\+I\+L\+L\+\_\+\+D\+E\+L\+E\+T\+E\+D\+\_\+\+A\+N\+D\+\_\+\+C\+H\+E\+C\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+ED@{F\+I\+L\+L\+\_\+\+D\+E\+L\+E\+T\+E\+D\+\_\+\+A\+N\+D\+\_\+\+C\+H\+E\+C\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+ED}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{F\+I\+L\+L\+\_\+\+D\+E\+L\+E\+T\+E\+D\+\_\+\+A\+N\+D\+\_\+\+C\+H\+E\+C\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+ED}{FILL_DELETED_AND_CHECK_ALLOCATED}}]{\setlength{\rightskip}{0pt plus 5cm}\#define F\+I\+L\+L\+\_\+\+D\+E\+L\+E\+T\+E\+D\+\_\+\+A\+N\+D\+\_\+\+C\+H\+E\+C\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+ED}\hypertarget{mem_8c_a25d84e49c5b14fc304ad83826e3172ae}{}\label{mem_8c_a25d84e49c5b14fc304ad83826e3172ae}
\index{mem.\+c@{mem.\+c}!G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+S\+I\+ZE@{G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+S\+I\+ZE}}
\index{G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+S\+I\+ZE@{G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+S\+I\+ZE}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+S\+I\+ZE}{GUARD_BAND_SIZE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+S\+I\+ZE~(sizeof({\bf G\+U\+A\+R\+D\+\_\+\+W\+O\+RD}) $\ast$ {\bf N\+U\+M\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+W\+O\+R\+DS})}\hypertarget{mem_8c_ac6cee95dddfd4bc13e546fca9bcde2de}{}\label{mem_8c_ac6cee95dddfd4bc13e546fca9bcde2de}
\index{mem.\+c@{mem.\+c}!G\+U\+A\+R\+D\+\_\+\+W\+O\+RD@{G\+U\+A\+R\+D\+\_\+\+W\+O\+RD}}
\index{G\+U\+A\+R\+D\+\_\+\+W\+O\+RD@{G\+U\+A\+R\+D\+\_\+\+W\+O\+RD}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{G\+U\+A\+R\+D\+\_\+\+W\+O\+RD}{GUARD_WORD}}]{\setlength{\rightskip}{0pt plus 5cm}\#define G\+U\+A\+R\+D\+\_\+\+W\+O\+RD~((uint32\+\_\+t)0x\+D\+E\+A\+D\+B\+E\+E\+F)}\hypertarget{mem_8c_ad07c8efc76499f4cbdd7af8b00e20520}{}\label{mem_8c_ad07c8efc76499f4cbdd7af8b00e20520}
\index{mem.\+c@{mem.\+c}!M\+A\+X\+\_\+\+P\+O\+O\+L\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES@{M\+A\+X\+\_\+\+P\+O\+O\+L\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES}}
\index{M\+A\+X\+\_\+\+P\+O\+O\+L\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES@{M\+A\+X\+\_\+\+P\+O\+O\+L\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{M\+A\+X\+\_\+\+P\+O\+O\+L\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES}{MAX_POOL_NAME_BYTES}}]{\setlength{\rightskip}{0pt plus 5cm}\#define M\+A\+X\+\_\+\+P\+O\+O\+L\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES~({\bf L\+I\+M\+I\+T\+\_\+\+M\+A\+X\+\_\+\+C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+N\+A\+M\+E\+\_\+\+L\+EN} + 1 + {\bf L\+I\+M\+I\+T\+\_\+\+M\+A\+X\+\_\+\+M\+E\+M\+\_\+\+P\+O\+O\+L\+\_\+\+N\+A\+M\+E\+\_\+\+B\+Y\+T\+ES})}\hypertarget{mem_8c_a554085ed0200922085de2e2d7d23c1c5}{}\label{mem_8c_a554085ed0200922085de2e2d7d23c1c5}
The maximum total pool name size, including the component prefix, which is a component name plus a \textquotesingle{}.\textquotesingle{} separator (\char`\"{}my\+Comp.\+my\+Pool\char`\"{}) and the null terminator. \index{mem.\+c@{mem.\+c}!N\+U\+M\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+W\+O\+R\+DS@{N\+U\+M\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+W\+O\+R\+DS}}
\index{N\+U\+M\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+W\+O\+R\+DS@{N\+U\+M\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+W\+O\+R\+DS}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{N\+U\+M\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+W\+O\+R\+DS}{NUM_GUARD_BAND_WORDS}}]{\setlength{\rightskip}{0pt plus 5cm}\#define N\+U\+M\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+N\+D\+\_\+\+W\+O\+R\+DS~8}\hypertarget{mem_8c_ae307f86eca9d86b8b6dcdf119849f3f3}{}\label{mem_8c_ae307f86eca9d86b8b6dcdf119849f3f3}
\index{mem.\+c@{mem.\+c}!U\+S\+E\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+ND@{U\+S\+E\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+ND}}
\index{U\+S\+E\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+ND@{U\+S\+E\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+ND}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{U\+S\+E\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+ND}{USE_GUARD_BAND}}]{\setlength{\rightskip}{0pt plus 5cm}\#define U\+S\+E\+\_\+\+G\+U\+A\+R\+D\+\_\+\+B\+A\+ND}\hypertarget{mem_8c_a553a390cf8175201f0232d121ff7349e}{}\label{mem_8c_a553a390cf8175201f0232d121ff7349e}


\subsection{Function Documentation}
\index{mem.\+c@{mem.\+c}!\+\_\+le\+\_\+mem\+\_\+\+Create\+Pool@{\+\_\+le\+\_\+mem\+\_\+\+Create\+Pool}}
\index{\+\_\+le\+\_\+mem\+\_\+\+Create\+Pool@{\+\_\+le\+\_\+mem\+\_\+\+Create\+Pool}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{\+\_\+le\+\_\+mem\+\_\+\+Create\+Pool(const char $\ast$component\+Name, const char $\ast$name, size\+\_\+t obj\+Size)}{_le_mem_CreatePool(const char *componentName, const char *name, size_t objSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \+\_\+le\+\_\+mem\+\_\+\+Create\+Pool (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{component\+Name, }
\item[{const char $\ast$}]{name, }
\item[{size\+\_\+t}]{obj\+Size}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a3b1e3ef3e1f8a02fb4cb5b99a1cd33fe}{}\label{mem_8c_a3b1e3ef3e1f8a02fb4cb5b99a1cd33fe}
Creates an empty memory pool.

\begin{DoxyReturn}{Returns}
A reference to the memory pool object.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
On failure, the process exits, so you don\textquotesingle{}t have to worry about checking the returned reference for validity. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em component\+Name} & Name of the component. \\
\hline
\mbox{\tt in}  & {\em name} & Name of the pool inside the component. \\
\hline
\mbox{\tt in}  & {\em obj\+Size} & The size of the individual objects to be allocated from this pool (in bytes). E.\+g., sizeof(\+My\+Object\+\_\+t). \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!\+\_\+le\+\_\+mem\+\_\+\+Create\+Sub\+Pool@{\+\_\+le\+\_\+mem\+\_\+\+Create\+Sub\+Pool}}
\index{\+\_\+le\+\_\+mem\+\_\+\+Create\+Sub\+Pool@{\+\_\+le\+\_\+mem\+\_\+\+Create\+Sub\+Pool}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{\+\_\+le\+\_\+mem\+\_\+\+Create\+Sub\+Pool(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t super\+Pool, const char $\ast$component\+Name, const char $\ast$name, size\+\_\+t num\+Objects)}{_le_mem_CreateSubPool(le_mem_PoolRef_t superPool, const char *componentName, const char *name, size_t numObjects)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \+\_\+le\+\_\+mem\+\_\+\+Create\+Sub\+Pool (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{super\+Pool, }
\item[{const char $\ast$}]{component\+Name, }
\item[{const char $\ast$}]{name, }
\item[{size\+\_\+t}]{num\+Objects}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a7251ebb965fa014ff17fc359a7c99098}{}\label{mem_8c_a7251ebb965fa014ff17fc359a7c99098}
Creates a sub-\/pool. You cannot create sub-\/pools of sub-\/pools so do not attempt to pass a sub-\/pool in the super\+Pool parameter.

See sub\+\_\+pools for more information.

\begin{DoxyReturn}{Returns}
A reference to the sub-\/pool.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
On failure, the process exits, so you don\textquotesingle{}t have to worry about checking the returned reference for validity. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em super\+Pool} & The super-\/pool. \\
\hline
\mbox{\tt in}  & {\em component\+Name} & Name of the component. \\
\hline
\mbox{\tt in}  & {\em name} & Name of the pool inside the component. \\
\hline
\mbox{\tt in}  & {\em num\+Objects} & The number of objects to take from the super-\/pool. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!\+\_\+le\+\_\+mem\+\_\+\+Find\+Pool@{\+\_\+le\+\_\+mem\+\_\+\+Find\+Pool}}
\index{\+\_\+le\+\_\+mem\+\_\+\+Find\+Pool@{\+\_\+le\+\_\+mem\+\_\+\+Find\+Pool}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{\+\_\+le\+\_\+mem\+\_\+\+Find\+Pool(const char $\ast$component\+Name, const char $\ast$name)}{_le_mem_FindPool(const char *componentName, const char *name)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \+\_\+le\+\_\+mem\+\_\+\+Find\+Pool (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{component\+Name, }
\item[{const char $\ast$}]{name}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a6396dd1271b70ddf56babec57e28a9f9}{}\label{mem_8c_a6396dd1271b70ddf56babec57e28a9f9}
Finds a pool given the pool\textquotesingle{}s name.

\begin{DoxyReturn}{Returns}
Reference to the pool, or N\+U\+LL if the pool doesn\textquotesingle{}t exist. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em component\+Name} & Name of the component. \\
\hline
\mbox{\tt in}  & {\em name} & Name of the pool inside the component. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!Add\+Blocks@{Add\+Blocks}}
\index{Add\+Blocks@{Add\+Blocks}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Add\+Blocks(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool, size\+\_\+t num\+Blocks)}{AddBlocks(le_mem_PoolRef_t pool, size_t numBlocks)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Add\+Blocks (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool, }
\item[{size\+\_\+t}]{num\+Blocks}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{mem_8c_ac9385e393f829976870cd3357873c5ce}{}\label{mem_8c_ac9385e393f829976870cd3357873c5ce}
Creates blocks and adds them to the pool.

\begin{DoxyNote}{Note}
Updates the pools total number of blocks.

Assumes that the mutex is locked. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool to be expanded. \\
\hline
\mbox{\tt in}  & {\em num\+Blocks} & The number of blocks to add to the pool. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!Check\+Guard\+Bands@{Check\+Guard\+Bands}}
\index{Check\+Guard\+Bands@{Check\+Guard\+Bands}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Check\+Guard\+Bands(\+Mem\+Block\+\_\+t $\ast$block\+Header\+Ptr)}{CheckGuardBands(MemBlock_t *blockHeaderPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Check\+Guard\+Bands (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Block\+\_\+t} $\ast$}]{block\+Header\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{mem_8c_a4104978a8ba67d5a204d7519dc063afb}{}\label{mem_8c_a4104978a8ba67d5a204d7519dc063afb}
Checks the integrity of the guard bands in a memory block\textquotesingle{}s data payload section. \index{mem.\+c@{mem.\+c}!Init\+Block@{Init\+Block}}
\index{Init\+Block@{Init\+Block}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Init\+Block(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool, Mem\+Block\+\_\+t $\ast$new\+Block\+Ptr)}{InitBlock(le_mem_PoolRef_t pool, MemBlock_t *newBlockPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Init\+Block (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool, }
\item[{{\bf Mem\+Block\+\_\+t} $\ast$}]{new\+Block\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{mem_8c_af7b9d472a5ed999c72746458a13b1006}{}\label{mem_8c_af7b9d472a5ed999c72746458a13b1006}
Initialize a new pool block. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool the new block belongs to. \\
\hline
\mbox{\tt in}  & {\em new\+Block\+Ptr} & The block being initialized. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!Init\+Guard\+Bands@{Init\+Guard\+Bands}}
\index{Init\+Guard\+Bands@{Init\+Guard\+Bands}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Init\+Guard\+Bands(\+Mem\+Block\+\_\+t $\ast$block\+Header\+Ptr)}{InitGuardBands(MemBlock_t *blockHeaderPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Init\+Guard\+Bands (
\begin{DoxyParamCaption}
\item[{{\bf Mem\+Block\+\_\+t} $\ast$}]{block\+Header\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{mem_8c_a7d003f2aba1a7b26488cac1d3f5e5f60}{}\label{mem_8c_a7d003f2aba1a7b26488cac1d3f5e5f60}
Initializes the guard bands in a memory block\textquotesingle{}s data payload section. \index{mem.\+c@{mem.\+c}!Init\+Pool@{Init\+Pool}}
\index{Init\+Pool@{Init\+Pool}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Init\+Pool(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool, const char $\ast$component\+Name, const char $\ast$name, size\+\_\+t obj\+Size)}{InitPool(le_mem_PoolRef_t pool, const char *componentName, const char *name, size_t objSize)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Init\+Pool (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool, }
\item[{const char $\ast$}]{component\+Name, }
\item[{const char $\ast$}]{name, }
\item[{size\+\_\+t}]{obj\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{mem_8c_a0020e0c8e8e14110d61f4b381339549c}{}\label{mem_8c_a0020e0c8e8e14110d61f4b381339549c}
Initializes a memory pool.

\begin{DoxyWarning}{Warning}
Called without the mutex locked. 
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool to initialize. \\
\hline
\mbox{\tt in}  & {\em component\+Name} & Name of the component. \\
\hline
\mbox{\tt in}  & {\em name} & Name of the pool inside the component. \\
\hline
\mbox{\tt in}  & {\em obj\+Size} & The size of the individual objects to be allocated from this pool in bytes. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Add\+Ref@{le\+\_\+mem\+\_\+\+Add\+Ref}}
\index{le\+\_\+mem\+\_\+\+Add\+Ref@{le\+\_\+mem\+\_\+\+Add\+Ref}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Add\+Ref(void $\ast$obj\+Ptr)}{le_mem_AddRef(void *objPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+mem\+\_\+\+Add\+Ref (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$}]{obj\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a92e869f92a344d61fb44922f99fe679b}{}\label{mem_8c_a92e869f92a344d61fb44922f99fe679b}
Increments the reference count on an object by 1.

See ref\+\_\+counting for more information.

\begin{DoxyReturn}{Returns}
Nothing. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em obj\+Ptr} & Pointer to the object. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Assert\+Alloc@{le\+\_\+mem\+\_\+\+Assert\+Alloc}}
\index{le\+\_\+mem\+\_\+\+Assert\+Alloc@{le\+\_\+mem\+\_\+\+Assert\+Alloc}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Assert\+Alloc(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_AssertAlloc(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ le\+\_\+mem\+\_\+\+Assert\+Alloc (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a2993bf7a9705d119c96cf80cd64a56bb}{}\label{mem_8c_a2993bf7a9705d119c96cf80cd64a56bb}
Allocates an object from a pool or logs a fatal error and terminates the process if the pool doesn\textquotesingle{}t have any free objects to allocate.

\begin{DoxyReturn}{Returns}
A pointer to the allocated object.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
On failure, the process exits, so you don\textquotesingle{}t have to worry about checking the returned pointer for validity. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool from which the object is to be allocated. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool@{le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool}}
\index{le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool@{le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t sub\+Pool)}{le_mem_DeleteSubPool(le_mem_PoolRef_t subPool)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+mem\+\_\+\+Delete\+Sub\+Pool (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{sub\+Pool}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_aa1d51a37f572c2d891cdfb625ea19f27}{}\label{mem_8c_aa1d51a37f572c2d891cdfb625ea19f27}
Deletes a sub-\/pool.

See sub\+\_\+pools for more information.

\begin{DoxyReturn}{Returns}
Nothing. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em sub\+Pool} & The sub-\/pool to be deleted. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Expand\+Pool@{le\+\_\+mem\+\_\+\+Expand\+Pool}}
\index{le\+\_\+mem\+\_\+\+Expand\+Pool@{le\+\_\+mem\+\_\+\+Expand\+Pool}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Expand\+Pool(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool, size\+\_\+t num\+Objects)}{le_mem_ExpandPool(le_mem_PoolRef_t pool, size_t numObjects)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} le\+\_\+mem\+\_\+\+Expand\+Pool (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool, }
\item[{size\+\_\+t}]{num\+Objects}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a79a4321ffa0345f267eaf3b7d3d3528a}{}\label{mem_8c_a79a4321ffa0345f267eaf3b7d3d3528a}
Expands the size of a memory pool.

\begin{DoxyReturn}{Returns}
A reference to the memory pool object (the same value passed into it).
\end{DoxyReturn}
\begin{DoxyNote}{Note}
On failure, the process exits, so you don\textquotesingle{}t have to worry about checking the returned reference for validity. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool to be expanded. \\
\hline
\mbox{\tt in}  & {\em num\+Objects} & The number of objects to add to the pool. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Force\+Alloc@{le\+\_\+mem\+\_\+\+Force\+Alloc}}
\index{le\+\_\+mem\+\_\+\+Force\+Alloc@{le\+\_\+mem\+\_\+\+Force\+Alloc}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Force\+Alloc(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_ForceAlloc(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ le\+\_\+mem\+\_\+\+Force\+Alloc (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_af7c289c73d4182835a26a9099f3db359}{}\label{mem_8c_af7c289c73d4182835a26a9099f3db359}
Allocates an object from a pool or logs a warning and expands the pool if the pool doesn\textquotesingle{}t have any free objects to allocate.

\begin{DoxyReturn}{Returns}
A pointer to the allocated object.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
On failure, the process exits, so you don\textquotesingle{}t have to worry about checking the returned pointer for validity. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool from which the object is to be allocated. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Get\+Name@{le\+\_\+mem\+\_\+\+Get\+Name}}
\index{le\+\_\+mem\+\_\+\+Get\+Name@{le\+\_\+mem\+\_\+\+Get\+Name}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Get\+Name(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool, char $\ast$name\+Ptr, size\+\_\+t buf\+Size)}{le_mem_GetName(le_mem_PoolRef_t pool, char *namePtr, size_t bufSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+mem\+\_\+\+Get\+Name (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool, }
\item[{char $\ast$}]{name\+Ptr, }
\item[{size\+\_\+t}]{buf\+Size}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a721219712fb3d62988cc151a1908cb4b}{}\label{mem_8c_a721219712fb3d62988cc151a1908cb4b}
Gets the memory pool\textquotesingle{}s name, including the component name prefix.

If the pool were given the name \char`\"{}my\+Pool\char`\"{} and the component that it belongs to is called \char`\"{}my\+Component\char`\"{}, then the full pool name returned by this function would be \char`\"{}my\+Component.\+my\+Pool\char`\"{}.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if successful. L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if the name was truncated to fit in the provided buffer. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The memory pool. \\
\hline
\mbox{\tt out}  & {\em name\+Ptr} & Buffer to store the name of memory pool. \\
\hline
\mbox{\tt in}  & {\em buf\+Size} & Size of the buffer name\+Ptr points to. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Get\+Object\+Count@{le\+\_\+mem\+\_\+\+Get\+Object\+Count}}
\index{le\+\_\+mem\+\_\+\+Get\+Object\+Count@{le\+\_\+mem\+\_\+\+Get\+Object\+Count}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Get\+Object\+Count(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_GetObjectCount(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+mem\+\_\+\+Get\+Object\+Count (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a76725588ed757ca95cdf36e5ab3aeebf}{}\label{mem_8c_a76725588ed757ca95cdf36e5ab3aeebf}
Fetches the number of objects that a given pool can hold (this includes both the number of free and in-\/use objects).

\begin{DoxyReturn}{Returns}
Total number of objects. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool whose number of objects is to be fetched. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size@{le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size}}
\index{le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size@{le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_GetObjectFullSize(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+mem\+\_\+\+Get\+Object\+Full\+Size (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_ac802750b9aab7bb596004f30ce58adf0}{}\label{mem_8c_ac802750b9aab7bb596004f30ce58adf0}
Fetches the total size of the object including all the memory overhead in a given pool (in bytes).

\begin{DoxyReturn}{Returns}
Total object memory size, in bytes. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool whose object memory size is to be fetched. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Get\+Object\+Size@{le\+\_\+mem\+\_\+\+Get\+Object\+Size}}
\index{le\+\_\+mem\+\_\+\+Get\+Object\+Size@{le\+\_\+mem\+\_\+\+Get\+Object\+Size}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Get\+Object\+Size(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_GetObjectSize(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+mem\+\_\+\+Get\+Object\+Size (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a0f6fbc0c886486a1e19fc43143991c66}{}\label{mem_8c_a0f6fbc0c886486a1e19fc43143991c66}
Fetches the size of the objects in a given pool (in bytes).

\begin{DoxyReturn}{Returns}
Object size, in bytes. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool whose object size is to be fetched. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Get\+Stats@{le\+\_\+mem\+\_\+\+Get\+Stats}}
\index{le\+\_\+mem\+\_\+\+Get\+Stats@{le\+\_\+mem\+\_\+\+Get\+Stats}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Get\+Stats(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool, le\+\_\+mem\+\_\+\+Pool\+Stats\+\_\+t $\ast$stats\+Ptr)}{le_mem_GetStats(le_mem_PoolRef_t pool, le_mem_PoolStats_t *statsPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+mem\+\_\+\+Get\+Stats (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool, }
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Stats\+\_\+t} $\ast$}]{stats\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_ab7b41431c57c8c7b5c4ff1501fd5b772}{}\label{mem_8c_ab7b41431c57c8c7b5c4ff1501fd5b772}
Fetches the statistics for a given pool.

\begin{DoxyReturn}{Returns}
Nothing. Uses output parameter instead. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool whose stats are to be fetched. \\
\hline
\mbox{\tt out}  & {\em stats\+Ptr} & Pointer to where the stats will be stored. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Is\+Sub\+Pool@{le\+\_\+mem\+\_\+\+Is\+Sub\+Pool}}
\index{le\+\_\+mem\+\_\+\+Is\+Sub\+Pool@{le\+\_\+mem\+\_\+\+Is\+Sub\+Pool}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Is\+Sub\+Pool(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_IsSubPool(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}const bool le\+\_\+mem\+\_\+\+Is\+Sub\+Pool (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a55840232147421c951714013abbab4ec}{}\label{mem_8c_a55840232147421c951714013abbab4ec}
Checks if the specified pool is a sub-\/pool.

\begin{DoxyReturn}{Returns}
true if it is a sub-\/pool. false if it is not a sub-\/pool. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The memory pool. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Release@{le\+\_\+mem\+\_\+\+Release}}
\index{le\+\_\+mem\+\_\+\+Release@{le\+\_\+mem\+\_\+\+Release}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Release(void $\ast$obj\+Ptr)}{le_mem_Release(void *objPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+mem\+\_\+\+Release (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$}]{obj\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a6d8e3fe430bcb81efe97b57ce30ef2de}{}\label{mem_8c_a6d8e3fe430bcb81efe97b57ce30ef2de}
Releases an object. If the object\textquotesingle{}s reference count has reached zero, it will be destructed and its memory will be put back into the pool for later reuse.

\begin{DoxyReturn}{Returns}
Nothing.
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}

\begin{DoxyItemize}
\item {\bfseries Do not E\+V\+ER access an object after releasing it.} It might not exist anymore.
\item If the object has a destructor that accesses a data structure that is shared by multiple threads, make sure you hold the mutex (or take other measures to prevent races) before releasing the object. 
\end{DoxyItemize}
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em obj\+Ptr} & Pointer to the object to be released. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Reset\+Stats@{le\+\_\+mem\+\_\+\+Reset\+Stats}}
\index{le\+\_\+mem\+\_\+\+Reset\+Stats@{le\+\_\+mem\+\_\+\+Reset\+Stats}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Reset\+Stats(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_ResetStats(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+mem\+\_\+\+Reset\+Stats (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a35b7e757356764c39f0a7ede2aa242ae}{}\label{mem_8c_a35b7e757356764c39f0a7ede2aa242ae}
Resets the statistics for a given pool.

\begin{DoxyReturn}{Returns}
Nothing. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool whose stats are to be reset. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Set\+Destructor@{le\+\_\+mem\+\_\+\+Set\+Destructor}}
\index{le\+\_\+mem\+\_\+\+Set\+Destructor@{le\+\_\+mem\+\_\+\+Set\+Destructor}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Set\+Destructor(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool, le\+\_\+mem\+\_\+\+Destructor\+\_\+t destructor)}{le_mem_SetDestructor(le_mem_PoolRef_t pool, le_mem_Destructor_t destructor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+mem\+\_\+\+Set\+Destructor (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool, }
\item[{{\bf le\+\_\+mem\+\_\+\+Destructor\+\_\+t}}]{destructor}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a055007b38ce04bcb823e08034fd11b85}{}\label{mem_8c_a055007b38ce04bcb823e08034fd11b85}
Sets the destructor function for a given pool.

See destructors for more information.

\begin{DoxyReturn}{Returns}
Nothing. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool. \\
\hline
\mbox{\tt in}  & {\em destructor} & The destructor function. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force@{le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force}}
\index{le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force@{le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool, size\+\_\+t num\+Objects)}{le_mem_SetNumObjsToForce(le_mem_PoolRef_t pool, size_t numObjects)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+mem\+\_\+\+Set\+Num\+Objs\+To\+Force (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool, }
\item[{size\+\_\+t}]{num\+Objects}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a267485862100d8cdfefae2c328fb8b91}{}\label{mem_8c_a267485862100d8cdfefae2c328fb8b91}
Sets the number of objects that is added when le\+\_\+mem\+\_\+\+Force\+Alloc expands the pool.

\begin{DoxyReturn}{Returns}
Nothing.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
The default value is one. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool to set the number of objects for. \\
\hline
\mbox{\tt in}  & {\em num\+Objects} & The number of objects that is added when le\+\_\+mem\+\_\+\+Force\+Alloc expands the pool. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!le\+\_\+mem\+\_\+\+Try\+Alloc@{le\+\_\+mem\+\_\+\+Try\+Alloc}}
\index{le\+\_\+mem\+\_\+\+Try\+Alloc@{le\+\_\+mem\+\_\+\+Try\+Alloc}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+mem\+\_\+\+Try\+Alloc(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool)}{le_mem_TryAlloc(le_mem_PoolRef_t pool)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ le\+\_\+mem\+\_\+\+Try\+Alloc (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a742e4f9d621ca27493733ca781bbe187}{}\label{mem_8c_a742e4f9d621ca27493733ca781bbe187}
Attempts to allocate an object from a pool.

\begin{DoxyReturn}{Returns}
A pointer to the allocated object, or N\+U\+LL if the pool doesn\textquotesingle{}t have any free objects to allocate. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em pool} & The pool from which the object is to be allocated. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!Lock@{Lock}}
\index{Lock@{Lock}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Lock(void)}{Lock(void)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Lock (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{mem_8c_a63692d3983734584a66f2ca4db563ad6}{}\label{mem_8c_a63692d3983734584a66f2ca4db563ad6}
Locks the mutex. \index{mem.\+c@{mem.\+c}!mem\+\_\+\+Get\+Pool\+List@{mem\+\_\+\+Get\+Pool\+List}}
\index{mem\+\_\+\+Get\+Pool\+List@{mem\+\_\+\+Get\+Pool\+List}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{mem\+\_\+\+Get\+Pool\+List(void)}{mem_GetPoolList(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+dls\+\_\+\+List\+\_\+t}$\ast$ mem\+\_\+\+Get\+Pool\+List (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_afdb1825411be8731a7ead8332bf72870}{}\label{mem_8c_afdb1825411be8731a7ead8332bf72870}
Exposing the memory pool list; mainly for the Inspect tool. \index{mem.\+c@{mem.\+c}!mem\+\_\+\+Get\+Pool\+List\+Chg\+Cnt\+Ref@{mem\+\_\+\+Get\+Pool\+List\+Chg\+Cnt\+Ref}}
\index{mem\+\_\+\+Get\+Pool\+List\+Chg\+Cnt\+Ref@{mem\+\_\+\+Get\+Pool\+List\+Chg\+Cnt\+Ref}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{mem\+\_\+\+Get\+Pool\+List\+Chg\+Cnt\+Ref(void)}{mem_GetPoolListChgCntRef(void)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t$\ast$$\ast$ mem\+\_\+\+Get\+Pool\+List\+Chg\+Cnt\+Ref (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_ad2e07f90603768e498dbbf2e865a55e6}{}\label{mem_8c_ad2e07f90603768e498dbbf2e865a55e6}
Exposing the memory pool list change counter; mainly for the Inspect tool. \index{mem.\+c@{mem.\+c}!mem\+\_\+\+Init@{mem\+\_\+\+Init}}
\index{mem\+\_\+\+Init@{mem\+\_\+\+Init}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{mem\+\_\+\+Init(void)}{mem_Init(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} mem\+\_\+\+Init (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{mem_8c_a0cc72256d8e8462693609e28557da1f2}{}\label{mem_8c_a0cc72256d8e8462693609e28557da1f2}
Initializes the memory pool system. This function must be called before any other memory pool functions are called.

\begin{DoxyNote}{Note}
On failure, the process exits. 
\end{DoxyNote}
\index{mem.\+c@{mem.\+c}!Move\+Blocks@{Move\+Blocks}}
\index{Move\+Blocks@{Move\+Blocks}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Move\+Blocks(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t dest\+Pool, le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t src\+Pool, size\+\_\+t num\+Blocks)}{MoveBlocks(le_mem_PoolRef_t destPool, le_mem_PoolRef_t srcPool, size_t numBlocks)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Move\+Blocks (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{dest\+Pool, }
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{src\+Pool, }
\item[{size\+\_\+t}]{num\+Blocks}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{mem_8c_a07696371106b316322cb7c5e0d0df667}{}\label{mem_8c_a07696371106b316322cb7c5e0d0df667}
Moves the specified number of blocks from the source pool to the destination pool.

\begin{DoxyNote}{Note}
Does not update the total number of blocks for either pool.

Assumes that the mutex is locked. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em dest\+Pool} & The pool to move the blocks to. \\
\hline
\mbox{\tt in}  & {\em src\+Pool} & The pool to get the blocks from. \\
\hline
\mbox{\tt in}  & {\em num\+Blocks} & The maximum number of blocks to move. \\
\hline
\end{DoxyParams}
\index{mem.\+c@{mem.\+c}!Unlock@{Unlock}}
\index{Unlock@{Unlock}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Unlock(void)}{Unlock(void)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Unlock (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{mem_8c_abba239500052c40aac456def0f18e855}{}\label{mem_8c_abba239500052c40aac456def0f18e855}
Unlocks the mutex. \index{mem.\+c@{mem.\+c}!Verify\+Uniqueness\+Of\+Name@{Verify\+Uniqueness\+Of\+Name}}
\index{Verify\+Uniqueness\+Of\+Name@{Verify\+Uniqueness\+Of\+Name}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Verify\+Uniqueness\+Of\+Name(le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t new\+Pool)}{VerifyUniquenessOfName(le_mem_PoolRef_t newPool)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Verify\+Uniqueness\+Of\+Name (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{new\+Pool}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{mem_8c_ae8df42e68ff1614e29e1ffc713713eec}{}\label{mem_8c_ae8df42e68ff1614e29e1ffc713713eec}
Log an error message if there is another pool with the same name as a given pool. 

\subsection{Variable Documentation}
\index{mem.\+c@{mem.\+c}!Mutex@{Mutex}}
\index{Mutex@{Mutex}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Mutex}{Mutex}}]{\setlength{\rightskip}{0pt plus 5cm}pthread\+\_\+mutex\+\_\+t Mutex = P\+T\+H\+R\+E\+A\+D\+\_\+\+M\+U\+T\+E\+X\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+ER\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{mem_8c_abc03085ccf7c38e092cdf06bf6b98ea6}{}\label{mem_8c_abc03085ccf7c38e092cdf06bf6b98ea6}
Pthreads fast mutex used to protect data structures in this module from multithreading races. \index{mem.\+c@{mem.\+c}!Pool\+List@{Pool\+List}}
\index{Pool\+List@{Pool\+List}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Pool\+List}{PoolList}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+dls\+\_\+\+List\+\_\+t} Pool\+List = {\bf L\+E\+\_\+\+D\+L\+S\+\_\+\+L\+I\+S\+T\+\_\+\+I\+N\+IT}\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{mem_8c_a8315b1db3bf541e8ec9bd778d6c79ece}{}\label{mem_8c_a8315b1db3bf541e8ec9bd778d6c79ece}
Local list of all memory pools created with le\+\_\+mem\+\_\+\+Create\+Pool and le\+\_\+mem\+\_\+\+Create\+Sub\+Pool within this process. \index{mem.\+c@{mem.\+c}!Pool\+List\+Change\+Count@{Pool\+List\+Change\+Count}}
\index{Pool\+List\+Change\+Count@{Pool\+List\+Change\+Count}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Pool\+List\+Change\+Count}{PoolListChangeCount}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t Pool\+List\+Change\+Count = 0\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{mem_8c_a0346ee884fa56835886bec6a26df6ef1}{}\label{mem_8c_a0346ee884fa56835886bec6a26df6ef1}
A counter that increments every time a change is made to Pool\+List. \index{mem.\+c@{mem.\+c}!Pool\+List\+Change\+Count\+Ref@{Pool\+List\+Change\+Count\+Ref}}
\index{Pool\+List\+Change\+Count\+Ref@{Pool\+List\+Change\+Count\+Ref}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Pool\+List\+Change\+Count\+Ref}{PoolListChangeCountRef}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t$\ast$ Pool\+List\+Change\+Count\+Ref = \&{\bf Pool\+List\+Change\+Count}\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{mem_8c_a4ce410269d11155528cc966d70ab1957}{}\label{mem_8c_a4ce410269d11155528cc966d70ab1957}
\index{mem.\+c@{mem.\+c}!Sub\+Pools\+Pool@{Sub\+Pools\+Pool}}
\index{Sub\+Pools\+Pool@{Sub\+Pools\+Pool}!mem.\+c@{mem.\+c}}
\subsubsection[{\texorpdfstring{Sub\+Pools\+Pool}{SubPoolsPool}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} Sub\+Pools\+Pool\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{mem_8c_a2a7f46f6824d7c5e925d5b1761ad99f4}{}\label{mem_8c_a2a7f46f6824d7c5e925d5b1761ad99f4}
Local memory pool that is used for allocating sub-\/pools. 