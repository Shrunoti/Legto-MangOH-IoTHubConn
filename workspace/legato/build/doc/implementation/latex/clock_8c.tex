\hypertarget{clock_8c}{}\section{framework/liblegato/linux/clock.c File Reference}
\label{clock_8c}\index{framework/liblegato/linux/clock.\+c@{framework/liblegato/linux/clock.\+c}}
{\ttfamily \#include \char`\"{}legato.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}timer.\+h\char`\"{}}\\*
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{clock_8c_aa7198679962b072a364206f696a1a6ff}{L\+I\+M\+I\+T\+\_\+\+U\+S\+EC}~(1000000)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} \hyperlink{clock_8c_ab5c7a819f6ecd37a76ca6e938c97c186}{clk\+\_\+\+Get\+Relative\+Time} (bool Is\+Wakeup)
\item 
\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} \hyperlink{clock_8c_a298619d8c1d8f107cb03b8600f09a42b}{le\+\_\+clk\+\_\+\+Get\+Relative\+Time} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} \hyperlink{clock_8c_a33197dbd676a37b8c4d5de8f93edc1ee}{le\+\_\+clk\+\_\+\+Get\+Absolute\+Time} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} \hyperlink{clock_8c_a6f4bda0268cd9349b6eb81ae350575fc}{le\+\_\+clk\+\_\+\+Add} (\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} timeA, \hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} timeB)
\item 
bool \hyperlink{clock_8c_ac4a550ee8aa5fad9c81a33024946660a}{le\+\_\+clk\+\_\+\+Greater\+Than} (\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} timeA, \hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} timeB)
\item 
bool \hyperlink{clock_8c_a164476582afdec88bdd48ad5255dce17}{le\+\_\+clk\+\_\+\+Equal} (\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} timeA, \hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} timeB)
\item 
\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} \hyperlink{clock_8c_ac5b5ec6f462d598f4e5aa081224725ac}{le\+\_\+clk\+\_\+\+Sub} (\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} timeA, \hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} timeB)
\item 
\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} \hyperlink{clock_8c_a77961175ee422b1418a18eece5192c9c}{le\+\_\+clk\+\_\+\+Multiply} (\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} timeA, int scale\+Factor)
\item 
static \hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{clock_8c_a26650d7050cde1045429612e12ce4821}{Format\+Broken\+Time} (\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} absolute\+Time, struct tm broken\+Time, const char $\ast$format\+Spec\+Str\+Ptr, char $\ast$dest\+Str\+Ptr, size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{clock_8c_a5392b8eb7d45ce86c0842a0a69975059}{le\+\_\+clk\+\_\+\+Get\+U\+T\+C\+Date\+Time\+String} (const char $\ast$format\+Spec\+Str\+Ptr, char $\ast$dest\+Str\+Ptr, size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{clock_8c_a6f37c2a2171eac23ddc306de1fd55f5c}{le\+\_\+clk\+\_\+\+Get\+Local\+Date\+Time\+String} (const char $\ast$format\+Spec\+Str\+Ptr, char $\ast$dest\+Str\+Ptr, size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{clock_8c_ae06285727609683956c22f6af2937f64}{le\+\_\+clk\+\_\+\+Convert\+To\+U\+T\+C\+String} (\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} time, const char $\ast$format\+Spec\+Str\+Ptr, char $\ast$dest\+Str\+Ptr, size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{clock_8c_a62c3e4ca5b0862938aea139f30846884}{le\+\_\+clk\+\_\+\+Convert\+To\+Local\+Time\+String} (\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} time, const char $\ast$format\+Spec\+Str\+Ptr, char $\ast$dest\+Str\+Ptr, size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{clock_8c_a4eccd60ca4f915c546f811d3574864a8}{le\+\_\+clk\+\_\+\+Set\+Absolute\+Time} (\hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} absolute\+Time)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{clock_8c_aac966e18d931982c8ad19a3dc7271042}{le\+\_\+clk\+\_\+\+Convert\+To\+Time} (const char $\ast$format\+Spec\+Str\+Ptr, const char $\ast$src\+Str\+Ptr, \hyperlink{structle__clk___time__t}{le\+\_\+clk\+\_\+\+Time\+\_\+t} $\ast$time\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{clock_8c_a80f1414046ce8b151f6121e52aa7838c}{le\+\_\+clk\+\_\+\+Set\+U\+T\+C\+Date\+Time\+String} (const char $\ast$format\+Spec\+Str\+Ptr, const char $\ast$src\+Str\+Ptr)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Copyright (C) Sierra Wireless Inc. 

\subsection{Macro Definition Documentation}
\index{clock.\+c@{clock.\+c}!L\+I\+M\+I\+T\+\_\+\+U\+S\+EC@{L\+I\+M\+I\+T\+\_\+\+U\+S\+EC}}
\index{L\+I\+M\+I\+T\+\_\+\+U\+S\+EC@{L\+I\+M\+I\+T\+\_\+\+U\+S\+EC}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{L\+I\+M\+I\+T\+\_\+\+U\+S\+EC}{LIMIT_USEC}}]{\setlength{\rightskip}{0pt plus 5cm}\#define L\+I\+M\+I\+T\+\_\+\+U\+S\+EC~(1000000)}\hypertarget{clock_8c_aa7198679962b072a364206f696a1a6ff}{}\label{clock_8c_aa7198679962b072a364206f696a1a6ff}


\subsection{Function Documentation}
\index{clock.\+c@{clock.\+c}!clk\+\_\+\+Get\+Relative\+Time@{clk\+\_\+\+Get\+Relative\+Time}}
\index{clk\+\_\+\+Get\+Relative\+Time@{clk\+\_\+\+Get\+Relative\+Time}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{clk\+\_\+\+Get\+Relative\+Time(bool Is\+Wakeup)}{clk_GetRelativeTime(bool IsWakeup)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t} clk\+\_\+\+Get\+Relative\+Time (
\begin{DoxyParamCaption}
\item[{bool}]{Is\+Wakeup}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_ab5c7a819f6ecd37a76ca6e938c97c186}{}\label{clock_8c_ab5c7a819f6ecd37a76ca6e938c97c186}
Get relative time since some fixed but unspecified starting point. However, retrieve the time based on the desired wakeup behaviour. Is\+Wakeup\+: False -\/ Use non-\/waking clock. Otherwise not.

\begin{DoxyReturn}{Returns}
Relative time in seconds/microseconds 
\end{DoxyReturn}
\index{clock.\+c@{clock.\+c}!Format\+Broken\+Time@{Format\+Broken\+Time}}
\index{Format\+Broken\+Time@{Format\+Broken\+Time}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{Format\+Broken\+Time(le\+\_\+clk\+\_\+\+Time\+\_\+t absolute\+Time, struct tm broken\+Time, const char $\ast$format\+Spec\+Str\+Ptr, char $\ast$dest\+Str\+Ptr, size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)}{FormatBrokenTime(le_clk_Time_t absoluteTime, struct tm brokenTime, const char *formatSpecStrPtr, char *destStrPtr, size_t destSize, size_t *numBytesPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf le\+\_\+result\+\_\+t} Format\+Broken\+Time (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t}}]{absolute\+Time, }
\item[{struct tm}]{broken\+Time, }
\item[{const char $\ast$}]{format\+Spec\+Str\+Ptr, }
\item[{char $\ast$}]{dest\+Str\+Ptr, }
\item[{size\+\_\+t}]{dest\+Size, }
\item[{size\+\_\+t $\ast$}]{num\+Bytes\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{clock_8c_a26650d7050cde1045429612e12ce4821}{}\label{clock_8c_a26650d7050cde1045429612e12ce4821}
Convert broken down time into a formatted string.

The formatted date/time string, including N\+U\+L\+L-\/terminator, will be copied to the destination buffer, provided it fits, and the number of bytes copied (not including the N\+U\+L\+L-\/terminator) will be returned in num\+Bytes\+Ptr.

If the formatted date/time string does not fit in the destination buffer, then the contents of the destination buffer are undefined, and the value returned in num\+Bytes\+Ptr is zero.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if the formatted string was copied to dest\+Str\+Ptr
\item L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if the formatted string would not fit in dest\+Str\+Ptr 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em absolute\+Time} & Absolute time. \\
\hline
\mbox{\tt in}  & {\em broken\+Time} & The broken-\/down time based on the absolute time. \\
\hline
\mbox{\tt in}  & {\em format\+Spec\+Str\+Ptr} & Format specifier string, using conversion specifiers defined for strftime(). \\
\hline
\mbox{\tt out}  & {\em dest\+Str\+Ptr} & Destination for the formatted date/time string \\
\hline
\mbox{\tt in}  & {\em dest\+Size} & Size of the destination buffer in bytes. \\
\hline
\mbox{\tt out}  & {\em num\+Bytes\+Ptr} & Number of bytes copied, not including N\+U\+L\+L-\/terminator. This parameter can be set to N\+U\+LL if the number of bytes copied is not needed. \\
\hline
\end{DoxyParams}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Add@{le\+\_\+clk\+\_\+\+Add}}
\index{le\+\_\+clk\+\_\+\+Add@{le\+\_\+clk\+\_\+\+Add}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Add(le\+\_\+clk\+\_\+\+Time\+\_\+t time\+A, le\+\_\+clk\+\_\+\+Time\+\_\+t time\+B)}{le_clk_Add(le_clk_Time_t timeA, le_clk_Time_t timeB)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t} le\+\_\+clk\+\_\+\+Add (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t}}]{timeA, }
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t}}]{timeB}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_a6f4bda0268cd9349b6eb81ae350575fc}{}\label{clock_8c_a6f4bda0268cd9349b6eb81ae350575fc}
Add two time values together, and return the result.

\begin{DoxyReturn}{Returns}
The sum of the two time values 
\end{DoxyReturn}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Convert\+To\+Local\+Time\+String@{le\+\_\+clk\+\_\+\+Convert\+To\+Local\+Time\+String}}
\index{le\+\_\+clk\+\_\+\+Convert\+To\+Local\+Time\+String@{le\+\_\+clk\+\_\+\+Convert\+To\+Local\+Time\+String}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Convert\+To\+Local\+Time\+String(le\+\_\+clk\+\_\+\+Time\+\_\+t time, const char $\ast$format\+Spec\+Str\+Ptr, char $\ast$dest\+Str\+Ptr, size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)}{le_clk_ConvertToLocalTimeString(le_clk_Time_t time, const char *formatSpecStrPtr, char *destStrPtr, size_t destSize, size_t *numBytesPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+clk\+\_\+\+Convert\+To\+Local\+Time\+String (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t}}]{time, }
\item[{const char $\ast$}]{format\+Spec\+Str\+Ptr, }
\item[{char $\ast$}]{dest\+Str\+Ptr, }
\item[{size\+\_\+t}]{dest\+Size, }
\item[{size\+\_\+t $\ast$}]{num\+Bytes\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_a62c3e4ca5b0862938aea139f30846884}{}\label{clock_8c_a62c3e4ca5b0862938aea139f30846884}
Generate a printable string representation of a given absolute date/time value as a local time (with timezone offset applied).

The formatted date/time string, including N\+U\+L\+L-\/terminator, will be copied to the destination buffer, provided it fits, and the number of bytes copied (not including the N\+U\+L\+L-\/terminator) will be returned in num\+Bytes\+Ptr.

If the formatted date/time string does not fit in the destination buffer, then the contents of the destination buffer are undefined, and the value returned in num\+Bytes\+Ptr is zero.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if the formatted string was copied to dest\+Str\+Ptr
\item L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if the formatted string would not fit in dest\+Str\+Ptr 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em time} & date/time to convert \\
\hline
\mbox{\tt in}  & {\em format\+Spec\+Str\+Ptr} & Format specifier string, using conversion specifiers defined for strftime(). \\
\hline
\mbox{\tt out}  & {\em dest\+Str\+Ptr} & Destination for the formatted date/time string \\
\hline
\mbox{\tt in}  & {\em dest\+Size} & Size of the destination buffer in bytes. \\
\hline
\mbox{\tt out}  & {\em num\+Bytes\+Ptr} & Number of bytes copied, not including N\+U\+L\+L-\/terminator. Parameter can be set to N\+U\+LL if the number of bytes copied is not needed. \\
\hline
\end{DoxyParams}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Convert\+To\+Time@{le\+\_\+clk\+\_\+\+Convert\+To\+Time}}
\index{le\+\_\+clk\+\_\+\+Convert\+To\+Time@{le\+\_\+clk\+\_\+\+Convert\+To\+Time}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Convert\+To\+Time(const char $\ast$format\+Spec\+Str\+Ptr, const char $\ast$src\+Str\+Ptr, le\+\_\+clk\+\_\+\+Time\+\_\+t $\ast$time\+Ptr)}{le_clk_ConvertToTime(const char *formatSpecStrPtr, const char *srcStrPtr, le_clk_Time_t *timePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+clk\+\_\+\+Convert\+To\+Time (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{format\+Spec\+Str\+Ptr, }
\item[{const char $\ast$}]{src\+Str\+Ptr, }
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t} $\ast$}]{time\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_aac966e18d931982c8ad19a3dc7271042}{}\label{clock_8c_aac966e18d931982c8ad19a3dc7271042}
Generate an absolute date/time value as U\+TC time representation of a given printable string representation (no timezone offset applied).

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if the conversion was successful
\item L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER if an invalid parameter is provided
\item L\+E\+\_\+\+F\+A\+U\+LT if an error occurred 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em format\+Spec\+Str\+Ptr} & Format specifier string, using conversion specifiers defined for strptime(). \\
\hline
\mbox{\tt in}  & {\em src\+Str\+Ptr} & Formatted date/time string. \\
\hline
\mbox{\tt out}  & {\em time\+Ptr} & Converted date/time. \\
\hline
\end{DoxyParams}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Convert\+To\+U\+T\+C\+String@{le\+\_\+clk\+\_\+\+Convert\+To\+U\+T\+C\+String}}
\index{le\+\_\+clk\+\_\+\+Convert\+To\+U\+T\+C\+String@{le\+\_\+clk\+\_\+\+Convert\+To\+U\+T\+C\+String}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Convert\+To\+U\+T\+C\+String(le\+\_\+clk\+\_\+\+Time\+\_\+t time, const char $\ast$format\+Spec\+Str\+Ptr, char $\ast$dest\+Str\+Ptr, size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)}{le_clk_ConvertToUTCString(le_clk_Time_t time, const char *formatSpecStrPtr, char *destStrPtr, size_t destSize, size_t *numBytesPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+clk\+\_\+\+Convert\+To\+U\+T\+C\+String (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t}}]{time, }
\item[{const char $\ast$}]{format\+Spec\+Str\+Ptr, }
\item[{char $\ast$}]{dest\+Str\+Ptr, }
\item[{size\+\_\+t}]{dest\+Size, }
\item[{size\+\_\+t $\ast$}]{num\+Bytes\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_ae06285727609683956c22f6af2937f64}{}\label{clock_8c_ae06285727609683956c22f6af2937f64}
Generate a printable string representation of a given absolute date/time value as U\+TC time (no timezone offset applied).

The formatted date/time string, including N\+U\+L\+L-\/terminator, will be copied to the destination buffer, provided it fits, and the number of bytes copied (not including the N\+U\+L\+L-\/terminator) will be returned in num\+Bytes\+Ptr.

If the formatted date/time string does not fit in the destination buffer, the contents of the destination buffer will be undefined and the value returned in num\+Bytes\+Ptr will be zero.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if the formatted string was copied to dest\+Str\+Ptr
\item L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if the formatted string would not fit in dest\+Str\+Ptr 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em time} & date/time to convert \\
\hline
\mbox{\tt in}  & {\em format\+Spec\+Str\+Ptr} & Format specifier string, using conversion specifiers defined for strftime(). \\
\hline
\mbox{\tt out}  & {\em dest\+Str\+Ptr} & Destination for the formatted date/time string \\
\hline
\mbox{\tt in}  & {\em dest\+Size} & Size of the destination buffer in bytes. \\
\hline
\mbox{\tt out}  & {\em num\+Bytes\+Ptr} & Number of bytes copied, not including N\+U\+L\+L-\/terminator. Parameter can be set to N\+U\+LL if the number of bytes copied is not needed. \\
\hline
\end{DoxyParams}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Equal@{le\+\_\+clk\+\_\+\+Equal}}
\index{le\+\_\+clk\+\_\+\+Equal@{le\+\_\+clk\+\_\+\+Equal}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Equal(le\+\_\+clk\+\_\+\+Time\+\_\+t time\+A, le\+\_\+clk\+\_\+\+Time\+\_\+t time\+B)}{le_clk_Equal(le_clk_Time_t timeA, le_clk_Time_t timeB)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+clk\+\_\+\+Equal (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t}}]{timeA, }
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t}}]{timeB}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_a164476582afdec88bdd48ad5255dce17}{}\label{clock_8c_a164476582afdec88bdd48ad5255dce17}
Compare two time values.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item T\+R\+UE if TimeA == TimeB
\item F\+A\+L\+SE otherwise 
\end{DoxyItemize}
\end{DoxyReturn}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Get\+Absolute\+Time@{le\+\_\+clk\+\_\+\+Get\+Absolute\+Time}}
\index{le\+\_\+clk\+\_\+\+Get\+Absolute\+Time@{le\+\_\+clk\+\_\+\+Get\+Absolute\+Time}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Get\+Absolute\+Time(void)}{le_clk_GetAbsoluteTime(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t} le\+\_\+clk\+\_\+\+Get\+Absolute\+Time (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_a33197dbd676a37b8c4d5de8f93edc1ee}{}\label{clock_8c_a33197dbd676a37b8c4d5de8f93edc1ee}
Get absolute time since the Epoch, 1970-\/01-\/01 00\+:00\+:00 +0000 (U\+TC).

\begin{DoxyReturn}{Returns}
The absolute time in seconds/microseconds
\end{DoxyReturn}
\begin{DoxyNote}{Note}

\begin{DoxyItemize}
\item The absolute time includes any time that the processor is suspended.
\item It is a fatal error if the absolute time cannot be returned 
\end{DoxyItemize}
\end{DoxyNote}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Get\+Local\+Date\+Time\+String@{le\+\_\+clk\+\_\+\+Get\+Local\+Date\+Time\+String}}
\index{le\+\_\+clk\+\_\+\+Get\+Local\+Date\+Time\+String@{le\+\_\+clk\+\_\+\+Get\+Local\+Date\+Time\+String}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Get\+Local\+Date\+Time\+String(const char $\ast$format\+Spec\+Str\+Ptr, char $\ast$dest\+Str\+Ptr, size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)}{le_clk_GetLocalDateTimeString(const char *formatSpecStrPtr, char *destStrPtr, size_t destSize, size_t *numBytesPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+clk\+\_\+\+Get\+Local\+Date\+Time\+String (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{format\+Spec\+Str\+Ptr, }
\item[{char $\ast$}]{dest\+Str\+Ptr, }
\item[{size\+\_\+t}]{dest\+Size, }
\item[{size\+\_\+t $\ast$}]{num\+Bytes\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_a6f37c2a2171eac23ddc306de1fd55f5c}{}\label{clock_8c_a6f37c2a2171eac23ddc306de1fd55f5c}
Get the Local date/time as a formatted string.

The formatted date/time string, including N\+U\+L\+L-\/terminator, will be copied to the destination buffer, provided it fits, and the number of bytes copied (not including the N\+U\+L\+L-\/terminator) will be returned in num\+Bytes\+Ptr.

If the formatted date/time string does not fit in the destination buffer, then the contents of the destination buffer are undefined, and the value returned in num\+Bytes\+Ptr is zero.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if the formatted string was copied to dest\+Str\+Ptr
\item L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if the formatted string would not fit in dest\+Str\+Ptr 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em format\+Spec\+Str\+Ptr} & Format specifier string, using conversion specifiers defined for strftime(). \\
\hline
\mbox{\tt out}  & {\em dest\+Str\+Ptr} & Destination for the formatted date/time string \\
\hline
\mbox{\tt in}  & {\em dest\+Size} & Size of the destination buffer in bytes. \\
\hline
\mbox{\tt out}  & {\em num\+Bytes\+Ptr} & Number of bytes copied, not including N\+U\+L\+L-\/terminator. This parameter can be set to N\+U\+LL if the number of bytes copied is not needed. \\
\hline
\end{DoxyParams}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Get\+Relative\+Time@{le\+\_\+clk\+\_\+\+Get\+Relative\+Time}}
\index{le\+\_\+clk\+\_\+\+Get\+Relative\+Time@{le\+\_\+clk\+\_\+\+Get\+Relative\+Time}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Get\+Relative\+Time(void)}{le_clk_GetRelativeTime(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t} le\+\_\+clk\+\_\+\+Get\+Relative\+Time (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_a298619d8c1d8f107cb03b8600f09a42b}{}\label{clock_8c_a298619d8c1d8f107cb03b8600f09a42b}
Get relative time since some fixed but unspecified starting point.

\begin{DoxyReturn}{Returns}
The relative time in seconds/microseconds
\end{DoxyReturn}
\begin{DoxyNote}{Note}

\begin{DoxyItemize}
\item The relative time includes any time that the processor is suspended.
\item It is a fatal error if the relative time cannot be returned 
\end{DoxyItemize}
\end{DoxyNote}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Get\+U\+T\+C\+Date\+Time\+String@{le\+\_\+clk\+\_\+\+Get\+U\+T\+C\+Date\+Time\+String}}
\index{le\+\_\+clk\+\_\+\+Get\+U\+T\+C\+Date\+Time\+String@{le\+\_\+clk\+\_\+\+Get\+U\+T\+C\+Date\+Time\+String}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Get\+U\+T\+C\+Date\+Time\+String(const char $\ast$format\+Spec\+Str\+Ptr, char $\ast$dest\+Str\+Ptr, size\+\_\+t dest\+Size, size\+\_\+t $\ast$num\+Bytes\+Ptr)}{le_clk_GetUTCDateTimeString(const char *formatSpecStrPtr, char *destStrPtr, size_t destSize, size_t *numBytesPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+clk\+\_\+\+Get\+U\+T\+C\+Date\+Time\+String (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{format\+Spec\+Str\+Ptr, }
\item[{char $\ast$}]{dest\+Str\+Ptr, }
\item[{size\+\_\+t}]{dest\+Size, }
\item[{size\+\_\+t $\ast$}]{num\+Bytes\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_a5392b8eb7d45ce86c0842a0a69975059}{}\label{clock_8c_a5392b8eb7d45ce86c0842a0a69975059}
Get the U\+TC date/time as a formatted string.

The formatted date/time string, including N\+U\+L\+L-\/terminator, will be copied to the destination buffer, provided it fits, and the number of bytes copied (not including the N\+U\+L\+L-\/terminator) will be returned in num\+Bytes\+Ptr.

If the formatted date/time string does not fit in the destination buffer, then the contents of the destination buffer are undefined, and the value returned in num\+Bytes\+Ptr is zero.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if the formatted string was copied to dest\+Str
\item L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW if the formatted string would not fit in dest\+Str 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em format\+Spec\+Str\+Ptr} & Format specifier string, using conversion specifiers defined for strftime(). \\
\hline
\mbox{\tt out}  & {\em dest\+Str\+Ptr} & Destination for the formatted date/time string \\
\hline
\mbox{\tt in}  & {\em dest\+Size} & Size of the destination buffer in bytes. \\
\hline
\mbox{\tt out}  & {\em num\+Bytes\+Ptr} & Number of bytes copied, not including N\+U\+L\+L-\/terminator. This parameter can be set to N\+U\+LL if the number of bytes copied is not needed. \\
\hline
\end{DoxyParams}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Greater\+Than@{le\+\_\+clk\+\_\+\+Greater\+Than}}
\index{le\+\_\+clk\+\_\+\+Greater\+Than@{le\+\_\+clk\+\_\+\+Greater\+Than}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Greater\+Than(le\+\_\+clk\+\_\+\+Time\+\_\+t time\+A, le\+\_\+clk\+\_\+\+Time\+\_\+t time\+B)}{le_clk_GreaterThan(le_clk_Time_t timeA, le_clk_Time_t timeB)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+clk\+\_\+\+Greater\+Than (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t}}]{timeA, }
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t}}]{timeB}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_ac4a550ee8aa5fad9c81a33024946660a}{}\label{clock_8c_ac4a550ee8aa5fad9c81a33024946660a}
Compare two time values.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item T\+R\+UE if TimeA $>$ TimeB
\item F\+A\+L\+SE otherwise 
\end{DoxyItemize}
\end{DoxyReturn}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Multiply@{le\+\_\+clk\+\_\+\+Multiply}}
\index{le\+\_\+clk\+\_\+\+Multiply@{le\+\_\+clk\+\_\+\+Multiply}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Multiply(le\+\_\+clk\+\_\+\+Time\+\_\+t time\+A, int scale\+Factor)}{le_clk_Multiply(le_clk_Time_t timeA, int scaleFactor)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t} le\+\_\+clk\+\_\+\+Multiply (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t}}]{timeA, }
\item[{int}]{scale\+Factor}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_a77961175ee422b1418a18eece5192c9c}{}\label{clock_8c_a77961175ee422b1418a18eece5192c9c}
Multiply the time by a scale factor, and return the result

\begin{DoxyReturn}{Returns}
Time multiplied by scale factor 
\end{DoxyReturn}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Set\+Absolute\+Time@{le\+\_\+clk\+\_\+\+Set\+Absolute\+Time}}
\index{le\+\_\+clk\+\_\+\+Set\+Absolute\+Time@{le\+\_\+clk\+\_\+\+Set\+Absolute\+Time}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Set\+Absolute\+Time(le\+\_\+clk\+\_\+\+Time\+\_\+t absolute\+Time)}{le_clk_SetAbsoluteTime(le_clk_Time_t absoluteTime)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+clk\+\_\+\+Set\+Absolute\+Time (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t}}]{absolute\+Time}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_a4eccd60ca4f915c546f811d3574864a8}{}\label{clock_8c_a4eccd60ca4f915c546f811d3574864a8}
Set absolute time since the Epoch, 1970-\/01-\/01 00\+:00\+:00 +0000 (U\+TC).

\begin{DoxyNote}{Note}
Only unsandboxed application can set the date/time.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if the function succeeded
\item L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER if an invalid parameter is provided
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+P\+E\+R\+M\+I\+T\+T\+ED if the operation is not permitted
\item L\+E\+\_\+\+F\+A\+U\+LT if an error occurred 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em absolute\+Time} & Absolute time in seconds/microseconds \\
\hline
\end{DoxyParams}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Set\+U\+T\+C\+Date\+Time\+String@{le\+\_\+clk\+\_\+\+Set\+U\+T\+C\+Date\+Time\+String}}
\index{le\+\_\+clk\+\_\+\+Set\+U\+T\+C\+Date\+Time\+String@{le\+\_\+clk\+\_\+\+Set\+U\+T\+C\+Date\+Time\+String}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Set\+U\+T\+C\+Date\+Time\+String(const char $\ast$format\+Spec\+Str\+Ptr, const char $\ast$src\+Str\+Ptr)}{le_clk_SetUTCDateTimeString(const char *formatSpecStrPtr, const char *srcStrPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+clk\+\_\+\+Set\+U\+T\+C\+Date\+Time\+String (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{format\+Spec\+Str\+Ptr, }
\item[{const char $\ast$}]{src\+Str\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_a80f1414046ce8b151f6121e52aa7838c}{}\label{clock_8c_a80f1414046ce8b151f6121e52aa7838c}
Set the U\+TC date/time as a formatted string.

\begin{DoxyNote}{Note}
Only unsandboxed application can set the date/time.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if the time is correctly set
\item L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER if an invalid parameter is provided
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+P\+E\+R\+M\+I\+T\+T\+ED if the operation is not permitted
\item L\+E\+\_\+\+F\+A\+U\+LT if an error occurred 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em format\+Spec\+Str\+Ptr} & Format specifier string, using conversion specifiers defined for strptime(). \\
\hline
\mbox{\tt in}  & {\em src\+Str\+Ptr} & Formatted date/time string. \\
\hline
\end{DoxyParams}
\index{clock.\+c@{clock.\+c}!le\+\_\+clk\+\_\+\+Sub@{le\+\_\+clk\+\_\+\+Sub}}
\index{le\+\_\+clk\+\_\+\+Sub@{le\+\_\+clk\+\_\+\+Sub}!clock.\+c@{clock.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+clk\+\_\+\+Sub(le\+\_\+clk\+\_\+\+Time\+\_\+t time\+A, le\+\_\+clk\+\_\+\+Time\+\_\+t time\+B)}{le_clk_Sub(le_clk_Time_t timeA, le_clk_Time_t timeB)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t} le\+\_\+clk\+\_\+\+Sub (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t}}]{timeA, }
\item[{{\bf le\+\_\+clk\+\_\+\+Time\+\_\+t}}]{timeB}
\end{DoxyParamCaption}
)}\hypertarget{clock_8c_ac5b5ec6f462d598f4e5aa081224725ac}{}\label{clock_8c_ac5b5ec6f462d598f4e5aa081224725ac}
Subtract two time values, and return the result.

\begin{DoxyReturn}{Returns}
Result of (timeA -\/ timeB) 
\end{DoxyReturn}
