\hypertarget{signals_8c}{}\section{framework/liblegato/linux/signals.c File Reference}
\label{signals_8c}\index{framework/liblegato/linux/signals.\+c@{framework/liblegato/linux/signals.\+c}}
{\ttfamily \#include \char`\"{}legato.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}limit.\+h\char`\"{}}\\*
{\ttfamily \#include $<$ucontext.\+h$>$}\\*
{\ttfamily \#include $<$syslog.\+h$>$}\\*
{\ttfamily \#include $<$execinfo.\+h$>$}\\*
{\ttfamily \#include $<$setjmp.\+h$>$}\\*
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct_monitor_obj__t}{Monitor\+Obj\+\_\+t}
\item 
struct \hyperlink{struct_handler_obj__t}{Handler\+Obj\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{signals_8c_a369266c24eacffb87046522897a570d5}{\+\_\+\+G\+N\+U\+\_\+\+S\+O\+U\+R\+CE}
\item 
\#define \hyperlink{signals_8c_acc3b2d5b6dba18fe07087a065619bbc2}{S\+I\+G\+\_\+\+S\+TR}~\char`\"{}Sig\char`\"{}
\item 
\#define \hyperlink{signals_8c_a88d13b73bb278596844b801755aca552}{W\+R\+I\+TE}(\hyperlink{app_stop_client_8c_a44f21d5190b5a6df8089f54799628d7e}{fd},  buffer,  sz)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{struct_handler_obj__t}{Handler\+Obj\+\_\+t} $\ast$ \hyperlink{signals_8c_a28ec7d993c364c8de4a240a57ac5b1d0}{Find\+Handler\+Obj} (const int sig\+Num, \hyperlink{structle__dls___list__t}{le\+\_\+dls\+\_\+\+List\+\_\+t} $\ast$list\+Ptr)
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{signals_8c_a077c5e918a44362a7225bbd5bc3fd4e3}{Our\+Sig\+Handler} (int \hyperlink{app_stop_client_8c_a44f21d5190b5a6df8089f54799628d7e}{fd}, short events)
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{signals_8c_aa7dc58d39d6552abef5ef4b7f0898ff2}{Sig\+Seg\+V\+Handler} (int signum)
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{signals_8c_a199eff4756a32175cf3f684770827177}{Show\+Stack\+Signal\+Handler} (int sig\+Num, siginfo\+\_\+t $\ast$sig\+Info\+Ptr, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$sig\+Void\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{signals_8c_acae2ca62730ef3e9834779c4948f5812}{le\+\_\+sig\+\_\+\+Install\+Show\+Stack\+Handler} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{signals_8c_acaeb18d6d39617557407a4d628096f18}{Term\+Signal\+Handler} (int sig\+Num)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{signals_8c_a8bc8661a69dd8f5378091a3099815253}{le\+\_\+sig\+\_\+\+Install\+Default\+Term\+Handler} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{signals_8c_ae763eee7e4b0c63c229f4d0d01f4d934}{sig\+\_\+\+Init} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{signals_8c_a095ec12deab6b6ed0475583586a6c4d7}{le\+\_\+sig\+\_\+\+Block} (int sig\+Num)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{signals_8c_a421910132f193dae70e8309dc86a86c4}{le\+\_\+sig\+\_\+\+Set\+Event\+Handler} (int sig\+Num, \hyperlink{le__signals_8h_a89301bf64254cdb071c5277c7762f32d}{le\+\_\+sig\+\_\+\+Event\+Handler\+Func\+\_\+t} sig\+Event\+Handler)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{signals_8c_ae921df0e028ec66f4920cf3ed655d398}{le\+\_\+sig\+\_\+\+Delete\+All} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \hyperlink{signals_8c_a4b327bce26282f497d79fe31e1eaeaf1}{Monitor\+Obj\+Pool}
\item 
static \hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \hyperlink{signals_8c_a4da2b58b4166191d6f7a6ec7e17458c2}{Handler\+Obj\+Pool}
\item 
static pthread\+\_\+key\+\_\+t \hyperlink{signals_8c_a8aeab1297fdc6ad7ac9c462c17cfe0a2}{Sig\+Mon\+Key}
\item 
static sigjmp\+\_\+buf \hyperlink{signals_8c_a3273ed9497760bb6284a7d2ab2f19436}{Sig\+Env}
\item 
static uint32\+\_\+t \hyperlink{signals_8c_ae77fbab864bf3ec3350774606f3bbfca}{Gdb\+Server\+Port} = 0
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This file implements the Legato Signal Events by making use of signal\+Fd. When the user sets a signal event handler the handler is stored in a list of handlers and associated with a single signal number. The signal mask for the thread is then updated.

Each thread has its own list of handlers and stores this list in the thread\textquotesingle{}s local data.

A monitor fd is created for each thread with atleast one handler but all monitor fds share a single fd handler, \hyperlink{signals_8c_a077c5e918a44362a7225bbd5bc3fd4e3}{Our\+Sig\+Handler()}. When \hyperlink{signals_8c_a077c5e918a44362a7225bbd5bc3fd4e3}{Our\+Sig\+Handler()} is invoked it grabs the list of handlers for the current thread and routes the signal to the proper user handler.

Copyright (C) Sierra Wireless Inc. 

\subsection{Macro Definition Documentation}
\index{signals.\+c@{signals.\+c}!\+\_\+\+G\+N\+U\+\_\+\+S\+O\+U\+R\+CE@{\+\_\+\+G\+N\+U\+\_\+\+S\+O\+U\+R\+CE}}
\index{\+\_\+\+G\+N\+U\+\_\+\+S\+O\+U\+R\+CE@{\+\_\+\+G\+N\+U\+\_\+\+S\+O\+U\+R\+CE}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{\+\_\+\+G\+N\+U\+\_\+\+S\+O\+U\+R\+CE}{_GNU_SOURCE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define \+\_\+\+G\+N\+U\+\_\+\+S\+O\+U\+R\+CE}\hypertarget{signals_8c_a369266c24eacffb87046522897a570d5}{}\label{signals_8c_a369266c24eacffb87046522897a570d5}
\index{signals.\+c@{signals.\+c}!S\+I\+G\+\_\+\+S\+TR@{S\+I\+G\+\_\+\+S\+TR}}
\index{S\+I\+G\+\_\+\+S\+TR@{S\+I\+G\+\_\+\+S\+TR}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{S\+I\+G\+\_\+\+S\+TR}{SIG_STR}}]{\setlength{\rightskip}{0pt plus 5cm}\#define S\+I\+G\+\_\+\+S\+TR~\char`\"{}Sig\char`\"{}}\hypertarget{signals_8c_acc3b2d5b6dba18fe07087a065619bbc2}{}\label{signals_8c_acc3b2d5b6dba18fe07087a065619bbc2}
Prefix for the monitor\textquotesingle{}s name. The monitor\textquotesingle{}s name is this prefix plus the name of the thread. \index{signals.\+c@{signals.\+c}!W\+R\+I\+TE@{W\+R\+I\+TE}}
\index{W\+R\+I\+TE@{W\+R\+I\+TE}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{W\+R\+I\+TE}{WRITE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define W\+R\+I\+TE(
\begin{DoxyParamCaption}
\item[{}]{{\bf fd}, }
\item[{}]{buffer, }
\item[{}]{sz}
\end{DoxyParamCaption}
)}\hypertarget{signals_8c_a88d13b73bb278596844b801755aca552}{}\label{signals_8c_a88d13b73bb278596844b801755aca552}
{\bfseries Value\+:}
\begin{DoxyCode}
\textcolor{keywordflow}{do} \{                                 \(\backslash\)
                int \_rc;                         \(\backslash\)
                \_rc = write((\hyperlink{app_stop_client_8c_a44f21d5190b5a6df8089f54799628d7e}{fd}),(buffer),(sz)); \hyperlink{service_directory_8c_a1d84aa99c70d8cb8f479b606b96ae7e0}{\(\backslash\)}
\hyperlink{service_directory_8c_a1d84aa99c70d8cb8f479b606b96ae7e0}{                if} ((\_rc >= 0) && (\_rc < (sz)))  \(\backslash\)
                \{                                \(\backslash\)
                    \_rc = write((\hyperlink{app_stop_client_8c_a44f21d5190b5a6df8089f54799628d7e}{fd}),(buffer) + \_rc,(sz) - \_rc); \(\backslash\)
                \}                                \(\backslash\)
            \} \textcolor{keywordflow}{while}(0)
\end{DoxyCode}
W\+R\+I\+TE macro to discard the return code inside the Show\+Stack\+Signal\+Handler 

\subsection{Function Documentation}
\index{signals.\+c@{signals.\+c}!Find\+Handler\+Obj@{Find\+Handler\+Obj}}
\index{Find\+Handler\+Obj@{Find\+Handler\+Obj}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{Find\+Handler\+Obj(const int sig\+Num, le\+\_\+dls\+\_\+\+List\+\_\+t $\ast$list\+Ptr)}{FindHandlerObj(const int sigNum, le_dls_List_t *listPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf Handler\+Obj\+\_\+t}$\ast$ Find\+Handler\+Obj (
\begin{DoxyParamCaption}
\item[{const int}]{sig\+Num, }
\item[{{\bf le\+\_\+dls\+\_\+\+List\+\_\+t} $\ast$}]{list\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{signals_8c_a28ec7d993c364c8de4a240a57ac5b1d0}{}\label{signals_8c_a28ec7d993c364c8de4a240a57ac5b1d0}
Returns the handler object with the matching sig\+Num from the list.

\begin{DoxyReturn}{Returns}
A pointer to the handler object with a matching sig\+Num if found. N\+U\+LL if a matching sig\+Num could not be found. 
\end{DoxyReturn}
\index{signals.\+c@{signals.\+c}!le\+\_\+sig\+\_\+\+Block@{le\+\_\+sig\+\_\+\+Block}}
\index{le\+\_\+sig\+\_\+\+Block@{le\+\_\+sig\+\_\+\+Block}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+sig\+\_\+\+Block(int sig\+Num)}{le_sig_Block(int sigNum)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+sig\+\_\+\+Block (
\begin{DoxyParamCaption}
\item[{int}]{sig\+Num}
\end{DoxyParamCaption}
)}\hypertarget{signals_8c_a095ec12deab6b6ed0475583586a6c4d7}{}\label{signals_8c_a095ec12deab6b6ed0475583586a6c4d7}
Blocks a signal in the calling thread.

Signals that an event handler will be set for must be blocked for all threads in the process. To ensure that the signals are blocked in all threads call this function in the process\textquotesingle{} first thread, all subsequent threads will inherit the signal mask.

\begin{DoxyNote}{Note}
Does not return on failure. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em sig\+Num} & Signal to block. \\
\hline
\end{DoxyParams}
\index{signals.\+c@{signals.\+c}!le\+\_\+sig\+\_\+\+Delete\+All@{le\+\_\+sig\+\_\+\+Delete\+All}}
\index{le\+\_\+sig\+\_\+\+Delete\+All@{le\+\_\+sig\+\_\+\+Delete\+All}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+sig\+\_\+\+Delete\+All(void)}{le_sig_DeleteAll(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+sig\+\_\+\+Delete\+All (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{signals_8c_ae921df0e028ec66f4920cf3ed655d398}{}\label{signals_8c_ae921df0e028ec66f4920cf3ed655d398}
Removes all signal event handlers for the calling thread and cleans up any resources used for signal events. This should be called before the thread exits. \index{signals.\+c@{signals.\+c}!le\+\_\+sig\+\_\+\+Install\+Default\+Term\+Handler@{le\+\_\+sig\+\_\+\+Install\+Default\+Term\+Handler}}
\index{le\+\_\+sig\+\_\+\+Install\+Default\+Term\+Handler@{le\+\_\+sig\+\_\+\+Install\+Default\+Term\+Handler}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+sig\+\_\+\+Install\+Default\+Term\+Handler(void)}{le_sig_InstallDefaultTermHandler(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+sig\+\_\+\+Install\+Default\+Term\+Handler (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{signals_8c_a8bc8661a69dd8f5378091a3099815253}{}\label{signals_8c_a8bc8661a69dd8f5378091a3099815253}
Install a default handler to handle the S\+I\+G\+T\+E\+RM signal.

Called automatically by \hyperlink{start_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main()}. \index{signals.\+c@{signals.\+c}!le\+\_\+sig\+\_\+\+Install\+Show\+Stack\+Handler@{le\+\_\+sig\+\_\+\+Install\+Show\+Stack\+Handler}}
\index{le\+\_\+sig\+\_\+\+Install\+Show\+Stack\+Handler@{le\+\_\+sig\+\_\+\+Install\+Show\+Stack\+Handler}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+sig\+\_\+\+Install\+Show\+Stack\+Handler(void)}{le_sig_InstallShowStackHandler(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+sig\+\_\+\+Install\+Show\+Stack\+Handler (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{signals_8c_acae2ca62730ef3e9834779c4948f5812}{}\label{signals_8c_acae2ca62730ef3e9834779c4948f5812}
Install the Show\+Stack\+Signal\+Handler to show information and dump stack \index{signals.\+c@{signals.\+c}!le\+\_\+sig\+\_\+\+Set\+Event\+Handler@{le\+\_\+sig\+\_\+\+Set\+Event\+Handler}}
\index{le\+\_\+sig\+\_\+\+Set\+Event\+Handler@{le\+\_\+sig\+\_\+\+Set\+Event\+Handler}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+sig\+\_\+\+Set\+Event\+Handler(int sig\+Num, le\+\_\+sig\+\_\+\+Event\+Handler\+Func\+\_\+t sig\+Event\+Handler)}{le_sig_SetEventHandler(int sigNum, le_sig_EventHandlerFunc_t sigEventHandler)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+sig\+\_\+\+Set\+Event\+Handler (
\begin{DoxyParamCaption}
\item[{int}]{sig\+Num, }
\item[{{\bf le\+\_\+sig\+\_\+\+Event\+Handler\+Func\+\_\+t}}]{sig\+Event\+Handler}
\end{DoxyParamCaption}
)}\hypertarget{signals_8c_a421910132f193dae70e8309dc86a86c4}{}\label{signals_8c_a421910132f193dae70e8309dc86a86c4}
Set a signal event handler for the calling thread. Each signal can only have a single event handler. The most recent event handler set will be called when the signal is received. sig\+Event\+Handler can be set to N\+U\+LL to remove a previously set handler.


\begin{DoxyParams}{Parameters}
{\em sig\+Num} & Cannot be S\+I\+G\+K\+I\+LL or S\+I\+G\+S\+T\+OP or any program error signals\+: S\+I\+G\+F\+PE, S\+I\+G\+I\+LL, S\+I\+G\+S\+E\+GV, S\+I\+G\+B\+US, S\+I\+G\+A\+B\+RT, S\+I\+G\+I\+OT, S\+I\+G\+T\+R\+AP, S\+I\+G\+E\+MT, S\+I\+G\+S\+YS.\\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Does not return on failure. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em sig\+Num} & The signal to set the event handler for. See parameter documentation in comments above. \\
\hline
{\em sig\+Event\+Handler} & The event handler to call when a signal is received. \\
\hline
\end{DoxyParams}
\index{signals.\+c@{signals.\+c}!Our\+Sig\+Handler@{Our\+Sig\+Handler}}
\index{Our\+Sig\+Handler@{Our\+Sig\+Handler}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{Our\+Sig\+Handler(int fd, short events)}{OurSigHandler(int fd, short events)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Our\+Sig\+Handler (
\begin{DoxyParamCaption}
\item[{int}]{fd, }
\item[{short}]{events}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{signals_8c_a077c5e918a44362a7225bbd5bc3fd4e3}{}\label{signals_8c_a077c5e918a44362a7225bbd5bc3fd4e3}
Our signal handler. This signal handler gets called whenever any unmasked signals are received. This handler will read the signal info and call the appropriate user handler. 
\begin{DoxyParams}{Parameters}
{\em fd} & The monitored file descriptor. \\
\hline
{\em events} & The event or events (bit mask) that occurred on the fd. \\
\hline
\end{DoxyParams}
\index{signals.\+c@{signals.\+c}!Show\+Stack\+Signal\+Handler@{Show\+Stack\+Signal\+Handler}}
\index{Show\+Stack\+Signal\+Handler@{Show\+Stack\+Signal\+Handler}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{Show\+Stack\+Signal\+Handler(int sig\+Num, siginfo\+\_\+t $\ast$sig\+Info\+Ptr, void $\ast$sig\+Void\+Ptr)}{ShowStackSignalHandler(int sigNum, siginfo_t *sigInfoPtr, void *sigVoidPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Show\+Stack\+Signal\+Handler (
\begin{DoxyParamCaption}
\item[{int}]{sig\+Num, }
\item[{siginfo\+\_\+t $\ast$}]{sig\+Info\+Ptr, }
\item[{{\bf void} $\ast$}]{sig\+Void\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{signals_8c_a199eff4756a32175cf3f684770827177}{}\label{signals_8c_a199eff4756a32175cf3f684770827177}
Our show stack signal handler. This signal handler is called only when S\+E\+GV, I\+LL, B\+US, F\+PE, A\+B\+RT T\+R\+AP are raised. It will show useful informations\+: signal, fault address, fault PC, registers, stack and back-\/trace. It also dumps the process maps. Note\+: Because these signals are raised from low-\/level, we should avoid any usage of malloc(3), syslog(3) and others services like these from stdio(3).

\begin{DoxyNote}{Note}
This code is architecture dependant, and supports arm, x86\+\_\+64, i586 and i686. 

Some unsafe functions are used\+:
\begin{DoxyItemize}
\item snprintf
\item backtrace (not on arm)
\item sigsetjmp/siglongjmp 
\end{DoxyItemize}
\end{DoxyNote}
\index{signals.\+c@{signals.\+c}!sig\+\_\+\+Init@{sig\+\_\+\+Init}}
\index{sig\+\_\+\+Init@{sig\+\_\+\+Init}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{sig\+\_\+\+Init(void)}{sig_Init(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} sig\+\_\+\+Init (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{signals_8c_ae763eee7e4b0c63c229f4d0d01f4d934}{}\label{signals_8c_ae763eee7e4b0c63c229f4d0d01f4d934}
The signal event initialization function. This must be called before any other functions in this module is called. \index{signals.\+c@{signals.\+c}!Sig\+Seg\+V\+Handler@{Sig\+Seg\+V\+Handler}}
\index{Sig\+Seg\+V\+Handler@{Sig\+Seg\+V\+Handler}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{Sig\+Seg\+V\+Handler(int signum)}{SigSegVHandler(int signum)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Sig\+Seg\+V\+Handler (
\begin{DoxyParamCaption}
\item[{int}]{signum}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{signals_8c_aa7dc58d39d6552abef5ef4b7f0898ff2}{}\label{signals_8c_aa7dc58d39d6552abef5ef4b7f0898ff2}
S\+E\+GV handler used to handle a S\+E\+GV while executing the Show\+Stack\+Signal\+Handler handler. This will abort the current dump and next dump will be run. This is to prevent the first handler to crash while dumping a crushed stack and backtrace. As sigsetjmp() and siglongjmp() are used, a proctection by counter is added to avoid infinite loop. As two critical parts exists inside the Show\+Stack\+Signal\+Handler, this counter M\+U\+ST N\+OT be greater than 2. At the third call, there will be no recover from S\+E\+GV. \index{signals.\+c@{signals.\+c}!Term\+Signal\+Handler@{Term\+Signal\+Handler}}
\index{Term\+Signal\+Handler@{Term\+Signal\+Handler}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{Term\+Signal\+Handler(int sig\+Num)}{TermSignalHandler(int sigNum)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Term\+Signal\+Handler (
\begin{DoxyParamCaption}
\item[{int}]{sig\+Num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{signals_8c_acaeb18d6d39617557407a4d628096f18}{}\label{signals_8c_acaeb18d6d39617557407a4d628096f18}
Minimal signal handler that exists the application if a S\+I\+G\+T\+E\+RM has been received. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em sig\+Num} & The signal that was received. \\
\hline
\end{DoxyParams}


\subsection{Variable Documentation}
\index{signals.\+c@{signals.\+c}!Gdb\+Server\+Port@{Gdb\+Server\+Port}}
\index{Gdb\+Server\+Port@{Gdb\+Server\+Port}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{Gdb\+Server\+Port}{GdbServerPort}}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t Gdb\+Server\+Port = 0\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{signals_8c_ae77fbab864bf3ec3350774606f3bbfca}{}\label{signals_8c_ae77fbab864bf3ec3350774606f3bbfca}
Port to use for start and attach a gdbserver(1) to itself. If 0, no gdbserver(1) is started \index{signals.\+c@{signals.\+c}!Handler\+Obj\+Pool@{Handler\+Obj\+Pool}}
\index{Handler\+Obj\+Pool@{Handler\+Obj\+Pool}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{Handler\+Obj\+Pool}{HandlerObjPool}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} Handler\+Obj\+Pool\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{signals_8c_a4da2b58b4166191d6f7a6ec7e17458c2}{}\label{signals_8c_a4da2b58b4166191d6f7a6ec7e17458c2}
The signal event handler object memory pool. \index{signals.\+c@{signals.\+c}!Monitor\+Obj\+Pool@{Monitor\+Obj\+Pool}}
\index{Monitor\+Obj\+Pool@{Monitor\+Obj\+Pool}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{Monitor\+Obj\+Pool}{MonitorObjPool}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} Monitor\+Obj\+Pool\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{signals_8c_a4b327bce26282f497d79fe31e1eaeaf1}{}\label{signals_8c_a4b327bce26282f497d79fe31e1eaeaf1}
The signal event monitor object memory pool. \index{signals.\+c@{signals.\+c}!Sig\+Env@{Sig\+Env}}
\index{Sig\+Env@{Sig\+Env}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{Sig\+Env}{SigEnv}}]{\setlength{\rightskip}{0pt plus 5cm}sigjmp\+\_\+buf Sig\+Env\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{signals_8c_a3273ed9497760bb6284a7d2ab2f19436}{}\label{signals_8c_a3273ed9497760bb6284a7d2ab2f19436}
Stack, signals mask and context environment for sigsetjmp() and siglongjmp() \index{signals.\+c@{signals.\+c}!Sig\+Mon\+Key@{Sig\+Mon\+Key}}
\index{Sig\+Mon\+Key@{Sig\+Mon\+Key}!signals.\+c@{signals.\+c}}
\subsubsection[{\texorpdfstring{Sig\+Mon\+Key}{SigMonKey}}]{\setlength{\rightskip}{0pt plus 5cm}pthread\+\_\+key\+\_\+t Sig\+Mon\+Key\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{signals_8c_a8aeab1297fdc6ad7ac9c462c17cfe0a2}{}\label{signals_8c_a8aeab1297fdc6ad7ac9c462c17cfe0a2}
The thread local data\textquotesingle{}s key for monitor objects. 