\hypertarget{le__safe_ref_8h}{}\section{framework/include/le\+\_\+safe\+Ref.h File Reference}
\label{le__safe_ref_8h}\index{framework/include/le\+\_\+safe\+Ref.\+h@{framework/include/le\+\_\+safe\+Ref.\+h}}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct le\+\_\+ref\+\_\+\+Map $\ast$ \hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}
\item 
typedef struct le\+\_\+ref\+\_\+\+Iter $\ast$ \hyperlink{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} \hyperlink{le__safe_ref_8h_a85faf3c75723a1af0e1adf720d9c9dca}{le\+\_\+ref\+\_\+\+Create\+Map} (const char $\ast$name, size\+\_\+t max\+Refs)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{le__safe_ref_8h_a458597757cbce48e03413b49f52ec240}{le\+\_\+ref\+\_\+\+Create\+Ref} (\hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} map\+Ref, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{le__safe_ref_8h_a488dddfd579f4a20f39be392c4d7d2e0}{le\+\_\+ref\+\_\+\+Lookup} (\hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} map\+Ref, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$safe\+Ref)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{le__safe_ref_8h_a438e18b8ace1d4dda3ca5144a27bd424}{le\+\_\+ref\+\_\+\+Delete\+Ref} (\hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} map\+Ref, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$safe\+Ref)
\item 
\hyperlink{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t} \hyperlink{le__safe_ref_8h_ab7d9ebce866a3ad49a967e2eb8def2cc}{le\+\_\+ref\+\_\+\+Get\+Iterator} (\hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} map\+Ref)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__safe_ref_8h_ac6304fc29d2ce7c82f5ca3b210931783}{le\+\_\+ref\+\_\+\+Next\+Node} (\hyperlink{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t} iterator\+Ref)
\item 
const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{le__safe_ref_8h_a6ed3823acb88746e745d21cb1bfecc5d}{le\+\_\+ref\+\_\+\+Get\+Safe\+Ref} (\hyperlink{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t} iterator\+Ref)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{le__safe_ref_8h_acc77218e165d9d2456acff38280f8194}{le\+\_\+ref\+\_\+\+Get\+Value} (\hyperlink{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t} iterator\+Ref)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Legato \hyperlink{c_safeRef}{Safe References A\+PI} include file.

Copyright (C) Sierra Wireless Inc. 

\subsection{Typedef Documentation}
\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t@{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}}
\index{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t@{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}{le_ref_IterRef_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct le\+\_\+ref\+\_\+\+Iter$\ast$ {\bf le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}}\hypertarget{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}{}\label{le__safe_ref_8h_a01b183aea234146b2df8a0ade1451539}
Reference to an \char`\"{}iterator\char`\"{} object, used to manage iterating a collection of safe refs. \index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t@{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}}
\index{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t@{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}{le_ref_MapRef_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct le\+\_\+ref\+\_\+\+Map$\ast$ {\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}}\hypertarget{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{}\label{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}
Reference to a \char`\"{}\+Reference Map\char`\"{} object, which stores mappings from Safe References to pointers. 

\subsection{Function Documentation}
\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Create\+Map@{le\+\_\+ref\+\_\+\+Create\+Map}}
\index{le\+\_\+ref\+\_\+\+Create\+Map@{le\+\_\+ref\+\_\+\+Create\+Map}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+ref\+\_\+\+Create\+Map(const char $\ast$name, size\+\_\+t max\+Refs)}{le_ref_CreateMap(const char *name, size_t maxRefs)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} le\+\_\+ref\+\_\+\+Create\+Map (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{name, }
\item[{size\+\_\+t}]{max\+Refs}
\end{DoxyParamCaption}
)}\hypertarget{le__safe_ref_8h_a85faf3c75723a1af0e1adf720d9c9dca}{}\label{le__safe_ref_8h_a85faf3c75723a1af0e1adf720d9c9dca}
Create a Reference Map that can hold mappings from Safe References to pointers.

\begin{DoxyReturn}{Returns}
A reference to the Reference Map object. 
\end{DoxyReturn}
\begin{DoxyRefDesc}{Todo}
\item[\hyperlink{todo__todo000052}{Todo}]Make this a random number so that using a reference from another Map is unlikely to get by undetected. \end{DoxyRefDesc}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em name} & The name of the map (for diagnostics). \\
\hline
\mbox{\tt in}  & {\em max\+Refs} & The maximum number of Safe References expected to be kept in this Reference Map at any one time. \\
\hline
\end{DoxyParams}
\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Create\+Ref@{le\+\_\+ref\+\_\+\+Create\+Ref}}
\index{le\+\_\+ref\+\_\+\+Create\+Ref@{le\+\_\+ref\+\_\+\+Create\+Ref}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+ref\+\_\+\+Create\+Ref(le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t map\+Ref, void $\ast$ptr)}{le_ref_CreateRef(le_ref_MapRef_t mapRef, void *ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ le\+\_\+ref\+\_\+\+Create\+Ref (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}}]{map\+Ref, }
\item[{{\bf void} $\ast$}]{ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__safe_ref_8h_a458597757cbce48e03413b49f52ec240}{}\label{le__safe_ref_8h_a458597757cbce48e03413b49f52ec240}
Creates a Safe Reference, storing a mapping between that reference and a specified pointer for future lookup.

\begin{DoxyReturn}{Returns}
The Safe Reference.
\end{DoxyReturn}
Creates a Safe Reference, storing a mapping between that reference and a given pointer for future lookup.

\begin{DoxyReturn}{Returns}
The Safe Reference. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & The Reference Map in which the mapping should be kept. \\
\hline
\mbox{\tt in}  & {\em ptr} & Pointer value to which the new Safe Reference will be mapped. \\
\hline
\end{DoxyParams}
\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Delete\+Ref@{le\+\_\+ref\+\_\+\+Delete\+Ref}}
\index{le\+\_\+ref\+\_\+\+Delete\+Ref@{le\+\_\+ref\+\_\+\+Delete\+Ref}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+ref\+\_\+\+Delete\+Ref(le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t map\+Ref, void $\ast$safe\+Ref)}{le_ref_DeleteRef(le_ref_MapRef_t mapRef, void *safeRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+ref\+\_\+\+Delete\+Ref (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}}]{map\+Ref, }
\item[{{\bf void} $\ast$}]{safe\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{le__safe_ref_8h_a438e18b8ace1d4dda3ca5144a27bd424}{}\label{le__safe_ref_8h_a438e18b8ace1d4dda3ca5144a27bd424}
Deletes a Safe Reference. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & The Reference Map to delete the mapping from. \\
\hline
\mbox{\tt in}  & {\em safe\+Ref} & The Safe Reference to be deleted (invalidated). \\
\hline
\end{DoxyParams}
\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Get\+Iterator@{le\+\_\+ref\+\_\+\+Get\+Iterator}}
\index{le\+\_\+ref\+\_\+\+Get\+Iterator@{le\+\_\+ref\+\_\+\+Get\+Iterator}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+ref\+\_\+\+Get\+Iterator(le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t map\+Ref)}{le_ref_GetIterator(le_ref_MapRef_t mapRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t} le\+\_\+ref\+\_\+\+Get\+Iterator (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}}]{map\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{le__safe_ref_8h_ab7d9ebce866a3ad49a967e2eb8def2cc}{}\label{le__safe_ref_8h_ab7d9ebce866a3ad49a967e2eb8def2cc}
Gets an interator for step-\/by-\/step iteration over the map. In this mode the iteration is controlled by the calling function using the \hyperlink{le__safe_ref_8h_ac6304fc29d2ce7c82f5ca3b210931783}{le\+\_\+ref\+\_\+\+Next\+Node()} function. There is one iterator per map, and calling this function resets the iterator position to the start of the map. The iterator is not ready for data access until \hyperlink{le__safe_ref_8h_ac6304fc29d2ce7c82f5ca3b210931783}{le\+\_\+ref\+\_\+\+Next\+Node()} has been called at least once.

\begin{DoxyReturn}{Returns}
Returns A reference to a hashmap iterator which is ready for \hyperlink{le__hashmap_8h_a601b7d3e5d92e91e4090d726e5b190ca}{le\+\_\+hashmap\+\_\+\+Next\+Node()} to be called on it. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map. \\
\hline
\end{DoxyParams}
\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Get\+Safe\+Ref@{le\+\_\+ref\+\_\+\+Get\+Safe\+Ref}}
\index{le\+\_\+ref\+\_\+\+Get\+Safe\+Ref@{le\+\_\+ref\+\_\+\+Get\+Safe\+Ref}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+ref\+\_\+\+Get\+Safe\+Ref(le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t iterator\+Ref)}{le_ref_GetSafeRef(le_ref_IterRef_t iteratorRef)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf void}$\ast$ le\+\_\+ref\+\_\+\+Get\+Safe\+Ref (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}}]{iterator\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{le__safe_ref_8h_a6ed3823acb88746e745d21cb1bfecc5d}{}\label{le__safe_ref_8h_a6ed3823acb88746e745d21cb1bfecc5d}
Retrieves a pointer to the safe ref iterator is currently pointing at. If the iterator has just been initialized and \hyperlink{le__hashmap_8h_a601b7d3e5d92e91e4090d726e5b190ca}{le\+\_\+hashmap\+\_\+\+Next\+Node()} has not been called, or if the iterator has been invalidated then this will return N\+U\+LL.

\begin{DoxyReturn}{Returns}
A pointer to the current key, or N\+U\+LL if the iterator has been invalidated or is not ready. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iterator\+Ref} & Reference to the iterator. \\
\hline
\end{DoxyParams}
\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Get\+Value@{le\+\_\+ref\+\_\+\+Get\+Value}}
\index{le\+\_\+ref\+\_\+\+Get\+Value@{le\+\_\+ref\+\_\+\+Get\+Value}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+ref\+\_\+\+Get\+Value(le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t iterator\+Ref)}{le_ref_GetValue(le_ref_IterRef_t iteratorRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ le\+\_\+ref\+\_\+\+Get\+Value (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}}]{iterator\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{le__safe_ref_8h_acc77218e165d9d2456acff38280f8194}{}\label{le__safe_ref_8h_acc77218e165d9d2456acff38280f8194}
Retrieves a pointer to the value which the iterator is currently pointing at. If the iterator has just been initialized and \hyperlink{le__safe_ref_8h_ac6304fc29d2ce7c82f5ca3b210931783}{le\+\_\+ref\+\_\+\+Next\+Node()} has not been called, or if the iterator has been invalidated then this will return N\+U\+LL.

\begin{DoxyReturn}{Returns}
A pointer to the current value, or N\+U\+LL if the iterator has been invalidated or is not ready. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iterator\+Ref} & Reference to the iterator. \\
\hline
\end{DoxyParams}
\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Lookup@{le\+\_\+ref\+\_\+\+Lookup}}
\index{le\+\_\+ref\+\_\+\+Lookup@{le\+\_\+ref\+\_\+\+Lookup}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+ref\+\_\+\+Lookup(le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t map\+Ref, void $\ast$safe\+Ref)}{le_ref_Lookup(le_ref_MapRef_t mapRef, void *safeRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ le\+\_\+ref\+\_\+\+Lookup (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t}}]{map\+Ref, }
\item[{{\bf void} $\ast$}]{safe\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{le__safe_ref_8h_a488dddfd579f4a20f39be392c4d7d2e0}{}\label{le__safe_ref_8h_a488dddfd579f4a20f39be392c4d7d2e0}
Translates a Safe Reference back to the pointer from when the Safe Reference was created.

\begin{DoxyReturn}{Returns}
Pointer that the Safe Reference maps to, or N\+U\+LL if the Safe Reference has been deleted or is invalid.
\end{DoxyReturn}
Translates a Safe Reference back into the pointer that was given when the Safe Reference was created.

\begin{DoxyReturn}{Returns}
The pointer that the Safe Reference maps to, or N\+U\+LL if the Safe Reference has been deleted or is invalid. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & The Reference Map to do the lookup in. \\
\hline
\mbox{\tt in}  & {\em safe\+Ref} & The Safe Reference to be translated into a pointer. \\
\hline
\end{DoxyParams}
\index{le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}!le\+\_\+ref\+\_\+\+Next\+Node@{le\+\_\+ref\+\_\+\+Next\+Node}}
\index{le\+\_\+ref\+\_\+\+Next\+Node@{le\+\_\+ref\+\_\+\+Next\+Node}!le\+\_\+safe\+Ref.\+h@{le\+\_\+safe\+Ref.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+ref\+\_\+\+Next\+Node(le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t iterator\+Ref)}{le_ref_NextNode(le_ref_IterRef_t iteratorRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+ref\+\_\+\+Next\+Node (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+ref\+\_\+\+Iter\+Ref\+\_\+t}}]{iterator\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{le__safe_ref_8h_ac6304fc29d2ce7c82f5ca3b210931783}{}\label{le__safe_ref_8h_ac6304fc29d2ce7c82f5ca3b210931783}
Moves the iterator to the next key/value pair in the map.

\begin{DoxyReturn}{Returns}
Returns L\+E\+\_\+\+OK unless you go past the end of the map, then returns L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND. If the iterator has been invalidated by the map changing or you have previously received a L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND then this returns L\+E\+\_\+\+F\+A\+U\+LT. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iterator\+Ref} & Reference to the iterator. \\
\hline
\end{DoxyParams}
