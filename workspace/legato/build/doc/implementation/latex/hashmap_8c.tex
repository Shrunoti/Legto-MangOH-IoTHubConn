\hypertarget{hashmap_8c}{}\section{framework/liblegato/linux/hashmap.c File Reference}
\label{hashmap_8c}\index{framework/liblegato/linux/hashmap.\+c@{framework/liblegato/linux/hashmap.\+c}}
{\ttfamily \#include \char`\"{}legato.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}hsieh\+\_\+hash.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}limit.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}hashmap.\+h\char`\"{}}\\*
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{hashmap_8c_acec821b2e3eea469f41c390808c78f59}{H\+A\+S\+H\+M\+A\+P\+\_\+\+T\+R\+A\+CE}(map\+Ref, ...)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static size\+\_\+t \hyperlink{hashmap_8c_adbd47824b26347b65083969c01b06a75}{Hash\+Key} (\hyperlink{struct_hashmap__t}{Hashmap\+\_\+t} $\ast$map, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$key)
\item 
static Entry\+\_\+t $\ast$ \hyperlink{hashmap_8c_a937b7dee5eae8ce295a6ed63d686ddf6}{Create\+Entry} (const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$new\+Key\+Ptr, int new\+Hash, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$new\+Value\+Ptr, \hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} pool\+Ref)
\item 
static size\+\_\+t \hyperlink{hashmap_8c_a988a91c4df4f165688de94e5c990e1c7}{Calculate\+Index} (size\+\_\+t bucket\+Count, size\+\_\+t hash)
\item 
static bool \hyperlink{hashmap_8c_a19b20356dad41e586198defe1f8cb78e}{Equal\+Keys} (const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$key\+A\+Ptr, int hashA, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$key\+B\+Ptr, int hashB, \hyperlink{le__hashmap_8h_adfe15673aeaa2400d3147d62abffee40}{le\+\_\+hashmap\+\_\+\+Equals\+Func\+\_\+t} equals\+Func\+Ptr)
\item 
\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} \hyperlink{hashmap_8c_ade79896a5b2ceec82c570fe21f7efe3a}{le\+\_\+hashmap\+\_\+\+Create} (const char $\ast$name\+Str, size\+\_\+t capacity, \hyperlink{le__hashmap_8h_a354b7f0a30dd40266d367351a4b248b7}{le\+\_\+hashmap\+\_\+\+Hash\+Func\+\_\+t} hash\+Func, \hyperlink{le__hashmap_8h_adfe15673aeaa2400d3147d62abffee40}{le\+\_\+hashmap\+\_\+\+Equals\+Func\+\_\+t} equals\+Func)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{hashmap_8c_a68759fb8291c487a507eae6d92710fc7}{le\+\_\+hashmap\+\_\+\+Put} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$key\+Ptr, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$value\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{hashmap_8c_a4322a312a2e4b00112022c2cb04eb416}{le\+\_\+hashmap\+\_\+\+Get} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$key\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{hashmap_8c_a9645e5b363c335e1dd324f536e2b754c}{le\+\_\+hashmap\+\_\+\+Get\+Stored\+Key} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$key\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{hashmap_8c_a64eab4c096da5b66aa54c70ec5d5a776}{le\+\_\+hashmap\+\_\+\+Remove} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$key\+Ptr)
\item 
bool \hyperlink{hashmap_8c_a5530fc9656f5e49f891541900bc21f34}{le\+\_\+hashmap\+\_\+is\+Empty} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref)
\item 
size\+\_\+t \hyperlink{hashmap_8c_a481e3fa6b0fe8319074140a2cb2ae1cc}{le\+\_\+hashmap\+\_\+\+Size} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref)
\item 
bool \hyperlink{hashmap_8c_af42bc33eaed4e6183edfbded3203beb4}{le\+\_\+hashmap\+\_\+\+Contains\+Key} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$key\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{hashmap_8c_a27e3af23871a2f9e8adffb748111aab2}{le\+\_\+hashmap\+\_\+\+Remove\+All} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref)
\item 
bool \hyperlink{hashmap_8c_af142213c63ebac35b0d0e474f0d9c2f3}{le\+\_\+hashmap\+\_\+\+For\+Each} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref, \hyperlink{le__hashmap_8h_acae181524ccab8958e1c8fd5855995b1}{le\+\_\+hashmap\+\_\+\+For\+Each\+Handler\+\_\+t} for\+Each\+Fn, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$context)
\item 
\hyperlink{le__hashmap_8h_a8ab2021261a368add28c1be14f248459}{le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t} \hyperlink{hashmap_8c_a8fb1d3a3d4c4b1b52a45205ac11a12c1}{le\+\_\+hashmap\+\_\+\+Get\+Iterator} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{hashmap_8c_a601b7d3e5d92e91e4090d726e5b190ca}{le\+\_\+hashmap\+\_\+\+Next\+Node} (\hyperlink{le__hashmap_8h_a8ab2021261a368add28c1be14f248459}{le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t} iterator\+Ref)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{hashmap_8c_aad5cdb7a6d36d28699b255814c0d639d}{le\+\_\+hashmap\+\_\+\+Prev\+Node} (\hyperlink{le__hashmap_8h_a8ab2021261a368add28c1be14f248459}{le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t} iterator\+Ref)
\item 
const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{hashmap_8c_aea0e64b3fee37053bba166c8a283f387}{le\+\_\+hashmap\+\_\+\+Get\+Key} (\hyperlink{le__hashmap_8h_a8ab2021261a368add28c1be14f248459}{le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t} iterator\+Ref)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{hashmap_8c_adf4761be6e9bf5a58155296e32c35c4b}{le\+\_\+hashmap\+\_\+\+Get\+Value} (\hyperlink{le__hashmap_8h_a8ab2021261a368add28c1be14f248459}{le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t} iterator\+Ref)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{hashmap_8c_aeec5d4c2a49b8d0304efdfd469a1b2a4}{le\+\_\+hashmap\+\_\+\+Get\+First\+Node} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$$\ast$first\+Key\+Ptr, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$$\ast$first\+Value\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{hashmap_8c_a6a30f4e7da8135ef0274b24a86b7fcb7}{le\+\_\+hashmap\+\_\+\+Get\+Node\+After} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$key\+Ptr, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$$\ast$next\+Key\+Ptr, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$$\ast$next\+Value\+Ptr)
\item 
size\+\_\+t \hyperlink{hashmap_8c_ad31a0f34a74f765998467fa30096e46b}{le\+\_\+hashmap\+\_\+\+Count\+Collisions} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref)
\item 
size\+\_\+t \hyperlink{hashmap_8c_a3ff75de814b38d4c4283379acb406b65}{le\+\_\+hashmap\+\_\+\+Hash\+String} (const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$string\+To\+Hash\+Ptr)
\item 
bool \hyperlink{hashmap_8c_a63d2b6c0689ece50ce979557029b8483}{le\+\_\+hashmap\+\_\+\+Equals\+String} (const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$first\+String\+Ptr, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$second\+String\+Ptr)
\item 
size\+\_\+t \hyperlink{hashmap_8c_a1bcf5d26bec7e15b6ec30fec4701ce03}{le\+\_\+hashmap\+\_\+\+Hash\+U\+Int32} (const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$int\+To\+Hash\+Ptr)
\item 
bool \hyperlink{hashmap_8c_ab3e3edfdbd30d06729486060a75a77c7}{le\+\_\+hashmap\+\_\+\+Equals\+U\+Int32} (const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$first\+Int\+Ptr, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$second\+Int\+Ptr)
\item 
size\+\_\+t \hyperlink{hashmap_8c_a12558f1e0eeb68991ffb8f8ad442ce86}{le\+\_\+hashmap\+\_\+\+Hash\+U\+Int64} (const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$int\+To\+Hash\+Ptr)
\item 
bool \hyperlink{hashmap_8c_a3b7ac9c681fc54fb121d94ee1e6f4c40}{le\+\_\+hashmap\+\_\+\+Equals\+U\+Int64} (const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$first\+Int\+Ptr, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$second\+Int\+Ptr)
\item 
size\+\_\+t \hyperlink{hashmap_8c_a2c9fc51c9f65c44f6c78cdaf101ab0e4}{le\+\_\+hashmap\+\_\+\+Hash\+Void\+Pointer} (const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$void\+To\+Hash\+Ptr)
\item 
bool \hyperlink{hashmap_8c_a8ecdbbdb5cc0773f0f9946e6e4dec89c}{le\+\_\+hashmap\+\_\+\+Equals\+Void\+Pointer} (const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$first\+Void\+Ptr, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$second\+Void\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{hashmap_8c_a853082500b05e57d899606cfc0e34fab}{le\+\_\+hashmap\+\_\+\+Make\+Traceable} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{hashmap_8c_a10b30e794df1c866fe39c40c7949eb29}{le\+\_\+hashmap\+\_\+\+Enable\+Trace} (\hyperlink{le__hashmap_8h_ae81c60860dbdb8c59beaf25985e5605a}{le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} map\+Ref)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Copyright (C) Sierra Wireless Inc.

Parts of this file are Copyright (C) 2007 The Android Open Source Project

Licensed under the Apache License, Version 2.\+0 (the \char`\"{}\+License\char`\"{}); you may not use this file except in compliance with the License. You may obtain a copy of the License at \begin{DoxyVerb} http://www.apache.org/licenses/LICENSE-2.0
\end{DoxyVerb}


Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \char`\"{}\+A\+S I\+S\char`\"{} B\+A\+S\+IS, W\+I\+T\+H\+O\+UT W\+A\+R\+R\+A\+N\+T\+I\+ES OR C\+O\+N\+D\+I\+T\+I\+O\+NS OF A\+NY K\+I\+ND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 

\subsection{Macro Definition Documentation}
\index{hashmap.\+c@{hashmap.\+c}!H\+A\+S\+H\+M\+A\+P\+\_\+\+T\+R\+A\+CE@{H\+A\+S\+H\+M\+A\+P\+\_\+\+T\+R\+A\+CE}}
\index{H\+A\+S\+H\+M\+A\+P\+\_\+\+T\+R\+A\+CE@{H\+A\+S\+H\+M\+A\+P\+\_\+\+T\+R\+A\+CE}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{H\+A\+S\+H\+M\+A\+P\+\_\+\+T\+R\+A\+CE}{HASHMAP_TRACE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define H\+A\+S\+H\+M\+A\+P\+\_\+\+T\+R\+A\+CE(
\begin{DoxyParamCaption}
\item[{}]{map\+Ref, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_acec821b2e3eea469f41c390808c78f59}{}\label{hashmap_8c_acec821b2e3eea469f41c390808c78f59}
{\bfseries Value\+:}
\begin{DoxyCode}
\textcolor{keywordflow}{if} ((mapRef)->traceRef != NULL) \(\backslash\)
    \{ \hyperlink{le__log_8h_a331fb6c78ccddeafc455ad9c64e42008}{\(\backslash\)}
\hyperlink{le__log_8h_a331fb6c78ccddeafc455ad9c64e42008}{        LE\_TRACE}((mapRef)->traceRef, ##\_\_VA\_ARGS\_\_); \(\backslash\)
    \}
\end{DoxyCode}
Trace if tracing is enabled for a given hashmap. 

\subsection{Function Documentation}
\index{hashmap.\+c@{hashmap.\+c}!Calculate\+Index@{Calculate\+Index}}
\index{Calculate\+Index@{Calculate\+Index}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{Calculate\+Index(size\+\_\+t bucket\+Count, size\+\_\+t hash)}{CalculateIndex(size_t bucketCount, size_t hash)}}]{\setlength{\rightskip}{0pt plus 5cm}static size\+\_\+t Calculate\+Index (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{bucket\+Count, }
\item[{size\+\_\+t}]{hash}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{hashmap_8c_a988a91c4df4f165688de94e5c990e1c7}{}\label{hashmap_8c_a988a91c4df4f165688de94e5c990e1c7}
Given a hash and a map size, calculate the index at which to store the entry


\begin{DoxyParams}{Parameters}
{\em bucket\+Count} & The number of buckets in the map \\
\hline
{\em hash} & The hash to use \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns the index to use in the bucket array 
\end{DoxyReturn}
\index{hashmap.\+c@{hashmap.\+c}!Create\+Entry@{Create\+Entry}}
\index{Create\+Entry@{Create\+Entry}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{Create\+Entry(const void $\ast$new\+Key\+Ptr, int new\+Hash, const void $\ast$new\+Value\+Ptr, le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t pool\+Ref)}{CreateEntry(const void *newKeyPtr, int newHash, const void *newValuePtr, le_mem_PoolRef_t poolRef)}}]{\setlength{\rightskip}{0pt plus 5cm}static Entry\+\_\+t$\ast$ Create\+Entry (
\begin{DoxyParamCaption}
\item[{const {\bf void} $\ast$}]{new\+Key\+Ptr, }
\item[{int}]{new\+Hash, }
\item[{const {\bf void} $\ast$}]{new\+Value\+Ptr, }
\item[{{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t}}]{pool\+Ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{hashmap_8c_a937b7dee5eae8ce295a6ed63d686ddf6}{}\label{hashmap_8c_a937b7dee5eae8ce295a6ed63d686ddf6}
Create a new entry to put in the map. Allocates the entry from the pool which was created during construction of the map.


\begin{DoxyParams}{Parameters}
{\em new\+Key\+Ptr} & A pointer to the key \\
\hline
{\em new\+Hash} & The calculated hash \\
\hline
{\em new\+Value\+Ptr} & A pointer to the value \\
\hline
{\em pool\+Ref} & A memory pool reference to use for allocating memory. This pool must have been created as a pool of Entry\+\_\+t. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a pointer to the newly allocated and filled-\/in Entry\+\_\+t 
\end{DoxyReturn}
\index{hashmap.\+c@{hashmap.\+c}!Equal\+Keys@{Equal\+Keys}}
\index{Equal\+Keys@{Equal\+Keys}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{Equal\+Keys(const void $\ast$key\+A\+Ptr, int hash\+A, const void $\ast$key\+B\+Ptr, int hash\+B, le\+\_\+hashmap\+\_\+\+Equals\+Func\+\_\+t equals\+Func\+Ptr)}{EqualKeys(const void *keyAPtr, int hashA, const void *keyBPtr, int hashB, le_hashmap_EqualsFunc_t equalsFuncPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool Equal\+Keys (
\begin{DoxyParamCaption}
\item[{const {\bf void} $\ast$}]{key\+A\+Ptr, }
\item[{int}]{hashA, }
\item[{const {\bf void} $\ast$}]{key\+B\+Ptr, }
\item[{int}]{hashB, }
\item[{{\bf le\+\_\+hashmap\+\_\+\+Equals\+Func\+\_\+t}}]{equals\+Func\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{hashmap_8c_a19b20356dad41e586198defe1f8cb78e}{}\label{hashmap_8c_a19b20356dad41e586198defe1f8cb78e}
Checks if 2 keys are equal (or are actually the same key)


\begin{DoxyParams}{Parameters}
{\em key\+A\+Ptr} & Pointer to the first key \\
\hline
{\em hashA} & The hash of the first key \\
\hline
{\em key\+B\+Ptr} & Pointer to the second key \\
\hline
{\em hashB} & The hash of the second key \\
\hline
{\em equals\+Func\+Ptr} & The equality function in use by the map \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns true if the keys are identical, false otherwise 
\end{DoxyReturn}
\index{hashmap.\+c@{hashmap.\+c}!Hash\+Key@{Hash\+Key}}
\index{Hash\+Key@{Hash\+Key}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{Hash\+Key(\+Hashmap\+\_\+t $\ast$map, const void $\ast$key)}{HashKey(Hashmap_t *map, const void *key)}}]{\setlength{\rightskip}{0pt plus 5cm}static size\+\_\+t Hash\+Key (
\begin{DoxyParamCaption}
\item[{{\bf Hashmap\+\_\+t} $\ast$}]{map, }
\item[{const {\bf void} $\ast$}]{key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{hashmap_8c_adbd47824b26347b65083969c01b06a75}{}\label{hashmap_8c_adbd47824b26347b65083969c01b06a75}
Calculate a hash. First this calls the user-\/supplied hash function. Then it does some defensive coding to avoid bad hashes from outside hash functions


\begin{DoxyParams}{Parameters}
{\em map} & A pointer to the hashmap instance \\
\hline
{\em key} & A pointer to the key to hash \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns a new hash 
\end{DoxyReturn}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Contains\+Key@{le\+\_\+hashmap\+\_\+\+Contains\+Key}}
\index{le\+\_\+hashmap\+\_\+\+Contains\+Key@{le\+\_\+hashmap\+\_\+\+Contains\+Key}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Contains\+Key(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref, const void $\ast$key\+Ptr)}{le_hashmap_ContainsKey(le_hashmap_Ref_t mapRef, const void *keyPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+hashmap\+\_\+\+Contains\+Key (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref, }
\item[{const {\bf void} $\ast$}]{key\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_af42bc33eaed4e6183edfbded3203beb4}{}\label{hashmap_8c_af42bc33eaed4e6183edfbded3203beb4}
Tests if the Hash\+Map contains a particular key

\begin{DoxyReturn}{Returns}
Returns true if the key is found, false otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\mbox{\tt in}  & {\em key\+Ptr} & Pointer to the key to be searched for \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Count\+Collisions@{le\+\_\+hashmap\+\_\+\+Count\+Collisions}}
\index{le\+\_\+hashmap\+\_\+\+Count\+Collisions@{le\+\_\+hashmap\+\_\+\+Count\+Collisions}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Count\+Collisions(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref)}{le_hashmap_CountCollisions(le_hashmap_Ref_t mapRef)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+hashmap\+\_\+\+Count\+Collisions (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_ad31a0f34a74f765998467fa30096e46b}{}\label{hashmap_8c_ad31a0f34a74f765998467fa30096e46b}
Counts the total number of collisions in the map. A collision occurs when more than one entry is stored in the map at the same index.

\begin{DoxyReturn}{Returns}
Returns The sum of the collisions in the map 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Create@{le\+\_\+hashmap\+\_\+\+Create}}
\index{le\+\_\+hashmap\+\_\+\+Create@{le\+\_\+hashmap\+\_\+\+Create}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Create(const char $\ast$name\+Str, size\+\_\+t capacity, le\+\_\+hashmap\+\_\+\+Hash\+Func\+\_\+t hash\+Func, le\+\_\+hashmap\+\_\+\+Equals\+Func\+\_\+t equals\+Func)}{le_hashmap_Create(const char *nameStr, size_t capacity, le_hashmap_HashFunc_t hashFunc, le_hashmap_EqualsFunc_t equalsFunc)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t} le\+\_\+hashmap\+\_\+\+Create (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{name\+Str, }
\item[{size\+\_\+t}]{capacity, }
\item[{{\bf le\+\_\+hashmap\+\_\+\+Hash\+Func\+\_\+t}}]{hash\+Func, }
\item[{{\bf le\+\_\+hashmap\+\_\+\+Equals\+Func\+\_\+t}}]{equals\+Func}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_ade79896a5b2ceec82c570fe21f7efe3a}{}\label{hashmap_8c_ade79896a5b2ceec82c570fe21f7efe3a}
Create a Hash\+Map

\begin{DoxyReturn}{Returns}
Returns a reference to the map.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Terminates the process on failure, so no need to check the return value for errors. 
\end{DoxyNote}
0.\+75 load factor. We have more buckets than expected keys as we want to reduce the chance of collisions. 1-\/1 would assume a perfect hashing function which is rather unlikely. Also, ensure that the capacity is at least 3 which avoids strange issues in the hashing algorithm

The memory pool is required to store entries. We set a default size and expansion size to reduce the number of forced allocations. Initial entries for each hash are actually doubly linked list objects which store where the starting entry is in the pool.
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em name\+Str} & Name of the Hash\+Map \\
\hline
\mbox{\tt in}  & {\em capacity} & Expected capacity of the map \\
\hline
\mbox{\tt in}  & {\em hash\+Func} & The hash function \\
\hline
\mbox{\tt in}  & {\em equals\+Func} & The equality function \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Enable\+Trace@{le\+\_\+hashmap\+\_\+\+Enable\+Trace}}
\index{le\+\_\+hashmap\+\_\+\+Enable\+Trace@{le\+\_\+hashmap\+\_\+\+Enable\+Trace}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Enable\+Trace(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref)}{le_hashmap_EnableTrace(le_hashmap_Ref_t mapRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+hashmap\+\_\+\+Enable\+Trace (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a10b30e794df1c866fe39c40c7949eb29}{}\label{hashmap_8c_a10b30e794df1c866fe39c40c7949eb29}
Immediately enables tracing on a particular hashmap object. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Equals\+String@{le\+\_\+hashmap\+\_\+\+Equals\+String}}
\index{le\+\_\+hashmap\+\_\+\+Equals\+String@{le\+\_\+hashmap\+\_\+\+Equals\+String}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Equals\+String(const void $\ast$first\+String\+Ptr, const void $\ast$second\+String\+Ptr)}{le_hashmap_EqualsString(const void *firstStringPtr, const void *secondStringPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+hashmap\+\_\+\+Equals\+String (
\begin{DoxyParamCaption}
\item[{const {\bf void} $\ast$}]{first\+String\+Ptr, }
\item[{const {\bf void} $\ast$}]{second\+String\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a63d2b6c0689ece50ce979557029b8483}{}\label{hashmap_8c_a63d2b6c0689ece50ce979557029b8483}
String equality function. This can be used as a paramter to le\+\_\+hashmap\+\_\+\+Create if the key to the table is a string

\begin{DoxyReturn}{Returns}
Returns true if the strings are identical, false otherwise 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first\+String\+Ptr} & Pointer to the first string for comparing. \\
\hline
\mbox{\tt in}  & {\em second\+String\+Ptr} & Pointer to the second string for comparing. \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Equals\+U\+Int32@{le\+\_\+hashmap\+\_\+\+Equals\+U\+Int32}}
\index{le\+\_\+hashmap\+\_\+\+Equals\+U\+Int32@{le\+\_\+hashmap\+\_\+\+Equals\+U\+Int32}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Equals\+U\+Int32(const void $\ast$first\+Int\+Ptr, const void $\ast$second\+Int\+Ptr)}{le_hashmap_EqualsUInt32(const void *firstIntPtr, const void *secondIntPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+hashmap\+\_\+\+Equals\+U\+Int32 (
\begin{DoxyParamCaption}
\item[{const {\bf void} $\ast$}]{first\+Int\+Ptr, }
\item[{const {\bf void} $\ast$}]{second\+Int\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_ab3e3edfdbd30d06729486060a75a77c7}{}\label{hashmap_8c_ab3e3edfdbd30d06729486060a75a77c7}
Integer equality function. This can be used as a paramter to le\+\_\+hashmap\+\_\+\+Create if the key to the table is a uint32\+\_\+t

\begin{DoxyReturn}{Returns}
Returns true if the integers are equal, false otherwise 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first\+Int\+Ptr} & Pointer to the first integer for comparing. \\
\hline
\mbox{\tt in}  & {\em second\+Int\+Ptr} & Pointer to the second integer for comparing. \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Equals\+U\+Int64@{le\+\_\+hashmap\+\_\+\+Equals\+U\+Int64}}
\index{le\+\_\+hashmap\+\_\+\+Equals\+U\+Int64@{le\+\_\+hashmap\+\_\+\+Equals\+U\+Int64}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Equals\+U\+Int64(const void $\ast$first\+Int\+Ptr, const void $\ast$second\+Int\+Ptr)}{le_hashmap_EqualsUInt64(const void *firstIntPtr, const void *secondIntPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+hashmap\+\_\+\+Equals\+U\+Int64 (
\begin{DoxyParamCaption}
\item[{const {\bf void} $\ast$}]{first\+Int\+Ptr, }
\item[{const {\bf void} $\ast$}]{second\+Int\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a3b7ac9c681fc54fb121d94ee1e6f4c40}{}\label{hashmap_8c_a3b7ac9c681fc54fb121d94ee1e6f4c40}
Long integer equality function. This can be used as a paramter to le\+\_\+hashmap\+\_\+\+Create if the key to the table is a uint64\+\_\+t

\begin{DoxyReturn}{Returns}
Returns true if the integers are equal, false otherwise 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first\+Int\+Ptr} & Pointer to the first long integer for comparing. \\
\hline
\mbox{\tt in}  & {\em second\+Int\+Ptr} & Pointer to the second long integer for comparing. \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Equals\+Void\+Pointer@{le\+\_\+hashmap\+\_\+\+Equals\+Void\+Pointer}}
\index{le\+\_\+hashmap\+\_\+\+Equals\+Void\+Pointer@{le\+\_\+hashmap\+\_\+\+Equals\+Void\+Pointer}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Equals\+Void\+Pointer(const void $\ast$first\+Void\+Ptr, const void $\ast$second\+Void\+Ptr)}{le_hashmap_EqualsVoidPointer(const void *firstVoidPtr, const void *secondVoidPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+hashmap\+\_\+\+Equals\+Void\+Pointer (
\begin{DoxyParamCaption}
\item[{const {\bf void} $\ast$}]{first\+Void\+Ptr, }
\item[{const {\bf void} $\ast$}]{second\+Void\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a8ecdbbdb5cc0773f0f9946e6e4dec89c}{}\label{hashmap_8c_a8ecdbbdb5cc0773f0f9946e6e4dec89c}
Pointer equality function. This can be used as a parameter to \hyperlink{hashmap_8c_ade79896a5b2ceec82c570fe21f7efe3a}{le\+\_\+hashmap\+\_\+\+Create()} if the key to the table is an pointer or reference.

\begin{DoxyReturn}{Returns}
Returns true if the pointers are equal, false otherwise 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em first\+Void\+Ptr} & First pointer for comparing. \\
\hline
\mbox{\tt in}  & {\em second\+Void\+Ptr} & P\+Second pointer for comparing. \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+For\+Each@{le\+\_\+hashmap\+\_\+\+For\+Each}}
\index{le\+\_\+hashmap\+\_\+\+For\+Each@{le\+\_\+hashmap\+\_\+\+For\+Each}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+For\+Each(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref, le\+\_\+hashmap\+\_\+\+For\+Each\+Handler\+\_\+t for\+Each\+Fn, void $\ast$context)}{le_hashmap_ForEach(le_hashmap_Ref_t mapRef, le_hashmap_ForEachHandler_t forEachFn, void *context)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+hashmap\+\_\+\+For\+Each (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref, }
\item[{{\bf le\+\_\+hashmap\+\_\+\+For\+Each\+Handler\+\_\+t}}]{for\+Each\+Fn, }
\item[{{\bf void} $\ast$}]{context}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_af142213c63ebac35b0d0e474f0d9c2f3}{}\label{hashmap_8c_af142213c63ebac35b0d0e474f0d9c2f3}
Iterates over the whole map, calling the supplied callback with each key-\/value pair. If the callback returns false for any key then this function will return.

\begin{DoxyReturn}{Returns}
Returns true if all elements were checked; or false if iteration was stopped early 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\mbox{\tt in}  & {\em for\+Each\+Fn} & Callback function to be called with each pair \\
\hline
\mbox{\tt in}  & {\em context} & Pointer to a context to be supplied to the callback \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Get@{le\+\_\+hashmap\+\_\+\+Get}}
\index{le\+\_\+hashmap\+\_\+\+Get@{le\+\_\+hashmap\+\_\+\+Get}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Get(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref, const void $\ast$key\+Ptr)}{le_hashmap_Get(le_hashmap_Ref_t mapRef, const void *keyPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ le\+\_\+hashmap\+\_\+\+Get (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref, }
\item[{const {\bf void} $\ast$}]{key\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a4322a312a2e4b00112022c2cb04eb416}{}\label{hashmap_8c_a4322a312a2e4b00112022c2cb04eb416}
Retrieve a value from a Hash\+Map.

\begin{DoxyReturn}{Returns}
Returns a pointer to the value or N\+U\+LL if the key is not found. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\mbox{\tt in}  & {\em key\+Ptr} & Pointer to the key to be retrieved \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Get\+First\+Node@{le\+\_\+hashmap\+\_\+\+Get\+First\+Node}}
\index{le\+\_\+hashmap\+\_\+\+Get\+First\+Node@{le\+\_\+hashmap\+\_\+\+Get\+First\+Node}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Get\+First\+Node(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref, void $\ast$$\ast$first\+Key\+Ptr, void $\ast$$\ast$first\+Value\+Ptr)}{le_hashmap_GetFirstNode(le_hashmap_Ref_t mapRef, void **firstKeyPtr, void **firstValuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+hashmap\+\_\+\+Get\+First\+Node (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref, }
\item[{{\bf void} $\ast$$\ast$}]{first\+Key\+Ptr, }
\item[{{\bf void} $\ast$$\ast$}]{first\+Value\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_aeec5d4c2a49b8d0304efdfd469a1b2a4}{}\label{hashmap_8c_aeec5d4c2a49b8d0304efdfd469a1b2a4}
Retrieves the key and value of the first node stored in the hashmap. The hashmap is not sorted so this will simply return the first node stored in the map. There is no guarantee that a subsequent call to this function will return the same pair if new keys have been added to the map. If N\+U\+LL is passed as the first\+Value\+Pointer then only the key will be returned.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if the first node is returned or L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND if the map is empty. L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER if the key is N\+U\+LL. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\mbox{\tt out}  & {\em first\+Key\+Ptr} & Pointer to the first key \\
\hline
 & {\em first\+Value\+Ptr} & \begin{quote}
\mbox{[}out\mbox{]} Pointer to the first key$>$ \mbox{[}out\mbox{]} Pointer to the first value \end{quote}
\\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Get\+Iterator@{le\+\_\+hashmap\+\_\+\+Get\+Iterator}}
\index{le\+\_\+hashmap\+\_\+\+Get\+Iterator@{le\+\_\+hashmap\+\_\+\+Get\+Iterator}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Get\+Iterator(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref)}{le_hashmap_GetIterator(le_hashmap_Ref_t mapRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t} le\+\_\+hashmap\+\_\+\+Get\+Iterator (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a8fb1d3a3d4c4b1b52a45205ac11a12c1}{}\label{hashmap_8c_a8fb1d3a3d4c4b1b52a45205ac11a12c1}
Gets an interator for step-\/by-\/step iteration over the map. In this mode the iteration is controlled by the calling function using the le\+\_\+hashmap\+\_\+\+Next\+Node function. There is one iterator per map, and calling this function resets the iterator position to the start of the map.

\begin{DoxyReturn}{Returns}
Returns A reference to a hashmap iterator which is ready for le\+\_\+hashmap\+\_\+\+Next\+Node to be called on it 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Get\+Key@{le\+\_\+hashmap\+\_\+\+Get\+Key}}
\index{le\+\_\+hashmap\+\_\+\+Get\+Key@{le\+\_\+hashmap\+\_\+\+Get\+Key}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Get\+Key(le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t iterator\+Ref)}{le_hashmap_GetKey(le_hashmap_It_Ref_t iteratorRef)}}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf void}$\ast$ le\+\_\+hashmap\+\_\+\+Get\+Key (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t}}]{iterator\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_aea0e64b3fee37053bba166c8a283f387}{}\label{hashmap_8c_aea0e64b3fee37053bba166c8a283f387}
Retrieves a pointer to the key which the iterator is currently pointing at

\begin{DoxyReturn}{Returns}
A pointer to the current key, or N\+U\+LL if the iterator has been invalidated 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iterator\+Ref} & Reference to the iterator \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Get\+Node\+After@{le\+\_\+hashmap\+\_\+\+Get\+Node\+After}}
\index{le\+\_\+hashmap\+\_\+\+Get\+Node\+After@{le\+\_\+hashmap\+\_\+\+Get\+Node\+After}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Get\+Node\+After(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref, const void $\ast$key\+Ptr, void $\ast$$\ast$next\+Key\+Ptr, void $\ast$$\ast$next\+Value\+Ptr)}{le_hashmap_GetNodeAfter(le_hashmap_Ref_t mapRef, const void *keyPtr, void **nextKeyPtr, void **nextValuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+hashmap\+\_\+\+Get\+Node\+After (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref, }
\item[{const {\bf void} $\ast$}]{key\+Ptr, }
\item[{{\bf void} $\ast$$\ast$}]{next\+Key\+Ptr, }
\item[{{\bf void} $\ast$$\ast$}]{next\+Value\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a6a30f4e7da8135ef0274b24a86b7fcb7}{}\label{hashmap_8c_a6a30f4e7da8135ef0274b24a86b7fcb7}
Retrieves the key and value of the node after the passed in key. The hashmap is not sorted so this will simply return the next node stored in the map. There is no guarantee that a subsequent call to this function will return the same pair if new keys have been added to the map. If N\+U\+LL is passed as the next\+Value\+Ptr then only the key will be returned.

\begin{DoxyReturn}{Returns}
L\+E\+\_\+\+OK if the next node is returned. If the key\+Ptr is not found in the map then L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER is returned. L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND is returned if the passed in key is the last one in the map. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\mbox{\tt in}  & {\em key\+Ptr} & Pointer to the key to be searched for \\
\hline
\mbox{\tt out}  & {\em next\+Key\+Ptr} & Pointer to the first key \\
\hline
 & {\em next\+Value\+Ptr} & \begin{quote}
\mbox{[}out\mbox{]} Pointer to the first key$>$ \mbox{[}out\mbox{]} Pointer to the first value \end{quote}
\\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Get\+Stored\+Key@{le\+\_\+hashmap\+\_\+\+Get\+Stored\+Key}}
\index{le\+\_\+hashmap\+\_\+\+Get\+Stored\+Key@{le\+\_\+hashmap\+\_\+\+Get\+Stored\+Key}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Get\+Stored\+Key(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref, const void $\ast$key\+Ptr)}{le_hashmap_GetStoredKey(le_hashmap_Ref_t mapRef, const void *keyPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ le\+\_\+hashmap\+\_\+\+Get\+Stored\+Key (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref, }
\item[{const {\bf void} $\ast$}]{key\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a9645e5b363c335e1dd324f536e2b754c}{}\label{hashmap_8c_a9645e5b363c335e1dd324f536e2b754c}
Retrieve a stored key from a Hash\+Map.

\begin{DoxyReturn}{Returns}
Returns a pointer to the key that was stored in the Hash\+Map by \hyperlink{hashmap_8c_a68759fb8291c487a507eae6d92710fc7}{le\+\_\+hashmap\+\_\+\+Put()} or N\+U\+LL if the key is not found. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map. \\
\hline
\mbox{\tt in}  & {\em key\+Ptr} & Pointer to the key to be retrieved. \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Get\+Value@{le\+\_\+hashmap\+\_\+\+Get\+Value}}
\index{le\+\_\+hashmap\+\_\+\+Get\+Value@{le\+\_\+hashmap\+\_\+\+Get\+Value}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Get\+Value(le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t iterator\+Ref)}{le_hashmap_GetValue(le_hashmap_It_Ref_t iteratorRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ le\+\_\+hashmap\+\_\+\+Get\+Value (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t}}]{iterator\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_adf4761be6e9bf5a58155296e32c35c4b}{}\label{hashmap_8c_adf4761be6e9bf5a58155296e32c35c4b}
Retrieves a pointer to the value which the iterator is currently pointing at

\begin{DoxyReturn}{Returns}
A pointer to the current value, or N\+U\+LL if the iterator has been invalidated 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iterator\+Ref} & Reference to the iterator \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Hash\+String@{le\+\_\+hashmap\+\_\+\+Hash\+String}}
\index{le\+\_\+hashmap\+\_\+\+Hash\+String@{le\+\_\+hashmap\+\_\+\+Hash\+String}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Hash\+String(const void $\ast$string\+To\+Hash\+Ptr)}{le_hashmap_HashString(const void *stringToHashPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+hashmap\+\_\+\+Hash\+String (
\begin{DoxyParamCaption}
\item[{const {\bf void} $\ast$}]{string\+To\+Hash\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a3ff75de814b38d4c4283379acb406b65}{}\label{hashmap_8c_a3ff75de814b38d4c4283379acb406b65}
String hashing function. This can be used as a parameter to le\+\_\+hashmap\+\_\+\+Create if the key to the table is a string

\begin{DoxyReturn}{Returns}
Returns the hash value of the string pointed to by string\+To\+Hash 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em string\+To\+Hash\+Ptr} & Pointer to the string to be hashed \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Hash\+U\+Int32@{le\+\_\+hashmap\+\_\+\+Hash\+U\+Int32}}
\index{le\+\_\+hashmap\+\_\+\+Hash\+U\+Int32@{le\+\_\+hashmap\+\_\+\+Hash\+U\+Int32}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Hash\+U\+Int32(const void $\ast$int\+To\+Hash\+Ptr)}{le_hashmap_HashUInt32(const void *intToHashPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+hashmap\+\_\+\+Hash\+U\+Int32 (
\begin{DoxyParamCaption}
\item[{const {\bf void} $\ast$}]{int\+To\+Hash\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a1bcf5d26bec7e15b6ec30fec4701ce03}{}\label{hashmap_8c_a1bcf5d26bec7e15b6ec30fec4701ce03}
Integer hashing function. This can be used as a paramter to le\+\_\+hashmap\+\_\+\+Create if the key to the table is a uint32\+\_\+t

\begin{DoxyReturn}{Returns}
Returns the hash value of the uint32\+\_\+t pointed to by int\+To\+Hash 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em int\+To\+Hash\+Ptr} & Pointer to the integer to be hashed \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Hash\+U\+Int64@{le\+\_\+hashmap\+\_\+\+Hash\+U\+Int64}}
\index{le\+\_\+hashmap\+\_\+\+Hash\+U\+Int64@{le\+\_\+hashmap\+\_\+\+Hash\+U\+Int64}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Hash\+U\+Int64(const void $\ast$int\+To\+Hash\+Ptr)}{le_hashmap_HashUInt64(const void *intToHashPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+hashmap\+\_\+\+Hash\+U\+Int64 (
\begin{DoxyParamCaption}
\item[{const {\bf void} $\ast$}]{int\+To\+Hash\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a12558f1e0eeb68991ffb8f8ad442ce86}{}\label{hashmap_8c_a12558f1e0eeb68991ffb8f8ad442ce86}
Long integer hashing function. This can be used as a paramter to le\+\_\+hashmap\+\_\+\+Create if the key to the table is a uint64\+\_\+t

\begin{DoxyReturn}{Returns}
Returns the hash value of the uint64\+\_\+t pointed to by int\+To\+Hash 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em int\+To\+Hash\+Ptr} & Pointer to the long integer to be hashed \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Hash\+Void\+Pointer@{le\+\_\+hashmap\+\_\+\+Hash\+Void\+Pointer}}
\index{le\+\_\+hashmap\+\_\+\+Hash\+Void\+Pointer@{le\+\_\+hashmap\+\_\+\+Hash\+Void\+Pointer}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Hash\+Void\+Pointer(const void $\ast$void\+To\+Hash\+Ptr)}{le_hashmap_HashVoidPointer(const void *voidToHashPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+hashmap\+\_\+\+Hash\+Void\+Pointer (
\begin{DoxyParamCaption}
\item[{const {\bf void} $\ast$}]{void\+To\+Hash\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a2c9fc51c9f65c44f6c78cdaf101ab0e4}{}\label{hashmap_8c_a2c9fc51c9f65c44f6c78cdaf101ab0e4}
Pointer hashing function. This can be used as a parameter to \hyperlink{hashmap_8c_ade79896a5b2ceec82c570fe21f7efe3a}{le\+\_\+hashmap\+\_\+\+Create()} if the key to the table is an pointer or reference. Simply pass in the address as the key.

\begin{DoxyReturn}{Returns}
Returns the hash value of the pointer pointed to by void\+To\+Hash\+Ptr 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em void\+To\+Hash\+Ptr} & Pointer to be hashed \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+is\+Empty@{le\+\_\+hashmap\+\_\+is\+Empty}}
\index{le\+\_\+hashmap\+\_\+is\+Empty@{le\+\_\+hashmap\+\_\+is\+Empty}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+is\+Empty(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref)}{le_hashmap_isEmpty(le_hashmap_Ref_t mapRef)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+hashmap\+\_\+is\+Empty (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a5530fc9656f5e49f891541900bc21f34}{}\label{hashmap_8c_a5530fc9656f5e49f891541900bc21f34}
Tests if the Hash\+Map is empty (i.\+e. contains zero keys).

\begin{DoxyReturn}{Returns}
Returns true if empty, false otherwise. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Make\+Traceable@{le\+\_\+hashmap\+\_\+\+Make\+Traceable}}
\index{le\+\_\+hashmap\+\_\+\+Make\+Traceable@{le\+\_\+hashmap\+\_\+\+Make\+Traceable}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Make\+Traceable(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref)}{le_hashmap_MakeTraceable(le_hashmap_Ref_t mapRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+hashmap\+\_\+\+Make\+Traceable (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a853082500b05e57d899606cfc0e34fab}{}\label{hashmap_8c_a853082500b05e57d899606cfc0e34fab}
Makes a particular hashmap traceable without enabling the tracing. After this is called, when the trace keyword for this hashmap (the hashmap\textquotesingle{}s name) is enabled for the \char`\"{}framework\char`\"{} component in the process, then tracing will commence. If that keyword was already enabled before this function is called, then tracing will commence immediately when this function is called. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Next\+Node@{le\+\_\+hashmap\+\_\+\+Next\+Node}}
\index{le\+\_\+hashmap\+\_\+\+Next\+Node@{le\+\_\+hashmap\+\_\+\+Next\+Node}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Next\+Node(le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t iterator\+Ref)}{le_hashmap_NextNode(le_hashmap_It_Ref_t iteratorRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+hashmap\+\_\+\+Next\+Node (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t}}]{iterator\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a601b7d3e5d92e91e4090d726e5b190ca}{}\label{hashmap_8c_a601b7d3e5d92e91e4090d726e5b190ca}
Moves the iterator to the next key/value pair in the map. Order is dependent on the hash algorithm and the order of inserts and is not sorted at all.

\begin{DoxyReturn}{Returns}
Returns L\+E\+\_\+\+OK unless you go past the end of the map, then returns L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iterator\+Ref} & Reference to the iterator \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Prev\+Node@{le\+\_\+hashmap\+\_\+\+Prev\+Node}}
\index{le\+\_\+hashmap\+\_\+\+Prev\+Node@{le\+\_\+hashmap\+\_\+\+Prev\+Node}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Prev\+Node(le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t iterator\+Ref)}{le_hashmap_PrevNode(le_hashmap_It_Ref_t iteratorRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+hashmap\+\_\+\+Prev\+Node (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+It\+\_\+\+Ref\+\_\+t}}]{iterator\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_aad5cdb7a6d36d28699b255814c0d639d}{}\label{hashmap_8c_aad5cdb7a6d36d28699b255814c0d639d}
Moves the iterator to the previous key/value pair in the map. Order is dependent on the hash algorithm and the order of inserts, and is not sorted at all.

\begin{DoxyReturn}{Returns}
Returns L\+E\+\_\+\+OK unless you go past the beginning of the map, then returns L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em iterator\+Ref} & Reference to the iterator \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Put@{le\+\_\+hashmap\+\_\+\+Put}}
\index{le\+\_\+hashmap\+\_\+\+Put@{le\+\_\+hashmap\+\_\+\+Put}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Put(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref, const void $\ast$key\+Ptr, const void $\ast$value\+Ptr)}{le_hashmap_Put(le_hashmap_Ref_t mapRef, const void *keyPtr, const void *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ le\+\_\+hashmap\+\_\+\+Put (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref, }
\item[{const {\bf void} $\ast$}]{key\+Ptr, }
\item[{const {\bf void} $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a68759fb8291c487a507eae6d92710fc7}{}\label{hashmap_8c_a68759fb8291c487a507eae6d92710fc7}
Add a key-\/value pair to a Hash\+Map. If the key already exists in the map then the previous value will be replaced with the new value passed into this function.

The process will terminate if this fails as it implies an inability to allocate any more memory 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\mbox{\tt in}  & {\em key\+Ptr} & Pointer to the key to be stored \\
\hline
\mbox{\tt in}  & {\em value\+Ptr} & Pointer to the value to be stored \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Remove@{le\+\_\+hashmap\+\_\+\+Remove}}
\index{le\+\_\+hashmap\+\_\+\+Remove@{le\+\_\+hashmap\+\_\+\+Remove}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Remove(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref, const void $\ast$key\+Ptr)}{le_hashmap_Remove(le_hashmap_Ref_t mapRef, const void *keyPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ le\+\_\+hashmap\+\_\+\+Remove (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref, }
\item[{const {\bf void} $\ast$}]{key\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a64eab4c096da5b66aa54c70ec5d5a776}{}\label{hashmap_8c_a64eab4c096da5b66aa54c70ec5d5a776}
Remove a value from a Hash\+Map.

\begin{DoxyNote}{Note}
If the iterator is currently on the item being removed, then it\textquotesingle{}s value is invalidated. The iterator will have to be moved before values and keys can be read from it again.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}
Returns a pointer to the value or N\+U\+LL if the key is not found. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\mbox{\tt in}  & {\em key\+Ptr} & Pointer to the key to be removed \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Remove\+All@{le\+\_\+hashmap\+\_\+\+Remove\+All}}
\index{le\+\_\+hashmap\+\_\+\+Remove\+All@{le\+\_\+hashmap\+\_\+\+Remove\+All}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Remove\+All(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref)}{le_hashmap_RemoveAll(le_hashmap_Ref_t mapRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+hashmap\+\_\+\+Remove\+All (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a27e3af23871a2f9e8adffb748111aab2}{}\label{hashmap_8c_a27e3af23871a2f9e8adffb748111aab2}
Deletes all the entries held in the hashmap. This will not delete the data pointed to by the key and value pointers. That cleanup is the responsibility of the caller. This allows the map to be re-\/used. Currently maps cannot be deleted. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\end{DoxyParams}
\index{hashmap.\+c@{hashmap.\+c}!le\+\_\+hashmap\+\_\+\+Size@{le\+\_\+hashmap\+\_\+\+Size}}
\index{le\+\_\+hashmap\+\_\+\+Size@{le\+\_\+hashmap\+\_\+\+Size}!hashmap.\+c@{hashmap.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+hashmap\+\_\+\+Size(le\+\_\+hashmap\+\_\+\+Ref\+\_\+t map\+Ref)}{le_hashmap_Size(le_hashmap_Ref_t mapRef)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t le\+\_\+hashmap\+\_\+\+Size (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+hashmap\+\_\+\+Ref\+\_\+t}}]{map\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{hashmap_8c_a481e3fa6b0fe8319074140a2cb2ae1cc}{}\label{hashmap_8c_a481e3fa6b0fe8319074140a2cb2ae1cc}
Calculates the number of keys in the Hash\+Map.

\begin{DoxyReturn}{Returns}
The number of keys in the Hash\+Map. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em map\+Ref} & Reference to the map \\
\hline
\end{DoxyParams}
