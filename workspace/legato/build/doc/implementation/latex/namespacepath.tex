\hypertarget{namespacepath}{}\section{path Namespace Reference}
\label{namespacepath}\index{path@{path}}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structpath_1_1_path__t}{Path\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool \hyperlink{namespacepath_a45b8e7862073af3d077ee44ef0697bf2}{Is\+Absolute} (const std\+::string \&path)
\item 
std\+::string \hyperlink{namespacepath_a9cf33e3fdeb3103bbbffe30632032266}{Unquote} (const std\+::string \&path)
\item 
std\+::string \hyperlink{namespacepath_a8ed674d40392cc3f41b5bd3b8ff97842}{Escape\+Quotes} (const std\+::string \&str)
\item 
std\+::string \hyperlink{namespacepath_ad2d0b1160d5e9b1382d674cbe2ee8769}{Minimize} (const std\+::string \&path)
\item 
std\+::string \hyperlink{namespacepath_a52547f49e692917f3405c65cb881aa1c}{Combine} (const std\+::string \&base, const std\+::string \&add)
\item 
std\+::string \hyperlink{namespacepath_a568976762f738bc3b6a5ec26a8a32c46}{Make\+Absolute} (const std\+::string \&path)
\item 
std\+::string \hyperlink{namespacepath_a5f910aef5c9f2268493a14d3550ed676}{Make\+Relative} (const std\+::string \&path)
\item 
std\+::string \hyperlink{namespacepath_a44ae422465654982d8220d53f5f611f7}{Make\+Canonical} (const std\+::string \&path)
\item 
std\+::string \hyperlink{namespacepath_afe434446f5a4df19ae83bfd2cfea6536}{Get\+Containing\+Dir} (const std\+::string \&path)
\item 
std\+::string \hyperlink{namespacepath_a5c0b138f721ba16a597cb45c02a9a559}{Get\+Last\+Node} (const std\+::string \&path)
\item 
std\+::string \hyperlink{namespacepath_ae840a6e8d250628f9567690984ed7416}{Get\+File\+Name\+Extension} (const std\+::string \&path)
\item 
std\+::string \hyperlink{namespacepath_aca906ba1f9f2375027d833c12b387ccc}{Has\+Suffix} (const std\+::string \&path, const std\+::list$<$ std\+::string $>$ \&suffix\+List)
\item 
bool \hyperlink{namespacepath_a57ca516c90a2707d47936d7a0ee59aa4}{Has\+Suffix} (const std\+::string \&path, const std\+::string \&suffix)
\item 
std\+::string \hyperlink{namespacepath_abd9585efbe211dda9bfb7b2ca7c196cb}{Remove\+Suffix} (const std\+::string \&path, const std\+::string \&suffix)
\item 
bool \hyperlink{namespacepath_a8cb09f913227650d334973aba5acdff6}{Is\+C\+Source} (const std\+::string \&path)
\item 
bool \hyperlink{namespacepath_a63af5f32391efca73b85b247afc4a00b}{Is\+Cxx\+Source} (const std\+::string \&path)
\item 
bool \hyperlink{namespacepath_a3de9fd58df83782751c3eac3b52ea07c}{Is\+Python\+Source} (const std\+::string \&path)
\item 
bool \hyperlink{namespacepath_af792bbbd68709fee340ff783fa8b6128}{Is\+Library} (const std\+::string \&path)
\item 
bool \hyperlink{namespacepath_adb89c60a9f11768047d21ef1af109ca5}{Is\+Shared\+Library} (const std\+::string \&path)
\item 
std\+::string \hyperlink{namespacepath_a2e29f1adb8698fd6aea0fcaedfde511f}{Get\+Lib\+Short\+Name} (const std\+::string \&path)
\item 
std\+::string \hyperlink{namespacepath_a2e949d1e0869f2cdcd63a17497a437b7}{Get\+Current\+Dir} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
std\+::string \hyperlink{namespacepath_a7c0099032ea88228ef3e45c635350751}{Get\+Identifier\+Safe\+Name} (const std\+::string \&name)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{path@{path}!Combine@{Combine}}
\index{Combine@{Combine}!path@{path}}
\subsubsection[{\texorpdfstring{Combine(const std\+::string \&base, const std\+::string \&add)}{Combine(const std::string &base, const std::string &add)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Combine (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{base, }
\item[{const std\+::string \&}]{add}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a52547f49e692917f3405c65cb881aa1c}{}\label{namespacepath_a52547f49e692917f3405c65cb881aa1c}
Concatenate two file system paths together.

\begin{DoxyReturn}{Returns}
The combined path. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em base} & The left-\/hand part of the path. \\
\hline
{\em add} & The right-\/hand part of the path. \\
\hline
\end{DoxyParams}
\index{path@{path}!Escape\+Quotes@{Escape\+Quotes}}
\index{Escape\+Quotes@{Escape\+Quotes}!path@{path}}
\subsubsection[{\texorpdfstring{Escape\+Quotes(const std\+::string \&str)}{EscapeQuotes(const std::string &str)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Escape\+Quotes (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{str}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a8ed674d40392cc3f41b5bd3b8ff97842}{}\label{namespacepath_a8ed674d40392cc3f41b5bd3b8ff97842}
Insert a backslash (\textquotesingle{}\textbackslash{}\textquotesingle{}) character in front of any quotation marks (\textquotesingle{}\char`\"{}\textquotesingle{}) characters.

\begin{DoxyReturn}{Returns}
The new string. 
\end{DoxyReturn}
\index{path@{path}!Get\+Containing\+Dir@{Get\+Containing\+Dir}}
\index{Get\+Containing\+Dir@{Get\+Containing\+Dir}!path@{path}}
\subsubsection[{\texorpdfstring{Get\+Containing\+Dir(const std\+::string \&path)}{GetContainingDir(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Get\+Containing\+Dir (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_afe434446f5a4df19ae83bfd2cfea6536}{}\label{namespacepath_afe434446f5a4df19ae83bfd2cfea6536}
\begin{DoxyReturn}{Returns}
The path of the directory containing this path (\char`\"{}.\char`\"{} if the path contains no slashes).
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classmk_1_1_exception__t}{mk\+::\+Exception\+\_\+t}} & on error. \\
\hline
\end{DoxyExceptions}
\index{path@{path}!Get\+Current\+Dir@{Get\+Current\+Dir}}
\index{Get\+Current\+Dir@{Get\+Current\+Dir}!path@{path}}
\subsubsection[{\texorpdfstring{Get\+Current\+Dir(void)}{GetCurrentDir(void)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Get\+Current\+Dir (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a2e949d1e0869f2cdcd63a17497a437b7}{}\label{namespacepath_a2e949d1e0869f2cdcd63a17497a437b7}
Gets the absolute file system path of the current directory. \index{path@{path}!Get\+File\+Name\+Extension@{Get\+File\+Name\+Extension}}
\index{Get\+File\+Name\+Extension@{Get\+File\+Name\+Extension}!path@{path}}
\subsubsection[{\texorpdfstring{Get\+File\+Name\+Extension(const std\+::string \&path)}{GetFileNameExtension(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Get\+File\+Name\+Extension (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_ae840a6e8d250628f9567690984ed7416}{}\label{namespacepath_ae840a6e8d250628f9567690984ed7416}
\begin{DoxyReturn}{Returns}
The file name extension at the end of the file name (e.\+g., \char`\"{}.\+c\char`\"{}, \char`\"{}.\+so\char`\"{}, etc.), or an empty string (\char`\"{}\char`\"{}) if the path doesn\textquotesingle{}t have a file name extension. 
\end{DoxyReturn}
\index{path@{path}!Get\+Identifier\+Safe\+Name@{Get\+Identifier\+Safe\+Name}}
\index{Get\+Identifier\+Safe\+Name@{Get\+Identifier\+Safe\+Name}!path@{path}}
\subsubsection[{\texorpdfstring{Get\+Identifier\+Safe\+Name(const std\+::string \&name)}{GetIdentifierSafeName(const std::string &name)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Get\+Identifier\+Safe\+Name (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{name}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a7c0099032ea88228ef3e45c635350751}{}\label{namespacepath_a7c0099032ea88228ef3e45c635350751}
Convert a name into one that is safe for use as identifiers in programming language code by replacing all unsafe characters with underscores.

\begin{DoxyReturn}{Returns}
The identifier-\/safe name.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em mk\+::\+Exception} & if all the characters in the original name had to be replaced. \\
\hline
\end{DoxyExceptions}
\index{path@{path}!Get\+Last\+Node@{Get\+Last\+Node}}
\index{Get\+Last\+Node@{Get\+Last\+Node}!path@{path}}
\subsubsection[{\texorpdfstring{Get\+Last\+Node(const std\+::string \&path)}{GetLastNode(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Get\+Last\+Node (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a5c0b138f721ba16a597cb45c02a9a559}{}\label{namespacepath_a5c0b138f721ba16a597cb45c02a9a559}
\begin{DoxyReturn}{Returns}
The last part of a file path (e.\+g., just the name of a file, with no directories or slashes in front of it). 
\end{DoxyReturn}
\index{path@{path}!Get\+Lib\+Short\+Name@{Get\+Lib\+Short\+Name}}
\index{Get\+Lib\+Short\+Name@{Get\+Lib\+Short\+Name}!path@{path}}
\subsubsection[{\texorpdfstring{Get\+Lib\+Short\+Name(const std\+::string \&path)}{GetLibShortName(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Get\+Lib\+Short\+Name (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a2e29f1adb8698fd6aea0fcaedfde511f}{}\label{namespacepath_a2e29f1adb8698fd6aea0fcaedfde511f}
Get the short name for a library by stripping off the directory path, the \char`\"{}lib\char`\"{} file name prefix and the \char`\"{}.\+so\char`\"{} or \char`\"{}.\+a\char`\"{} suffix. E.\+g., \char`\"{}/usr/local/lib/libfoo.\+so\char`\"{}, the short name is \char`\"{}foo\char`\"{}.

\begin{DoxyReturn}{Returns}
The short name.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classmk_1_1_exception__t}{mk\+::\+Exception\+\_\+t}} & on error.\\
\hline
\end{DoxyExceptions}
Get the short name for a library by stripping off the directory path, the \char`\"{}lib\char`\"{} file name prefix and the \char`\"{}.\+so\char`\"{} or \char`\"{}.\+a\char`\"{} suffix. E.\+g., \char`\"{}/usr/local/lib/libfoo.\+so\char`\"{}, the short name is \char`\"{}foo\char`\"{}.

\begin{DoxyReturn}{Returns}
The short name.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em legato\+::\+Exception} & on error. \\
\hline
\end{DoxyExceptions}
\index{path@{path}!Has\+Suffix@{Has\+Suffix}}
\index{Has\+Suffix@{Has\+Suffix}!path@{path}}
\subsubsection[{\texorpdfstring{Has\+Suffix(const std\+::string \&path, const std\+::list$<$ std\+::string $>$ \&suffix\+List)}{HasSuffix(const std::string &path, const std::list< std::string > &suffixList)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Has\+Suffix (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path, }
\item[{const std\+::list$<$ std\+::string $>$ \&}]{suffix\+List}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_aca906ba1f9f2375027d833c12b387ccc}{}\label{namespacepath_aca906ba1f9f2375027d833c12b387ccc}
Checks whether a given path has one of the suffixes in a given list of suffixes.

\begin{DoxyReturn}{Returns}
The suffix found, or an emptry string (\char`\"{}\char`\"{}) if not found.
\end{DoxyReturn}
Checks whether a given path has one of the suffixes in a given list of suffixes.

\begin{DoxyReturn}{Returns}
The suffix found, or an empty string (\char`\"{}\char`\"{}) if not found. 
\end{DoxyReturn}
\index{path@{path}!Has\+Suffix@{Has\+Suffix}}
\index{Has\+Suffix@{Has\+Suffix}!path@{path}}
\subsubsection[{\texorpdfstring{Has\+Suffix(const std\+::string \&path, const std\+::string \&suffix)}{HasSuffix(const std::string &path, const std::string &suffix)}}]{\setlength{\rightskip}{0pt plus 5cm}bool path\+::\+Has\+Suffix (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path, }
\item[{const std\+::string \&}]{suffix}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a57ca516c90a2707d47936d7a0ee59aa4}{}\label{namespacepath_a57ca516c90a2707d47936d7a0ee59aa4}
Checks whether a given path has a given suffix.

\begin{DoxyReturn}{Returns}
true if it has that suffix. 
\end{DoxyReturn}
\index{path@{path}!Is\+Absolute@{Is\+Absolute}}
\index{Is\+Absolute@{Is\+Absolute}!path@{path}}
\subsubsection[{\texorpdfstring{Is\+Absolute(const std\+::string \&path)}{IsAbsolute(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}bool path\+::\+Is\+Absolute (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a45b8e7862073af3d077ee44ef0697bf2}{}\label{namespacepath_a45b8e7862073af3d077ee44ef0697bf2}
\begin{DoxyReturn}{Returns}
true if the path is absolute (starts with a \textquotesingle{}/\textquotesingle{}). 
\end{DoxyReturn}
\index{path@{path}!Is\+C\+Source@{Is\+C\+Source}}
\index{Is\+C\+Source@{Is\+C\+Source}!path@{path}}
\subsubsection[{\texorpdfstring{Is\+C\+Source(const std\+::string \&path)}{IsCSource(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}bool path\+::\+Is\+C\+Source (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a8cb09f913227650d334973aba5acdff6}{}\label{namespacepath_a8cb09f913227650d334973aba5acdff6}
Figures out whether or not a given string is a C source code file path.

\begin{DoxyReturn}{Returns}
true if this is a C source code file path. 
\end{DoxyReturn}
\index{path@{path}!Is\+Cxx\+Source@{Is\+Cxx\+Source}}
\index{Is\+Cxx\+Source@{Is\+Cxx\+Source}!path@{path}}
\subsubsection[{\texorpdfstring{Is\+Cxx\+Source(const std\+::string \&path)}{IsCxxSource(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}bool path\+::\+Is\+Cxx\+Source (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a63af5f32391efca73b85b247afc4a00b}{}\label{namespacepath_a63af5f32391efca73b85b247afc4a00b}
Figures out whether or not a given string is a C++ source code file path.

\begin{DoxyReturn}{Returns}
true if this is a C++ source code file path. 
\end{DoxyReturn}
\index{path@{path}!Is\+Library@{Is\+Library}}
\index{Is\+Library@{Is\+Library}!path@{path}}
\subsubsection[{\texorpdfstring{Is\+Library(const std\+::string \&path)}{IsLibrary(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}bool path\+::\+Is\+Library (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_af792bbbd68709fee340ff783fa8b6128}{}\label{namespacepath_af792bbbd68709fee340ff783fa8b6128}
Figures out whether or not a given string is a library file path.

\begin{DoxyReturn}{Returns}
true if this is a library file path. 
\end{DoxyReturn}
\index{path@{path}!Is\+Python\+Source@{Is\+Python\+Source}}
\index{Is\+Python\+Source@{Is\+Python\+Source}!path@{path}}
\subsubsection[{\texorpdfstring{Is\+Python\+Source(const std\+::string \&path)}{IsPythonSource(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}bool path\+::\+Is\+Python\+Source (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a3de9fd58df83782751c3eac3b52ea07c}{}\label{namespacepath_a3de9fd58df83782751c3eac3b52ea07c}
Figures out whether or not a given string is a Python source code file path.

\begin{DoxyReturn}{Returns}
true if this is a Python source code file path. 
\end{DoxyReturn}
\index{path@{path}!Is\+Shared\+Library@{Is\+Shared\+Library}}
\index{Is\+Shared\+Library@{Is\+Shared\+Library}!path@{path}}
\subsubsection[{\texorpdfstring{Is\+Shared\+Library(const std\+::string \&path)}{IsSharedLibrary(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}bool path\+::\+Is\+Shared\+Library (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_adb89c60a9f11768047d21ef1af109ca5}{}\label{namespacepath_adb89c60a9f11768047d21ef1af109ca5}
Figures out whether or not a given string is a shared library file path.

\begin{DoxyReturn}{Returns}
true if this is a shared library file path. 
\end{DoxyReturn}
\index{path@{path}!Make\+Absolute@{Make\+Absolute}}
\index{Make\+Absolute@{Make\+Absolute}!path@{path}}
\subsubsection[{\texorpdfstring{Make\+Absolute(const std\+::string \&path)}{MakeAbsolute(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Make\+Absolute (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a568976762f738bc3b6a5ec26a8a32c46}{}\label{namespacepath_a568976762f738bc3b6a5ec26a8a32c46}
Make a file system path into an absolute path.

\begin{DoxyReturn}{Returns}
The absolute path. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em path} & The original path, which could be absolute or relative. \\
\hline
\end{DoxyParams}
\index{path@{path}!Make\+Canonical@{Make\+Canonical}}
\index{Make\+Canonical@{Make\+Canonical}!path@{path}}
\subsubsection[{\texorpdfstring{Make\+Canonical(const std\+::string \&path)}{MakeCanonical(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Make\+Canonical (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a44ae422465654982d8220d53f5f611f7}{}\label{namespacepath_a44ae422465654982d8220d53f5f611f7}
Clean all the \textquotesingle{}/./\textquotesingle{}, \textquotesingle{}//\textquotesingle{}, and \textquotesingle{}/../\textquotesingle{} nodes out of a path, follow symlinks, and makes the path absolute.

\begin{DoxyReturn}{Returns}
The canonical path.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classmk_1_1_exception__t}{mk\+::\+Exception\+\_\+t}} & on error.\\
\hline
\end{DoxyExceptions}
Clean all the \textquotesingle{}/./\textquotesingle{}, \textquotesingle{}//\textquotesingle{}, and \textquotesingle{}/../\textquotesingle{} nodes out of a path, follow symlinks, and make the path absolute.

\begin{DoxyReturn}{Returns}
The canonical path.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em legato\+::\+Exception} & on error. \\
\hline
\end{DoxyExceptions}
\index{path@{path}!Make\+Relative@{Make\+Relative}}
\index{Make\+Relative@{Make\+Relative}!path@{path}}
\subsubsection[{\texorpdfstring{Make\+Relative(const std\+::string \&path)}{MakeRelative(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Make\+Relative (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a5f910aef5c9f2268493a14d3550ed676}{}\label{namespacepath_a5f910aef5c9f2268493a14d3550ed676}
Make a file system path into a relative path by stripping off leading separators.

\begin{DoxyReturn}{Returns}
The relative path. 
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em path} & The original path, which could be absolute or relative. \\
\hline
\end{DoxyParams}
\index{path@{path}!Minimize@{Minimize}}
\index{Minimize@{Minimize}!path@{path}}
\subsubsection[{\texorpdfstring{Minimize(const std\+::string \&path)}{Minimize(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Minimize (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_ad2d0b1160d5e9b1382d674cbe2ee8769}{}\label{namespacepath_ad2d0b1160d5e9b1382d674cbe2ee8769}
Reduces a path to its minimum length by cleaning out any instances of \char`\"{}./\char`\"{} and \char`\"{}//\char`\"{} and any non-\/leading instances of \char`\"{}../\char`\"{}.

\begin{DoxyReturn}{Returns}
The cleaned path.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classmk_1_1_exception__t}{mk\+::\+Exception\+\_\+t}} & if the path is invalid. \\
\hline
\end{DoxyExceptions}
$<$ We haven\textquotesingle{}t processed any characters yet.

$<$ The last character we saw was a slash.

$<$ Since start of path node we have seen one \textquotesingle{}.\textquotesingle{}.

$<$ Since start of path node we have seen \char`\"{}..\char`\"{}.

$<$ Since start of path node we have seen a node name other than \char`\"{}.\char`\"{} or \char`\"{}..\char`\"{} \index{path@{path}!Remove\+Suffix@{Remove\+Suffix}}
\index{Remove\+Suffix@{Remove\+Suffix}!path@{path}}
\subsubsection[{\texorpdfstring{Remove\+Suffix(const std\+::string \&path, const std\+::string \&suffix)}{RemoveSuffix(const std::string &path, const std::string &suffix)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Remove\+Suffix (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path, }
\item[{const std\+::string \&}]{suffix}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_abd9585efbe211dda9bfb7b2ca7c196cb}{}\label{namespacepath_abd9585efbe211dda9bfb7b2ca7c196cb}
Remove a given suffix from the end of a file path.

\begin{DoxyReturn}{Returns}
The path, with the suffix removed.
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em \hyperlink{classmk_1_1_exception__t}{mk\+::\+Exception\+\_\+t}} & if the path doesn\textquotesingle{}t have the given suffix. \\
\hline
\end{DoxyExceptions}
\index{path@{path}!Unquote@{Unquote}}
\index{Unquote@{Unquote}!path@{path}}
\subsubsection[{\texorpdfstring{Unquote(const std\+::string \&path)}{Unquote(const std::string &path)}}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string path\+::\+Unquote (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{path}
\end{DoxyParamCaption}
)}\hypertarget{namespacepath_a9cf33e3fdeb3103bbbffe30632032266}{}\label{namespacepath_a9cf33e3fdeb3103bbbffe30632032266}
Removes matching outer quotation marks (\textquotesingle{} or ") from a path, if it has any.

\begin{DoxyReturn}{Returns}
The path without the quotes.
\end{DoxyReturn}
Removes matching outer quotation marks (\textquotesingle{} or ") from a path.

\begin{DoxyReturn}{Returns}
The path without the quotes. 
\end{DoxyReturn}
