\hypertarget{fs_8c}{}\section{framework/liblegato/linux/fs.c File Reference}
\label{fs_8c}\index{framework/liblegato/linux/fs.\+c@{framework/liblegato/linux/fs.\+c}}
{\ttfamily \#include \char`\"{}legato.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}file.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}dir.\+h\char`\"{}}\\*
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct_file__t}{File\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{fs_8c_afc7dc7fbfba22a2ecb654e541eee59b2}{F\+S\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+D\+A\+T\+A\+\_\+\+P\+A\+TH}~\char`\"{}/data/le\+\_\+fs/\char`\"{}
\item 
\#define \hyperlink{fs_8c_a238a0cd8898ca5c33d9f4a907fbe6a38}{F\+S\+\_\+\+M\+A\+X\+\_\+\+F\+I\+L\+E\+\_\+\+R\+EF}~32
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static char $\ast$ \hyperlink{fs_8c_a54c49f79a22bf6ae4f666d254aac0b3d}{Build\+Path\+Name} (char $\ast$path\+Ptr, size\+\_\+t path\+Size, const char $\ast$file\+Path\+Ptr)
\item 
static \hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{fs_8c_a3375858a4005a0b267396184a5571734}{Mk\+Dir\+Tree} (const char $\ast$file\+Path\+Ptr)
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{fs_8c_afe536d1201452c1191473adc3b590e5d}{Fs\+File\+Ref\+Destructor} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$obj\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{fs_8c_ac57bb687cc228f180f2713b639c13d99}{le\+\_\+fs\+\_\+\+Open} (const char $\ast$file\+Path\+Ptr, \hyperlink{le__fs_8h_a7d03254febfa1144c5f979e9c82e9780}{le\+\_\+fs\+\_\+\+Access\+Mode\+\_\+t} access\+Mode, \hyperlink{le__fs_8h_a5d6a6ea918795062df6645f9ae8ebfe0}{le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t} $\ast$file\+Ref\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{fs_8c_a2ecd0f3b1867abd51eca0f98f8cc932b}{le\+\_\+fs\+\_\+\+Close} (\hyperlink{le__fs_8h_a5d6a6ea918795062df6645f9ae8ebfe0}{le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t} file\+Ref)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{fs_8c_a155feeb2adcc8ca2caf7becf401030c8}{le\+\_\+fs\+\_\+\+Read} (\hyperlink{le__fs_8h_a5d6a6ea918795062df6645f9ae8ebfe0}{le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t} file\+Ref, uint8\+\_\+t $\ast$buf\+Ptr, size\+\_\+t $\ast$buf\+Num\+Elements\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{fs_8c_afb8428bae9f5335591bef6d723d908f9}{le\+\_\+fs\+\_\+\+Write} (\hyperlink{le__fs_8h_a5d6a6ea918795062df6645f9ae8ebfe0}{le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t} file\+Ref, const uint8\+\_\+t $\ast$buf\+Ptr, size\+\_\+t buf\+Num\+Elements)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{fs_8c_a17a5a2b58cb9dfb75a105048429e785e}{le\+\_\+fs\+\_\+\+Seek} (\hyperlink{le__fs_8h_a5d6a6ea918795062df6645f9ae8ebfe0}{le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t} file\+Ref, int32\+\_\+t offset, \hyperlink{le__fs_8h_a457edff9b23ffd119c2ef0efe2917e91}{le\+\_\+fs\+\_\+\+Position\+\_\+t} position, int32\+\_\+t $\ast$current\+Offset\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{fs_8c_a4a664f85a44586c327cc411e9f831c5d}{le\+\_\+fs\+\_\+\+Get\+Size} (const char $\ast$file\+Path\+Ptr, size\+\_\+t $\ast$size\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{fs_8c_a4dd1bcd025a56d420156c2f84b8aa993}{le\+\_\+fs\+\_\+\+Delete} (const char $\ast$file\+Path\+Ptr)
\item 
bool \hyperlink{fs_8c_a6438d7f80b8a5bce559db559a43f1ca4}{le\+\_\+fs\+\_\+\+Exists} (const char $\ast$file\+Path\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{fs_8c_ad9e475b3da2b07d158c8696890828eba}{le\+\_\+fs\+\_\+\+Remove\+Dir\+Recursive} (const char $\ast$dir\+Path\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{fs_8c_a301ce9a6e66efe5caeacd450d29b9ec0}{le\+\_\+fs\+\_\+\+Move} (const char $\ast$src\+Path\+Ptr, const char $\ast$dest\+Path\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{fs_8c_a4c0bf118144a4e0a26f63b5355558954}{fs\+\_\+\+Init} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static char $\ast$ \hyperlink{fs_8c_a72461ad37f672e082cc406cb6c70269e}{Fs\+Prefix\+Ptr} = N\+U\+LL
\item 
static \hyperlink{le__mem_8h_a44a896f6a0a1a8c733e8038eb332989e}{le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} \hyperlink{fs_8c_a3001c1c1b5732c6cda339cc461ced20a}{Fs\+File\+Ref\+Pool}
\item 
static \hyperlink{le__safe_ref_8h_aaf8fb3412fb840cb50366856affaf69b}{le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} \hyperlink{fs_8c_a8a826d68fe9af29f5ad572b61caac987}{Fs\+File\+Ref\+Map}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This file contains the data structures and the source code of the File System (FS) service.





Copyright (C) Sierra Wireless Inc. 

\subsection{Macro Definition Documentation}
\index{fs.\+c@{fs.\+c}!F\+S\+\_\+\+M\+A\+X\+\_\+\+F\+I\+L\+E\+\_\+\+R\+EF@{F\+S\+\_\+\+M\+A\+X\+\_\+\+F\+I\+L\+E\+\_\+\+R\+EF}}
\index{F\+S\+\_\+\+M\+A\+X\+\_\+\+F\+I\+L\+E\+\_\+\+R\+EF@{F\+S\+\_\+\+M\+A\+X\+\_\+\+F\+I\+L\+E\+\_\+\+R\+EF}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{F\+S\+\_\+\+M\+A\+X\+\_\+\+F\+I\+L\+E\+\_\+\+R\+EF}{FS_MAX_FILE_REF}}]{\setlength{\rightskip}{0pt plus 5cm}\#define F\+S\+\_\+\+M\+A\+X\+\_\+\+F\+I\+L\+E\+\_\+\+R\+EF~32}\hypertarget{fs_8c_a238a0cd8898ca5c33d9f4a907fbe6a38}{}\label{fs_8c_a238a0cd8898ca5c33d9f4a907fbe6a38}
Maximum number of file\+Ref managed by the service \index{fs.\+c@{fs.\+c}!F\+S\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+D\+A\+T\+A\+\_\+\+P\+A\+TH@{F\+S\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+D\+A\+T\+A\+\_\+\+P\+A\+TH}}
\index{F\+S\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+D\+A\+T\+A\+\_\+\+P\+A\+TH@{F\+S\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+D\+A\+T\+A\+\_\+\+P\+A\+TH}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{F\+S\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+D\+A\+T\+A\+\_\+\+P\+A\+TH}{FS_PREFIX_DATA_PATH}}]{\setlength{\rightskip}{0pt plus 5cm}\#define F\+S\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+D\+A\+T\+A\+\_\+\+P\+A\+TH~\char`\"{}/data/le\+\_\+fs/\char`\"{}}\hypertarget{fs_8c_afc7dc7fbfba22a2ecb654e541eee59b2}{}\label{fs_8c_afc7dc7fbfba22a2ecb654e541eee59b2}
Default prefix path for RW if nothing is defined in the config tree 

\subsection{Function Documentation}
\index{fs.\+c@{fs.\+c}!Build\+Path\+Name@{Build\+Path\+Name}}
\index{Build\+Path\+Name@{Build\+Path\+Name}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{Build\+Path\+Name(char $\ast$path\+Ptr, size\+\_\+t path\+Size, const char $\ast$file\+Path\+Ptr)}{BuildPathName(char *pathPtr, size_t pathSize, const char *filePathPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static char$\ast$ Build\+Path\+Name (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{path\+Ptr, }
\item[{size\+\_\+t}]{path\+Size, }
\item[{const char $\ast$}]{file\+Path\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{fs_8c_a54c49f79a22bf6ae4f666d254aac0b3d}{}\label{fs_8c_a54c49f79a22bf6ae4f666d254aac0b3d}
This function adds the prefix to the file\+Path to access

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item N\+U\+LL if the prefix is not set
\item Otherwise a pointer on the full path string related to the le\+\_\+fs directory 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em path\+Ptr} & Full file path with prefix \\
\hline
\mbox{\tt in}  & {\em path\+Size} & Length of the full path array \\
\hline
\mbox{\tt in}  & {\em file\+Path\+Ptr} & File path \\
\hline
\end{DoxyParams}
\index{fs.\+c@{fs.\+c}!fs\+\_\+\+Init@{fs\+\_\+\+Init}}
\index{fs\+\_\+\+Init@{fs\+\_\+\+Init}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{fs\+\_\+\+Init(void)}{fs_Init(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} fs\+\_\+\+Init (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{fs_8c_a4c0bf118144a4e0a26f63b5355558954}{}\label{fs_8c_a4c0bf118144a4e0a26f63b5355558954}
Initialize this component \index{fs.\+c@{fs.\+c}!Fs\+File\+Ref\+Destructor@{Fs\+File\+Ref\+Destructor}}
\index{Fs\+File\+Ref\+Destructor@{Fs\+File\+Ref\+Destructor}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{Fs\+File\+Ref\+Destructor(void $\ast$obj\+Ptr)}{FsFileRefDestructor(void *objPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Fs\+File\+Ref\+Destructor (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$}]{obj\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{fs_8c_afe536d1201452c1191473adc3b590e5d}{}\label{fs_8c_afe536d1201452c1191473adc3b590e5d}
Destructor function that runs when a file ref is deallocated \index{fs.\+c@{fs.\+c}!le\+\_\+fs\+\_\+\+Close@{le\+\_\+fs\+\_\+\+Close}}
\index{le\+\_\+fs\+\_\+\+Close@{le\+\_\+fs\+\_\+\+Close}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+fs\+\_\+\+Close(le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t file\+Ref)}{le_fs_Close(le_fs_FileRef_t fileRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+fs\+\_\+\+Close (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t}}]{file\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{fs_8c_a2ecd0f3b1867abd51eca0f98f8cc932b}{}\label{fs_8c_a2ecd0f3b1867abd51eca0f98f8cc932b}
This function is called to close an opened file.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK The function succeeded.
\item L\+E\+\_\+\+F\+A\+U\+LT The function failed. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Ref} & File reference \\
\hline
\end{DoxyParams}
\index{fs.\+c@{fs.\+c}!le\+\_\+fs\+\_\+\+Delete@{le\+\_\+fs\+\_\+\+Delete}}
\index{le\+\_\+fs\+\_\+\+Delete@{le\+\_\+fs\+\_\+\+Delete}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+fs\+\_\+\+Delete(const char $\ast$file\+Path\+Ptr)}{le_fs_Delete(const char *filePathPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+fs\+\_\+\+Delete (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{file\+Path\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{fs_8c_a4dd1bcd025a56d420156c2f84b8aa993}{}\label{fs_8c_a4dd1bcd025a56d420156c2f84b8aa993}
This function is called to delete a file.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK The function succeeded.
\item L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER A parameter is invalid.
\item L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW The file path is too long.
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND The file does not exist or a directory in the path does not exist
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+P\+E\+R\+M\+I\+T\+T\+ED The access right fails to delete the file or access is not granted to a a directory in the path
\item L\+E\+\_\+\+U\+N\+S\+U\+P\+P\+O\+R\+T\+ED The prefix cannot be added and the function is unusable
\item L\+E\+\_\+\+F\+A\+U\+LT The function failed. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path\+Ptr} & File path \\
\hline
\end{DoxyParams}
\index{fs.\+c@{fs.\+c}!le\+\_\+fs\+\_\+\+Exists@{le\+\_\+fs\+\_\+\+Exists}}
\index{le\+\_\+fs\+\_\+\+Exists@{le\+\_\+fs\+\_\+\+Exists}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+fs\+\_\+\+Exists(const char $\ast$file\+Path\+Ptr)}{le_fs_Exists(const char *filePathPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}bool le\+\_\+fs\+\_\+\+Exists (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{file\+Path\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{fs_8c_a6438d7f80b8a5bce559db559a43f1ca4}{}\label{fs_8c_a6438d7f80b8a5bce559db559a43f1ca4}
This function checks whether a regular file exists at the provided path under file system service storage.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item true If file exists and it is a regular file.
\item false Otherwise. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path\+Ptr} & File path \\
\hline
\end{DoxyParams}
\index{fs.\+c@{fs.\+c}!le\+\_\+fs\+\_\+\+Get\+Size@{le\+\_\+fs\+\_\+\+Get\+Size}}
\index{le\+\_\+fs\+\_\+\+Get\+Size@{le\+\_\+fs\+\_\+\+Get\+Size}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+fs\+\_\+\+Get\+Size(const char $\ast$file\+Path\+Ptr, size\+\_\+t $\ast$size\+Ptr)}{le_fs_GetSize(const char *filePathPtr, size_t *sizePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+fs\+\_\+\+Get\+Size (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{file\+Path\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{fs_8c_a4a664f85a44586c327cc411e9f831c5d}{}\label{fs_8c_a4a664f85a44586c327cc411e9f831c5d}
This function is called to get the size of a file.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK The function succeeded.
\item L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER A parameter is invalid.
\item L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW The file path is too long.
\item L\+E\+\_\+\+U\+N\+S\+U\+P\+P\+O\+R\+T\+ED The prefix cannot be added and the function is unusable
\item L\+E\+\_\+\+F\+A\+U\+LT The function failed. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path\+Ptr} & File path \\
\hline
\mbox{\tt out}  & {\em size\+Ptr} & File size (if successful) \\
\hline
\end{DoxyParams}
\index{fs.\+c@{fs.\+c}!le\+\_\+fs\+\_\+\+Move@{le\+\_\+fs\+\_\+\+Move}}
\index{le\+\_\+fs\+\_\+\+Move@{le\+\_\+fs\+\_\+\+Move}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+fs\+\_\+\+Move(const char $\ast$src\+Path\+Ptr, const char $\ast$dest\+Path\+Ptr)}{le_fs_Move(const char *srcPathPtr, const char *destPathPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+fs\+\_\+\+Move (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{src\+Path\+Ptr, }
\item[{const char $\ast$}]{dest\+Path\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{fs_8c_a301ce9a6e66efe5caeacd450d29b9ec0}{}\label{fs_8c_a301ce9a6e66efe5caeacd450d29b9ec0}
This function is called to rename an existing file. If rename fails, the file will keep its original name.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK The function succeeded.
\item L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER A parameter is invalid.
\item L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW A file path is too long.
\item L\+E\+\_\+\+F\+A\+U\+LT The function failed. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em src\+Path\+Ptr} & Path to file to rename \\
\hline
\mbox{\tt in}  & {\em dest\+Path\+Ptr} & New path to file \\
\hline
\end{DoxyParams}
\index{fs.\+c@{fs.\+c}!le\+\_\+fs\+\_\+\+Open@{le\+\_\+fs\+\_\+\+Open}}
\index{le\+\_\+fs\+\_\+\+Open@{le\+\_\+fs\+\_\+\+Open}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+fs\+\_\+\+Open(const char $\ast$file\+Path\+Ptr, le\+\_\+fs\+\_\+\+Access\+Mode\+\_\+t access\+Mode, le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t $\ast$file\+Ref\+Ptr)}{le_fs_Open(const char *filePathPtr, le_fs_AccessMode_t accessMode, le_fs_FileRef_t *fileRefPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+fs\+\_\+\+Open (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{file\+Path\+Ptr, }
\item[{{\bf le\+\_\+fs\+\_\+\+Access\+Mode\+\_\+t}}]{access\+Mode, }
\item[{{\bf le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t} $\ast$}]{file\+Ref\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{fs_8c_ac57bb687cc228f180f2713b639c13d99}{}\label{fs_8c_ac57bb687cc228f180f2713b639c13d99}
This function is called to create or open an existing file.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK The function succeeded.
\item L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER A parameter is invalid.
\item L\+E\+\_\+\+O\+V\+E\+R\+F\+L\+OW The file path is too long.
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND The file does not exists or a directory in the path does not exist
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+P\+E\+R\+M\+I\+T\+T\+ED Access denied to the file or to a directory in the path
\item L\+E\+\_\+\+U\+N\+S\+U\+P\+P\+O\+R\+T\+ED The prefix cannot be added and the function is unusable
\item L\+E\+\_\+\+F\+A\+U\+LT The function failed. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path\+Ptr} & File path \\
\hline
\mbox{\tt in}  & {\em access\+Mode} & Access mode for the file \\
\hline
\mbox{\tt out}  & {\em file\+Ref\+Ptr} & File reference (if successful) \\
\hline
\end{DoxyParams}
\index{fs.\+c@{fs.\+c}!le\+\_\+fs\+\_\+\+Read@{le\+\_\+fs\+\_\+\+Read}}
\index{le\+\_\+fs\+\_\+\+Read@{le\+\_\+fs\+\_\+\+Read}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+fs\+\_\+\+Read(le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t file\+Ref, uint8\+\_\+t $\ast$buf\+Ptr, size\+\_\+t $\ast$buf\+Num\+Elements\+Ptr)}{le_fs_Read(le_fs_FileRef_t fileRef, uint8_t *bufPtr, size_t *bufNumElementsPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+fs\+\_\+\+Read (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t}}]{file\+Ref, }
\item[{uint8\+\_\+t $\ast$}]{buf\+Ptr, }
\item[{size\+\_\+t $\ast$}]{buf\+Num\+Elements\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{fs_8c_a155feeb2adcc8ca2caf7becf401030c8}{}\label{fs_8c_a155feeb2adcc8ca2caf7becf401030c8}
This function is called to read the requested data length from an opened file. The data is read at the current file position.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK The function succeeded.
\item L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER A parameter is invalid.
\item L\+E\+\_\+\+F\+A\+U\+LT The function failed. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Ref} & File reference \\
\hline
\mbox{\tt out}  & {\em buf\+Ptr} & Buffer to store the data read in the file \\
\hline
\mbox{\tt in}  & {\em buf\+Num\+Elements\+Ptr} & Number of bytes to read when this function is called \mbox{[}O\+UT\mbox{]} Number of bytes read when this function returns \\
\hline
\end{DoxyParams}
\index{fs.\+c@{fs.\+c}!le\+\_\+fs\+\_\+\+Remove\+Dir\+Recursive@{le\+\_\+fs\+\_\+\+Remove\+Dir\+Recursive}}
\index{le\+\_\+fs\+\_\+\+Remove\+Dir\+Recursive@{le\+\_\+fs\+\_\+\+Remove\+Dir\+Recursive}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+fs\+\_\+\+Remove\+Dir\+Recursive(const char $\ast$dir\+Path\+Ptr)}{le_fs_RemoveDirRecursive(const char *dirPathPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+fs\+\_\+\+Remove\+Dir\+Recursive (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{dir\+Path\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{fs_8c_ad9e475b3da2b07d158c8696890828eba}{}\label{fs_8c_ad9e475b3da2b07d158c8696890828eba}
Removes a directory located at storage managed by file system service by first recursively removing sub-\/directories, files, symlinks, hardlinks, devices, etc. Symlinks are not followed, only the links themselves are deleted.

A file or device may not be able to be removed if it is busy, in which case an error message is logged and L\+E\+\_\+\+F\+A\+U\+LT is returned.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK The function succeeded.
\item L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER A parameter is invalid.
\item L\+E\+\_\+\+U\+N\+S\+U\+P\+P\+O\+R\+T\+ED The prefix cannot be added and the function is unusable
\item L\+E\+\_\+\+F\+A\+U\+LT There is an error. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em dir\+Path\+Ptr} & Directory path \\
\hline
\end{DoxyParams}
\index{fs.\+c@{fs.\+c}!le\+\_\+fs\+\_\+\+Seek@{le\+\_\+fs\+\_\+\+Seek}}
\index{le\+\_\+fs\+\_\+\+Seek@{le\+\_\+fs\+\_\+\+Seek}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+fs\+\_\+\+Seek(le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t file\+Ref, int32\+\_\+t offset, le\+\_\+fs\+\_\+\+Position\+\_\+t position, int32\+\_\+t $\ast$current\+Offset\+Ptr)}{le_fs_Seek(le_fs_FileRef_t fileRef, int32_t offset, le_fs_Position_t position, int32_t *currentOffsetPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+fs\+\_\+\+Seek (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t}}]{file\+Ref, }
\item[{int32\+\_\+t}]{offset, }
\item[{{\bf le\+\_\+fs\+\_\+\+Position\+\_\+t}}]{position, }
\item[{int32\+\_\+t $\ast$}]{current\+Offset\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{fs_8c_a17a5a2b58cb9dfb75a105048429e785e}{}\label{fs_8c_a17a5a2b58cb9dfb75a105048429e785e}
This function is called to change the file position of an opened file.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK The function succeeded.
\item L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER A parameter is invalid.
\item L\+E\+\_\+\+F\+A\+U\+LT The function failed. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Ref} & File reference \\
\hline
\mbox{\tt in}  & {\em offset} & Offset to apply when this function is called \\
\hline
\mbox{\tt in}  & {\em position} & Offset is relative to this position \\
\hline
\mbox{\tt out}  & {\em current\+Offset\+Ptr} & Offset from the beginning after the seek operation \\
\hline
\end{DoxyParams}
\index{fs.\+c@{fs.\+c}!le\+\_\+fs\+\_\+\+Write@{le\+\_\+fs\+\_\+\+Write}}
\index{le\+\_\+fs\+\_\+\+Write@{le\+\_\+fs\+\_\+\+Write}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{le\+\_\+fs\+\_\+\+Write(le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t file\+Ref, const uint8\+\_\+t $\ast$buf\+Ptr, size\+\_\+t buf\+Num\+Elements)}{le_fs_Write(le_fs_FileRef_t fileRef, const uint8_t *bufPtr, size_t bufNumElements)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+fs\+\_\+\+Write (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+fs\+\_\+\+File\+Ref\+\_\+t}}]{file\+Ref, }
\item[{const uint8\+\_\+t $\ast$}]{buf\+Ptr, }
\item[{size\+\_\+t}]{buf\+Num\+Elements}
\end{DoxyParamCaption}
)}\hypertarget{fs_8c_afb8428bae9f5335591bef6d723d908f9}{}\label{fs_8c_afb8428bae9f5335591bef6d723d908f9}
This function is called to write the requested data length to an opened file. The data is written at the current file position.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK The function succeeded.
\item L\+E\+\_\+\+B\+A\+D\+\_\+\+P\+A\+R\+A\+M\+E\+T\+ER A parameter is invalid.
\item L\+E\+\_\+\+U\+N\+D\+E\+R\+F\+L\+OW The write succeed but was not able to write all bytes
\item L\+E\+\_\+\+F\+A\+U\+LT The function failed. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Ref} & File reference \\
\hline
\mbox{\tt in}  & {\em buf\+Ptr} & Buffer to write in the file \\
\hline
\mbox{\tt in}  & {\em buf\+Num\+Elements} & Number of bytes to write \\
\hline
\end{DoxyParams}
\index{fs.\+c@{fs.\+c}!Mk\+Dir\+Tree@{Mk\+Dir\+Tree}}
\index{Mk\+Dir\+Tree@{Mk\+Dir\+Tree}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{Mk\+Dir\+Tree(const char $\ast$file\+Path\+Ptr)}{MkDirTree(const char *filePathPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf le\+\_\+result\+\_\+t} Mk\+Dir\+Tree (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{file\+Path\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{fs_8c_a3375858a4005a0b267396184a5571734}{}\label{fs_8c_a3375858a4005a0b267396184a5571734}
This function is called to create the directories of a file path if some do not exist

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK The function succeeded.
\item L\+E\+\_\+\+U\+N\+S\+U\+P\+P\+O\+R\+T\+ED The prefix cannot be added and the function is unusable
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+P\+O\+S\+S\+I\+B\+LE A directory in the tree belongs to a Read-\/\+Only space and cannot be created
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+P\+E\+R\+M\+I\+T\+T\+ED A directory in the tree belongs has not access right and cannot be created
\item L\+E\+\_\+\+F\+A\+U\+LT The function fails while creating or accessing to a directory. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em file\+Path\+Ptr} & Directory path \\
\hline
\end{DoxyParams}


\subsection{Variable Documentation}
\index{fs.\+c@{fs.\+c}!Fs\+File\+Ref\+Map@{Fs\+File\+Ref\+Map}}
\index{Fs\+File\+Ref\+Map@{Fs\+File\+Ref\+Map}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{Fs\+File\+Ref\+Map}{FsFileRefMap}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+ref\+\_\+\+Map\+Ref\+\_\+t} Fs\+File\+Ref\+Map\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{fs_8c_a8a826d68fe9af29f5ad572b61caac987}{}\label{fs_8c_a8a826d68fe9af29f5ad572b61caac987}
Safe reference map for the file structure \index{fs.\+c@{fs.\+c}!Fs\+File\+Ref\+Pool@{Fs\+File\+Ref\+Pool}}
\index{Fs\+File\+Ref\+Pool@{Fs\+File\+Ref\+Pool}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{Fs\+File\+Ref\+Pool}{FsFileRefPool}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+mem\+\_\+\+Pool\+Ref\+\_\+t} Fs\+File\+Ref\+Pool\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{fs_8c_a3001c1c1b5732c6cda339cc461ced20a}{}\label{fs_8c_a3001c1c1b5732c6cda339cc461ced20a}
Pool to store the file structures \index{fs.\+c@{fs.\+c}!Fs\+Prefix\+Ptr@{Fs\+Prefix\+Ptr}}
\index{Fs\+Prefix\+Ptr@{Fs\+Prefix\+Ptr}!fs.\+c@{fs.\+c}}
\subsubsection[{\texorpdfstring{Fs\+Prefix\+Ptr}{FsPrefixPtr}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ Fs\+Prefix\+Ptr = N\+U\+LL\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{fs_8c_a72461ad37f672e082cc406cb6c70269e}{}\label{fs_8c_a72461ad37f672e082cc406cb6c70269e}
Default prefixes path used by the daemon. If N\+U\+LL, the daemon will reject all open/rename/delete operations 