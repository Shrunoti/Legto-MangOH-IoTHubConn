\hypertarget{unix_socket_8c}{}\section{framework/liblegato/linux/unix\+Socket.c File Reference}
\label{unix_socket_8c}\index{framework/liblegato/linux/unix\+Socket.\+c@{framework/liblegato/linux/unix\+Socket.\+c}}
{\ttfamily \#include \char`\"{}legato.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}unix\+Socket.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}file\+Descriptor.\+h\char`\"{}}\\*
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{unix_socket_8c_a1c84dc80e36a5a9feca77d09bcec9b8f}{C\+M\+S\+G\+\_\+\+B\+U\+F\+F\+\_\+\+S\+I\+ZE}~(C\+M\+S\+G\+\_\+\+S\+P\+A\+CE(sizeof(int)) + C\+M\+S\+G\+\_\+\+S\+P\+A\+CE(sizeof(struct ucred)))
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{unix_socket_8c_a803ddd194b6cf7cb48af5e346a944c0e}{Extract\+File\+Descriptor} (struct cmsghdr $\ast$cmsg\+Header\+Ptr)
\item 
static \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{unix_socket_8c_a83a219c28161a045277fd3309595eb4d}{Extract\+Ancillary\+Data} (struct msghdr $\ast$msg\+Header\+Ptr, int $\ast$fd\+Ptr, struct ucred $\ast$cred\+Ptr)
\item 
int \hyperlink{unix_socket_8c_a1a9716076a305c1e918584568da28907}{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Named} (const char $\ast$path\+Str)
\item 
int \hyperlink{unix_socket_8c_abb4b00a74449a57fdfa4fd1a642fb37a}{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Unnamed} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{unix_socket_8c_a9eb8d8b2e6802827529abf2ad90f6ff6}{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Pair} (int $\ast$socket\+Fd1\+Ptr, int $\ast$socket\+Fd2\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{unix_socket_8c_af30486f2e4f0a4dbcaf3f27d1ac6ce73}{unix\+Socket\+\_\+\+Connect} (int \hyperlink{app_stop_client_8c_a44f21d5190b5a6df8089f54799628d7e}{fd}, const char $\ast$path\+Str)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{unix_socket_8c_af81ee1e16e1ee2edbb8610fbb4e34ebe}{unix\+Socket\+\_\+\+Send\+Msg} (int local\+Socket\+Fd, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$data\+Ptr, size\+\_\+t data\+Size, int fd\+To\+Send, bool send\+Credentials)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{unix_socket_8c_a4b3f6de930eaff61cb764a39d42c4e22}{unix\+Socket\+\_\+\+Send\+Data\+Msg} (int local\+Socket\+Fd, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$data\+Ptr, size\+\_\+t data\+Size)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{unix_socket_8c_ab64d779b38aa59e2a433a38f613fe191}{unix\+Socket\+\_\+\+Receive\+Msg} (int local\+Socket\+Fd, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$data\+Buff\+Ptr, size\+\_\+t $\ast$data\+Size\+Ptr, int $\ast$fd\+Ptr, struct ucred $\ast$cred\+Ptr)
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{unix_socket_8c_a4ed8bcf2438f3c7db8b02e3b6596a4a2}{unix\+Socket\+\_\+\+Receive\+Data\+Msg} (int local\+Socket\+Fd, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$data\+Buff\+Ptr, size\+\_\+t $\ast$data\+Size\+Ptr)
\item 
int \hyperlink{unix_socket_8c_a68e10b2c3bea86bd658798bc947621c8}{unix\+Socket\+\_\+\+Get\+Error\+State} (int local\+Socket\+Fd)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Legato \hyperlink{c_unixSockets}{Unix Domain Sockets A\+PI} implementation file.

Copyright (C) Sierra Wireless Inc. 

\subsection{Macro Definition Documentation}
\index{unix\+Socket.\+c@{unix\+Socket.\+c}!C\+M\+S\+G\+\_\+\+B\+U\+F\+F\+\_\+\+S\+I\+ZE@{C\+M\+S\+G\+\_\+\+B\+U\+F\+F\+\_\+\+S\+I\+ZE}}
\index{C\+M\+S\+G\+\_\+\+B\+U\+F\+F\+\_\+\+S\+I\+ZE@{C\+M\+S\+G\+\_\+\+B\+U\+F\+F\+\_\+\+S\+I\+ZE}!unix\+Socket.\+c@{unix\+Socket.\+c}}
\subsubsection[{\texorpdfstring{C\+M\+S\+G\+\_\+\+B\+U\+F\+F\+\_\+\+S\+I\+ZE}{CMSG_BUFF_SIZE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define C\+M\+S\+G\+\_\+\+B\+U\+F\+F\+\_\+\+S\+I\+ZE~(C\+M\+S\+G\+\_\+\+S\+P\+A\+CE(sizeof(int)) + C\+M\+S\+G\+\_\+\+S\+P\+A\+CE(sizeof(struct ucred)))}\hypertarget{unix_socket_8c_a1c84dc80e36a5a9feca77d09bcec9b8f}{}\label{unix_socket_8c_a1c84dc80e36a5a9feca77d09bcec9b8f}
Size of the ancillary (control) message buffer needed to send or receive one file descriptor and one set of process credentials through a Unix domain socket. \begin{DoxyNote}{Note}
We use C\+M\+S\+G\+\_\+\+S\+P\+A\+CE to ensure this is big enough to hold the cmsghdr structures. 
\end{DoxyNote}


\subsection{Function Documentation}
\index{unix\+Socket.\+c@{unix\+Socket.\+c}!Extract\+Ancillary\+Data@{Extract\+Ancillary\+Data}}
\index{Extract\+Ancillary\+Data@{Extract\+Ancillary\+Data}!unix\+Socket.\+c@{unix\+Socket.\+c}}
\subsubsection[{\texorpdfstring{Extract\+Ancillary\+Data(struct msghdr $\ast$msg\+Header\+Ptr, int $\ast$fd\+Ptr, struct ucred $\ast$cred\+Ptr)}{ExtractAncillaryData(struct msghdr *msgHeaderPtr, int *fdPtr, struct ucred *credPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf void} Extract\+Ancillary\+Data (
\begin{DoxyParamCaption}
\item[{struct msghdr $\ast$}]{msg\+Header\+Ptr, }
\item[{int $\ast$}]{fd\+Ptr, }
\item[{struct ucred $\ast$}]{cred\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{unix_socket_8c_a83a219c28161a045277fd3309595eb4d}{}\label{unix_socket_8c_a83a219c28161a045277fd3309595eb4d}
Extract ancillary data from a received message. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em msg\+Header\+Ptr} & Pointer to the struct msghdr that was filled in by a call to recvmsg(). \\
\hline
\mbox{\tt out}  & {\em fd\+Ptr} & Pointer to where the received file descriptor will be put. (-\/1 will be stored here if no fd was received.) \\
\hline
\mbox{\tt out}  & {\em cred\+Ptr} & Pointer to where received credentials will be stored. (N\+O\+TE\+: P\+ID is set to zero if no credentials received.) \\
\hline
\end{DoxyParams}
\index{unix\+Socket.\+c@{unix\+Socket.\+c}!Extract\+File\+Descriptor@{Extract\+File\+Descriptor}}
\index{Extract\+File\+Descriptor@{Extract\+File\+Descriptor}!unix\+Socket.\+c@{unix\+Socket.\+c}}
\subsubsection[{\texorpdfstring{Extract\+File\+Descriptor(struct cmsghdr $\ast$cmsg\+Header\+Ptr)}{ExtractFileDescriptor(struct cmsghdr *cmsgHeaderPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static int Extract\+File\+Descriptor (
\begin{DoxyParamCaption}
\item[{struct cmsghdr $\ast$}]{cmsg\+Header\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{unix_socket_8c_a803ddd194b6cf7cb48af5e346a944c0e}{}\label{unix_socket_8c_a803ddd194b6cf7cb48af5e346a944c0e}
Extract a file descriptor from an S\+C\+M\+\_\+\+R\+I\+G\+H\+TS ancillary data message.

\begin{DoxyReturn}{Returns}
The file descriptor. 
\end{DoxyReturn}
\index{unix\+Socket.\+c@{unix\+Socket.\+c}!unix\+Socket\+\_\+\+Connect@{unix\+Socket\+\_\+\+Connect}}
\index{unix\+Socket\+\_\+\+Connect@{unix\+Socket\+\_\+\+Connect}!unix\+Socket.\+c@{unix\+Socket.\+c}}
\subsubsection[{\texorpdfstring{unix\+Socket\+\_\+\+Connect(int fd, const char $\ast$path\+Str)}{unixSocket_Connect(int fd, const char *pathStr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} unix\+Socket\+\_\+\+Connect (
\begin{DoxyParamCaption}
\item[{int}]{fd, }
\item[{const char $\ast$}]{path\+Str}
\end{DoxyParamCaption}
)}\hypertarget{unix_socket_8c_af30486f2e4f0a4dbcaf3f27d1ac6ce73}{}\label{unix_socket_8c_af30486f2e4f0a4dbcaf3f27d1ac6ce73}
Connect a local socket to another named socket.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if successful.
\item L\+E\+\_\+\+W\+O\+U\+L\+D\+\_\+\+B\+L\+O\+CK if socket is non-\/blocking and could not be immediately connected.
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+F\+O\+U\+ND if the path provided does not refer to a listening socket.
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+P\+E\+R\+M\+I\+T\+T\+ED if the calling process does not have permission to connect to that socket.
\item L\+E\+\_\+\+F\+A\+U\+LT if failed for some other reason (check your logs).
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyNote}{Note}
In non-\/blocking mode, if L\+E\+\_\+\+W\+O\+U\+L\+D\+\_\+\+B\+L\+O\+CK is returned, monitor the socket fd for writeability, and when it becomes writeable, call \hyperlink{unix_socket_8c_a68e10b2c3bea86bd658798bc947621c8}{unix\+Socket\+\_\+\+Get\+Error\+State()} to find out if the connection succeeded or failed. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em fd} & Local socket file descriptor. \\
\hline
\mbox{\tt in}  & {\em path\+Str} & File system path of the named socket to connect to. \\
\hline
\end{DoxyParams}
\index{unix\+Socket.\+c@{unix\+Socket.\+c}!unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Named@{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Named}}
\index{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Named@{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Named}!unix\+Socket.\+c@{unix\+Socket.\+c}}
\subsubsection[{\texorpdfstring{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Named(const char $\ast$path\+Str)}{unixSocket_CreateSeqPacketNamed(const char *pathStr)}}]{\setlength{\rightskip}{0pt plus 5cm}int unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Named (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{path\+Str}
\end{DoxyParamCaption}
)}\hypertarget{unix_socket_8c_a1a9716076a305c1e918584568da28907}{}\label{unix_socket_8c_a1a9716076a305c1e918584568da28907}
Creates a named sequenced-\/packet Unix domain socket. This binds the socket to a file system path. A \char`\"{}socket\char`\"{} type pseudo file will appear at that location in the file system.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item The file descriptor (a number $>$ 0) of the socket, if successful.
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+P\+E\+R\+M\+I\+T\+T\+ED if the calling process does not have permission to create a socket at that location in the file system.
\item L\+E\+\_\+\+D\+U\+P\+L\+I\+C\+A\+TE if something already exists at that location in the file system.
\item L\+E\+\_\+\+F\+A\+U\+LT if failed for some other reason (check your logs). 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em path\+Str} & File system path to bind to the socket. \\
\hline
\end{DoxyParams}
\index{unix\+Socket.\+c@{unix\+Socket.\+c}!unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Pair@{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Pair}}
\index{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Pair@{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Pair}!unix\+Socket.\+c@{unix\+Socket.\+c}}
\subsubsection[{\texorpdfstring{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Pair(int $\ast$socket\+Fd1\+Ptr, int $\ast$socket\+Fd2\+Ptr)}{unixSocket_CreateSeqPacketPair(int *socketFd1Ptr, int *socketFd2Ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Pair (
\begin{DoxyParamCaption}
\item[{int $\ast$}]{socket\+Fd1\+Ptr, }
\item[{int $\ast$}]{socket\+Fd2\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{unix_socket_8c_a9eb8d8b2e6802827529abf2ad90f6ff6}{}\label{unix_socket_8c_a9eb8d8b2e6802827529abf2ad90f6ff6}
Creates a pair of unnamed Unix domain sequenced-\/packet sockets that are connected to each other.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if successful.
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+P\+E\+R\+M\+I\+T\+T\+ED if the calling process does not have permission to create a pair of sockets. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt out}  & {\em socket\+Fd1\+Ptr} & Ptr to where the fd for one of the sockets will be stored. \\
\hline
\mbox{\tt out}  & {\em socket\+Fd2\+Ptr} & Ptr to where the other socket\textquotesingle{}s fd will be stored. \\
\hline
\end{DoxyParams}
\index{unix\+Socket.\+c@{unix\+Socket.\+c}!unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Unnamed@{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Unnamed}}
\index{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Unnamed@{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Unnamed}!unix\+Socket.\+c@{unix\+Socket.\+c}}
\subsubsection[{\texorpdfstring{unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Unnamed(void)}{unixSocket_CreateSeqPacketUnnamed(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int unix\+Socket\+\_\+\+Create\+Seq\+Packet\+Unnamed (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{unix_socket_8c_abb4b00a74449a57fdfa4fd1a642fb37a}{}\label{unix_socket_8c_abb4b00a74449a57fdfa4fd1a642fb37a}
Creates an unnamed sequenced-\/packet Unix domain socket.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item The file descriptor (a number $>$ 0) of the socket, if successful.
\item L\+E\+\_\+\+N\+O\+T\+\_\+\+P\+E\+R\+M\+I\+T\+T\+ED if the calling process does not have permission to create the socket.
\item L\+E\+\_\+\+F\+A\+U\+LT if failed for some other reason (check your logs). 
\end{DoxyItemize}
\end{DoxyReturn}
\index{unix\+Socket.\+c@{unix\+Socket.\+c}!unix\+Socket\+\_\+\+Get\+Error\+State@{unix\+Socket\+\_\+\+Get\+Error\+State}}
\index{unix\+Socket\+\_\+\+Get\+Error\+State@{unix\+Socket\+\_\+\+Get\+Error\+State}!unix\+Socket.\+c@{unix\+Socket.\+c}}
\subsubsection[{\texorpdfstring{unix\+Socket\+\_\+\+Get\+Error\+State(int local\+Socket\+Fd)}{unixSocket_GetErrorState(int localSocketFd)}}]{\setlength{\rightskip}{0pt plus 5cm}int unix\+Socket\+\_\+\+Get\+Error\+State (
\begin{DoxyParamCaption}
\item[{int}]{local\+Socket\+Fd}
\end{DoxyParamCaption}
)}\hypertarget{unix_socket_8c_a68e10b2c3bea86bd658798bc947621c8}{}\label{unix_socket_8c_a68e10b2c3bea86bd658798bc947621c8}
Fetches the socket error state code (S\+O\+\_\+\+E\+R\+R\+OR).

\begin{DoxyReturn}{Returns}
The S\+O\+\_\+\+E\+R\+R\+OR value, or E\+B\+A\+DE if failed. 
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em local\+Socket\+Fd} & fd of local socket that will be used to receive the message. \\
\hline
\end{DoxyParams}
\index{unix\+Socket.\+c@{unix\+Socket.\+c}!unix\+Socket\+\_\+\+Receive\+Data\+Msg@{unix\+Socket\+\_\+\+Receive\+Data\+Msg}}
\index{unix\+Socket\+\_\+\+Receive\+Data\+Msg@{unix\+Socket\+\_\+\+Receive\+Data\+Msg}!unix\+Socket.\+c@{unix\+Socket.\+c}}
\subsubsection[{\texorpdfstring{unix\+Socket\+\_\+\+Receive\+Data\+Msg(int local\+Socket\+Fd, void $\ast$data\+Buff\+Ptr, size\+\_\+t $\ast$data\+Size\+Ptr)}{unixSocket_ReceiveDataMsg(int localSocketFd, void *dataBuffPtr, size_t *dataSizePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} unix\+Socket\+\_\+\+Receive\+Data\+Msg (
\begin{DoxyParamCaption}
\item[{int}]{local\+Socket\+Fd, }
\item[{{\bf void} $\ast$}]{data\+Buff\+Ptr, }
\item[{size\+\_\+t $\ast$}]{data\+Size\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{unix_socket_8c_a4ed8bcf2438f3c7db8b02e3b6596a4a2}{}\label{unix_socket_8c_a4ed8bcf2438f3c7db8b02e3b6596a4a2}
Receives a message containing only data payload through a connected Unix domain datagram or sequenced-\/packet socket.

\begin{DoxyNote}{Note}

\begin{DoxyItemize}
\item Any ancillary data (file descriptors or credentials) associated with the message will be discarded.
\item It is recommended that read() be used for stream sockets.
\end{DoxyItemize}
\end{DoxyNote}
\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if successful
\item L\+E\+\_\+\+N\+O\+\_\+\+M\+E\+M\+O\+RY if more data was sent than could fit in the buffer provided.
\item L\+E\+\_\+\+W\+O\+U\+L\+D\+\_\+\+B\+L\+O\+CK if the socket is set non-\/blocking and there is nothing to be received.
\item L\+E\+\_\+\+C\+L\+O\+S\+ED if the connection closed.
\item L\+E\+\_\+\+F\+A\+U\+LT if failed for some other reason (check your logs).
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
If L\+E\+\_\+\+N\+O\+\_\+\+M\+E\+M\+O\+RY is returned, the remainder of the message that couldn\textquotesingle{}t fit into the receive buffer will have been lost. 
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em local\+Socket\+Fd} & fd of local socket that will be used to receive the message. \\
\hline
\mbox{\tt out}  & {\em data\+Buff\+Ptr} & Pointer to where any received data payload will be put. \\
\hline
\mbox{\tt in,out}  & {\em data\+Size\+Ptr} & Ptr to the number of bytes that can fit in the array pointed to by data\+Buff\+Ptr. This will be updated to the number of bytes of data received. \\
\hline
\end{DoxyParams}
\index{unix\+Socket.\+c@{unix\+Socket.\+c}!unix\+Socket\+\_\+\+Receive\+Msg@{unix\+Socket\+\_\+\+Receive\+Msg}}
\index{unix\+Socket\+\_\+\+Receive\+Msg@{unix\+Socket\+\_\+\+Receive\+Msg}!unix\+Socket.\+c@{unix\+Socket.\+c}}
\subsubsection[{\texorpdfstring{unix\+Socket\+\_\+\+Receive\+Msg(int local\+Socket\+Fd, void $\ast$data\+Buff\+Ptr, size\+\_\+t $\ast$data\+Size\+Ptr, int $\ast$fd\+Ptr, struct ucred $\ast$cred\+Ptr)}{unixSocket_ReceiveMsg(int localSocketFd, void *dataBuffPtr, size_t *dataSizePtr, int *fdPtr, struct ucred *credPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} unix\+Socket\+\_\+\+Receive\+Msg (
\begin{DoxyParamCaption}
\item[{int}]{local\+Socket\+Fd, }
\item[{{\bf void} $\ast$}]{data\+Buff\+Ptr, }
\item[{size\+\_\+t $\ast$}]{data\+Size\+Ptr, }
\item[{int $\ast$}]{fd\+Ptr, }
\item[{struct ucred $\ast$}]{cred\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{unix_socket_8c_ab64d779b38aa59e2a433a38f613fe191}{}\label{unix_socket_8c_ab64d779b38aa59e2a433a38f613fe191}
Receives through a connected Unix domain socket a message containing any combination of
\begin{DoxyItemize}
\item a data payload
\item a file descriptor
\item authenticated credentials
\end{DoxyItemize}

N\+U\+LL pointers can be passed in for any of the above that are not needed. For example, if data and credentials are expected, but not a file descriptor, then fd\+Ptr could be set to N\+U\+LL.

\begin{DoxyNote}{Note}
Authentication of credentials must be enabled using \hyperlink{unix_socket_8h_a814c92589fc434132bc1cfbfc5b37e5b}{unix\+Socket\+\_\+\+Enable\+Authentication()} before credentials can be received.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if successful
\item L\+E\+\_\+\+N\+O\+\_\+\+M\+E\+M\+O\+RY if more data was received than could fit in the buffer provided.
\item L\+E\+\_\+\+W\+O\+U\+L\+D\+\_\+\+B\+L\+O\+CK if the socket is set non-\/blocking and there is nothing to be received.
\item L\+E\+\_\+\+C\+L\+O\+S\+ED if the connection closed.
\item L\+E\+\_\+\+F\+A\+U\+LT if failed for some other reason (check your logs).
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
If L\+E\+\_\+\+W\+O\+U\+L\+D\+\_\+\+B\+L\+O\+CK is returned when using a stream socket, some data may have been read. Check the returned data size to find out how much. Furthermore, if L\+E\+\_\+\+N\+O\+\_\+\+M\+E\+M\+O\+RY is returned for a datagram (or sequenced-\/packet?) socket, the remainder of the message that couldn\textquotesingle{}t fit into the receive buffer will have been lost. 
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em local\+Socket\+Fd} & fd of local socket that will be used to receive the message. \\
\hline
\mbox{\tt out}  & {\em data\+Buff\+Ptr} & Pointer to where any received data payload will be put. \\
\hline
\mbox{\tt in,out}  & {\em data\+Size\+Ptr} & Ptr to the number of bytes that can fit in the array pointed to by data\+Buff\+Ptr. This will be updated to the number of bytes of data received. \\
\hline
\mbox{\tt out}  & {\em fd\+Ptr} & Pointer to where the received file descriptor will be put. (-\/1 will be stored here if no fd was received.) \\
\hline
\mbox{\tt out}  & {\em cred\+Ptr} & Pointer to where received credentials will be stored. (N\+O\+TE\+: P\+ID is set to zero if no credentials received.) \\
\hline
\end{DoxyParams}
\index{unix\+Socket.\+c@{unix\+Socket.\+c}!unix\+Socket\+\_\+\+Send\+Data\+Msg@{unix\+Socket\+\_\+\+Send\+Data\+Msg}}
\index{unix\+Socket\+\_\+\+Send\+Data\+Msg@{unix\+Socket\+\_\+\+Send\+Data\+Msg}!unix\+Socket.\+c@{unix\+Socket.\+c}}
\subsubsection[{\texorpdfstring{unix\+Socket\+\_\+\+Send\+Data\+Msg(int local\+Socket\+Fd, void $\ast$data\+Ptr, size\+\_\+t data\+Size)}{unixSocket_SendDataMsg(int localSocketFd, void *dataPtr, size_t dataSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} unix\+Socket\+\_\+\+Send\+Data\+Msg (
\begin{DoxyParamCaption}
\item[{int}]{local\+Socket\+Fd, }
\item[{{\bf void} $\ast$}]{data\+Ptr, }
\item[{size\+\_\+t}]{data\+Size}
\end{DoxyParamCaption}
)}\hypertarget{unix_socket_8c_a4b3f6de930eaff61cb764a39d42c4e22}{}\label{unix_socket_8c_a4b3f6de930eaff61cb764a39d42c4e22}
Sends a message containing only data through a connected Unix domain datagram or sequenced-\/packet socket.

\begin{DoxyNote}{Note}
It is recommended that write() be used for stream sockets instead.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if successful
\item L\+E\+\_\+\+C\+O\+M\+M\+\_\+\+E\+R\+R\+OR if the local\+Socket\+Fd is not connected.
\item L\+E\+\_\+\+F\+A\+U\+LT if failed for some other reason (check your logs).
\item L\+E\+\_\+\+N\+O\+\_\+\+M\+E\+M\+O\+RY if the send socket is set to non-\/blocking and it doesn\textquotesingle{}t have enough buffer space to send right now. Wait for the \char`\"{}writeable\char`\"{} event on the file descriptor. 
\end{DoxyItemize}
\end{DoxyReturn}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em local\+Socket\+Fd} & fd of the local socket that will be used to send. \\
\hline
\mbox{\tt in}  & {\em data\+Ptr} & Pointer to the data payload to be sent (N\+U\+LL if none). \\
\hline
\mbox{\tt in}  & {\em data\+Size} & Number of bytes of data payload to be sent. \\
\hline
\end{DoxyParams}
\index{unix\+Socket.\+c@{unix\+Socket.\+c}!unix\+Socket\+\_\+\+Send\+Msg@{unix\+Socket\+\_\+\+Send\+Msg}}
\index{unix\+Socket\+\_\+\+Send\+Msg@{unix\+Socket\+\_\+\+Send\+Msg}!unix\+Socket.\+c@{unix\+Socket.\+c}}
\subsubsection[{\texorpdfstring{unix\+Socket\+\_\+\+Send\+Msg(int local\+Socket\+Fd, void $\ast$data\+Ptr, size\+\_\+t data\+Size, int fd\+To\+Send, bool send\+Credentials)}{unixSocket_SendMsg(int localSocketFd, void *dataPtr, size_t dataSize, int fdToSend, bool sendCredentials)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} unix\+Socket\+\_\+\+Send\+Msg (
\begin{DoxyParamCaption}
\item[{int}]{local\+Socket\+Fd, }
\item[{{\bf void} $\ast$}]{data\+Ptr, }
\item[{size\+\_\+t}]{data\+Size, }
\item[{int}]{fd\+To\+Send, }
\item[{bool}]{send\+Credentials}
\end{DoxyParamCaption}
)}\hypertarget{unix_socket_8c_af81ee1e16e1ee2edbb8610fbb4e34ebe}{}\label{unix_socket_8c_af81ee1e16e1ee2edbb8610fbb4e34ebe}
Sends through a connected Unix domain socket a message containing any combination of\+:
\begin{DoxyItemize}
\item a data payload
\item a file descriptor
\item authenticated credentials
\end{DoxyItemize}

All of the above are optional, with the following exceptions\+:
\begin{DoxyItemize}
\item it doesn\textquotesingle{}t make sense to omit everything
\item when using stream sockets, at least one byte of data payload must be sent.
\end{DoxyItemize}

For example, if data and credentials are to be sent, but not file descriptors, then fd\+To\+Send could be set to -\/1.

\begin{DoxyNote}{Note}
When file descriptors are sent, they are duplicated in the receiving process\textquotesingle{}s address space, as if they were created using dup(). This means that they are left open in the sending process and must be closed by the sender if the sender doesn\textquotesingle{}t need to continue using them.
\end{DoxyNote}
\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if successful
\item L\+E\+\_\+\+C\+O\+M\+M\+\_\+\+E\+R\+R\+OR if the local\+Socket\+Fd is not connected.
\item L\+E\+\_\+\+F\+A\+U\+LT if failed for some other reason (check your logs).
\item L\+E\+\_\+\+N\+O\+\_\+\+M\+E\+M\+O\+RY if the send socket is set to non-\/blocking and it doesn\textquotesingle{}t have enough buffer space to send right now. Wait for the \char`\"{}writeable\char`\"{} event on the file descriptor.
\end{DoxyItemize}
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
DO N\+OT S\+E\+ND D\+I\+R\+E\+C\+T\+O\+RY F\+I\+LE D\+E\+S\+C\+R\+I\+P\+T\+O\+RS. That can be exploited to break out of chroot() jails. 
\end{DoxyWarning}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em local\+Socket\+Fd} & fd of the local socket that will be used to send. \\
\hline
\mbox{\tt in}  & {\em data\+Ptr} & Pointer to the data payload to be sent (N\+U\+LL if none). \\
\hline
\mbox{\tt in}  & {\em data\+Size} & Number of bytes of data payload to be sent. \\
\hline
\mbox{\tt in}  & {\em fd\+To\+Send} & The file descriptor to be sent (-\/1 if no FD to send). \\
\hline
\mbox{\tt in}  & {\em send\+Credentials} & true = Send credentials. false = Don\textquotesingle{}t send credentials. \\
\hline
\end{DoxyParams}
