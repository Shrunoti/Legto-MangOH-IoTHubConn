\hypertarget{namespacemk_1_1detail}{}\section{mk\+:\+:detail Namespace Reference}
\label{namespacemk_1_1detail}\index{mk\+::detail@{mk\+::detail}}
\subsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structmk_1_1detail_1_1printf__type}{printf\+\_\+type}
\item 
struct \hyperlink{structmk_1_1detail_1_1printf__type_3_01std_1_1string_01_4}{printf\+\_\+type$<$ std\+::string $>$}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename T , typename R  = typename printf\+\_\+type$<$\+T$>$\+::type$>$ }\\R \hyperlink{namespacemk_1_1detail_a5679183f4f3f4e989ab6d5091e6922a4}{to\+\_\+printf\+\_\+type} (const T \&t)
\item 
{\footnotesize template$<$$>$ }\\const char $\ast$ \hyperlink{namespacemk_1_1detail_aff3ecd12602e9407db44df98017a506c}{to\+\_\+printf\+\_\+type$<$ std\+::string $>$} (const std\+::string \&t)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
static const int \hyperlink{namespacemk_1_1detail_a1108ca5affa7b4add72c7164eb650949}{buffer\+Size} = 128
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{mk\+::detail@{mk\+::detail}!to\+\_\+printf\+\_\+type@{to\+\_\+printf\+\_\+type}}
\index{to\+\_\+printf\+\_\+type@{to\+\_\+printf\+\_\+type}!mk\+::detail@{mk\+::detail}}
\subsubsection[{\texorpdfstring{to\+\_\+printf\+\_\+type(const T \&t)}{to_printf_type(const T &t)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T , typename R  = typename printf\+\_\+type$<$\+T$>$\+::type$>$ R mk\+::detail\+::to\+\_\+printf\+\_\+type (
\begin{DoxyParamCaption}
\item[{const T \&}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacemk_1_1detail_a5679183f4f3f4e989ab6d5091e6922a4}{}\label{namespacemk_1_1detail_a5679183f4f3f4e989ab6d5091e6922a4}
Convert argument to the correct type.

This is partially specialized so std\+::string will automatically be converted to const char $\ast$. add any other partial template specializations as required here -- final type needs to be a type understood by printf. \index{mk\+::detail@{mk\+::detail}!to\+\_\+printf\+\_\+type$<$ std\+::string $>$@{to\+\_\+printf\+\_\+type$<$ std\+::string $>$}}
\index{to\+\_\+printf\+\_\+type$<$ std\+::string $>$@{to\+\_\+printf\+\_\+type$<$ std\+::string $>$}!mk\+::detail@{mk\+::detail}}
\subsubsection[{\texorpdfstring{to\+\_\+printf\+\_\+type$<$ std\+::string $>$(const std\+::string \&t)}{to_printf_type< std::string >(const std::string &t)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$$>$ const char$\ast$ {\bf mk\+::detail\+::to\+\_\+printf\+\_\+type}$<$ std\+::string $>$ (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{namespacemk_1_1detail_aff3ecd12602e9407db44df98017a506c}{}\label{namespacemk_1_1detail_aff3ecd12602e9407db44df98017a506c}
Explicit specialization of to\+\_\+printf\+\_\+type for std\+::string 

\subsection{Variable Documentation}
\index{mk\+::detail@{mk\+::detail}!buffer\+Size@{buffer\+Size}}
\index{buffer\+Size@{buffer\+Size}!mk\+::detail@{mk\+::detail}}
\subsubsection[{\texorpdfstring{buffer\+Size}{bufferSize}}]{\setlength{\rightskip}{0pt plus 5cm}const int mk\+::detail\+::buffer\+Size = 128\hspace{0.3cm}{\ttfamily [static]}}\hypertarget{namespacemk_1_1detail_a1108ca5affa7b4add72c7164eb650949}{}\label{namespacemk_1_1detail_a1108ca5affa7b4add72c7164eb650949}
