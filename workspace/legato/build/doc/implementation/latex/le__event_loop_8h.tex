\hypertarget{le__event_loop_8h}{}\section{framework/include/le\+\_\+event\+Loop.h File Reference}
\label{le__event_loop_8h}\index{framework/include/le\+\_\+event\+Loop.\+h@{framework/include/le\+\_\+event\+Loop.\+h}}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{le__event_loop_8h_a3973e227dd6ff4e79b2f97c42b105662}{L\+E\+\_\+\+C\+I\+\_\+\+L\+I\+N\+K\+A\+GE}
\item 
\#define \hyperlink{le__event_loop_8h_abdb9187a56836a93d19cc793cbd4b7ec}{C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+I\+N\+IT}~\hyperlink{le__event_loop_8h_a3973e227dd6ff4e79b2f97c42b105662}{L\+E\+\_\+\+C\+I\+\_\+\+L\+I\+N\+K\+A\+GE} \hyperlink{le__basics_8h_a1661bfbb29c2e0372ca9f0c556a8fc24}{L\+E\+\_\+\+S\+H\+A\+R\+ED} \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{__le__main_8c_aac22a39362c7322bc7f002af1c38ba08}{\+\_\+le\+\_\+event\+\_\+\+Initialize\+Component}(\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
\#define \hyperlink{le__event_loop_8h_a47faa85db57fa5243f12a4a1e55fbfec}{L\+E\+\_\+\+E\+V\+E\+N\+T\+\_\+\+I\+N\+I\+T\+\_\+\+H\+A\+N\+D\+L\+ER}~\hyperlink{wifi_service_8c_a0392d452f926ce36c4852de26b5eca12}{C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+I\+N\+IT}
\begin{DoxyCompactList}\small\item\em Deprecated name for \hyperlink{wifi_service_8c_a0392d452f926ce36c4852de26b5eca12}{C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+I\+N\+IT}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct le\+\_\+event\+\_\+\+Id $\ast$ \hyperlink{le__event_loop_8h_ae6e351b38bc95954f159d16d19d2d55c}{le\+\_\+event\+\_\+\+Id\+\_\+t}
\item 
typedef \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void}($\ast$ \hyperlink{le__event_loop_8h_ada421dec46f51fcb3421ef7058f16944}{le\+\_\+event\+\_\+\+Handler\+Func\+\_\+t}) (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$report\+Ptr)
\item 
typedef \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void}($\ast$ \hyperlink{le__event_loop_8h_a325afcc96343fde371e4c63639ace2ef}{le\+\_\+event\+\_\+\+Layered\+Handler\+Func\+\_\+t}) (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$report\+Ptr, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$second\+Layer\+Func)
\item 
typedef \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void}($\ast$ \hyperlink{le__event_loop_8h_a6f86581d4d2bf24647d5efaff1046d5d}{le\+\_\+event\+\_\+\+Deferred\+Func\+\_\+t}) (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$param1\+Ptr, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$param2\+Ptr)
\item 
typedef struct le\+\_\+event\+\_\+\+Handler $\ast$ \hyperlink{le__event_loop_8h_ae7ab96b8e3441b3d484fcf52aa7a9dad}{le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{le__event_loop_8h_ae6e351b38bc95954f159d16d19d2d55c}{le\+\_\+event\+\_\+\+Id\+\_\+t} \hyperlink{le__event_loop_8h_a41a96eb3affb07184b519164cf54e213}{le\+\_\+event\+\_\+\+Create\+Id} (const char $\ast$name, size\+\_\+t payload\+Size)
\item 
\hyperlink{le__event_loop_8h_ae6e351b38bc95954f159d16d19d2d55c}{le\+\_\+event\+\_\+\+Id\+\_\+t} \hyperlink{le__event_loop_8h_a31bef8276ad0e911fd84fb710d58ca2b}{le\+\_\+event\+\_\+\+Create\+Id\+With\+Ref\+Counting} (const char $\ast$name)
\item 
\hyperlink{le__event_loop_8h_ae7ab96b8e3441b3d484fcf52aa7a9dad}{le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t} \hyperlink{le__event_loop_8h_ae65a65b4111618f47d7e6d57a48289e5}{le\+\_\+event\+\_\+\+Add\+Handler} (const char $\ast$name, \hyperlink{le__event_loop_8h_ae6e351b38bc95954f159d16d19d2d55c}{le\+\_\+event\+\_\+\+Id\+\_\+t} event\+Id, \hyperlink{le__event_loop_8h_ada421dec46f51fcb3421ef7058f16944}{le\+\_\+event\+\_\+\+Handler\+Func\+\_\+t} handler\+Func)
\item 
\hyperlink{le__event_loop_8h_ae7ab96b8e3441b3d484fcf52aa7a9dad}{le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t} \hyperlink{le__event_loop_8h_a8b906d38935f64953482f42c745e1c18}{le\+\_\+event\+\_\+\+Add\+Layered\+Handler} (const char $\ast$name, \hyperlink{le__event_loop_8h_ae6e351b38bc95954f159d16d19d2d55c}{le\+\_\+event\+\_\+\+Id\+\_\+t} event\+Id, \hyperlink{le__event_loop_8h_a325afcc96343fde371e4c63639ace2ef}{le\+\_\+event\+\_\+\+Layered\+Handler\+Func\+\_\+t} first\+Layer\+Func, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$second\+Layer\+Func)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{le__event_loop_8h_ae31a85d4acbef72451b5411a613eea58}{le\+\_\+event\+\_\+\+Remove\+Handler} (\hyperlink{le__event_loop_8h_ae7ab96b8e3441b3d484fcf52aa7a9dad}{le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t} handler\+Ref)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{le__event_loop_8h_ae3ffe6990b70fb572b4eef06739b4f54}{le\+\_\+event\+\_\+\+Report} (\hyperlink{le__event_loop_8h_ae6e351b38bc95954f159d16d19d2d55c}{le\+\_\+event\+\_\+\+Id\+\_\+t} event\+Id, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$\hyperlink{log_tool_8c_ad6392d3bc0da4dd08be44c538eb44b32}{payload\+Ptr}, size\+\_\+t payload\+Size)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{le__event_loop_8h_af0277165493b512216fabb6086ec7d9c}{le\+\_\+event\+\_\+\+Report\+With\+Ref\+Counting} (\hyperlink{le__event_loop_8h_ae6e351b38bc95954f159d16d19d2d55c}{le\+\_\+event\+\_\+\+Id\+\_\+t} event\+Id, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$object\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{le__event_loop_8h_ae0c4307a9715794c720e525032aa0bfd}{le\+\_\+event\+\_\+\+Set\+Context\+Ptr} (\hyperlink{le__event_loop_8h_ae7ab96b8e3441b3d484fcf52aa7a9dad}{le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t} handler\+Ref, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$context\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ \hyperlink{le__event_loop_8h_a1c73916295cc9e17af07e02756aa86c9}{le\+\_\+event\+\_\+\+Get\+Context\+Ptr} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{le__event_loop_8h_a6dcc88f96060c5bc107a81a978132f38}{le\+\_\+event\+\_\+\+Queue\+Function} (\hyperlink{le__event_loop_8h_a6f86581d4d2bf24647d5efaff1046d5d}{le\+\_\+event\+\_\+\+Deferred\+Func\+\_\+t} func, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$param1\+Ptr, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$param2\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{le__event_loop_8h_a228da2d1f53ffa74517f108b0dcfa4d9}{le\+\_\+event\+\_\+\+Queue\+Function\+To\+Thread} (\hyperlink{le__thread_8h_a32121104c6b4ca39008eb79a4d6862f2}{le\+\_\+thread\+\_\+\+Ref\+\_\+t} thread, \hyperlink{le__event_loop_8h_a6f86581d4d2bf24647d5efaff1046d5d}{le\+\_\+event\+\_\+\+Deferred\+Func\+\_\+t} func, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$param1\+Ptr, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$param2\+Ptr)
\item 
\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} \hyperlink{le__event_loop_8h_ae313b457994371c658be9fe0494a01ff}{le\+\_\+event\+\_\+\+Run\+Loop} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
int \hyperlink{le__event_loop_8h_a12ce7f92f4bc6f5167d5a6ef86d7d0b1}{le\+\_\+event\+\_\+\+Get\+Fd} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\item 
\hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} \hyperlink{le__event_loop_8h_a096222e98f6a0d92a79722018a752b58}{le\+\_\+event\+\_\+\+Service\+Loop} (\hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void})
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Legato \hyperlink{c_eventLoop}{Event Loop A\+PI} include file.

Copyright (C) Sierra Wireless Inc. 

\subsection{Macro Definition Documentation}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+I\+N\+IT@{C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+I\+N\+IT}}
\index{C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+I\+N\+IT@{C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+I\+N\+IT}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+I\+N\+IT}{COMPONENT_INIT}}]{\setlength{\rightskip}{0pt plus 5cm}\#define C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+I\+N\+IT~{\bf L\+E\+\_\+\+C\+I\+\_\+\+L\+I\+N\+K\+A\+GE} {\bf L\+E\+\_\+\+S\+H\+A\+R\+ED} {\bf void} {\bf \+\_\+le\+\_\+event\+\_\+\+Initialize\+Component}({\bf void})}\hypertarget{le__event_loop_8h_abdb9187a56836a93d19cc793cbd4b7ec}{}\label{le__event_loop_8h_abdb9187a56836a93d19cc793cbd4b7ec}
Initialization event handler function. \index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!L\+E\+\_\+\+C\+I\+\_\+\+L\+I\+N\+K\+A\+GE@{L\+E\+\_\+\+C\+I\+\_\+\+L\+I\+N\+K\+A\+GE}}
\index{L\+E\+\_\+\+C\+I\+\_\+\+L\+I\+N\+K\+A\+GE@{L\+E\+\_\+\+C\+I\+\_\+\+L\+I\+N\+K\+A\+GE}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{L\+E\+\_\+\+C\+I\+\_\+\+L\+I\+N\+K\+A\+GE}{LE_CI_LINKAGE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define L\+E\+\_\+\+C\+I\+\_\+\+L\+I\+N\+K\+A\+GE}\hypertarget{le__event_loop_8h_a3973e227dd6ff4e79b2f97c42b105662}{}\label{le__event_loop_8h_a3973e227dd6ff4e79b2f97c42b105662}
Initialization event handler function declaration macro.

Use this macro instead of a normal function prototype to create an Initialization Event Handler function. E.\+g.,


\begin{DoxyCode}
1 COMPONENT\_INIT
2 \{
3     // Do my initialization here...
4 \}
\end{DoxyCode}


\begin{DoxyReturn}{Returns}
Nothing. 
\end{DoxyReturn}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!L\+E\+\_\+\+E\+V\+E\+N\+T\+\_\+\+I\+N\+I\+T\+\_\+\+H\+A\+N\+D\+L\+ER@{L\+E\+\_\+\+E\+V\+E\+N\+T\+\_\+\+I\+N\+I\+T\+\_\+\+H\+A\+N\+D\+L\+ER}}
\index{L\+E\+\_\+\+E\+V\+E\+N\+T\+\_\+\+I\+N\+I\+T\+\_\+\+H\+A\+N\+D\+L\+ER@{L\+E\+\_\+\+E\+V\+E\+N\+T\+\_\+\+I\+N\+I\+T\+\_\+\+H\+A\+N\+D\+L\+ER}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{L\+E\+\_\+\+E\+V\+E\+N\+T\+\_\+\+I\+N\+I\+T\+\_\+\+H\+A\+N\+D\+L\+ER}{LE_EVENT_INIT_HANDLER}}]{\setlength{\rightskip}{0pt plus 5cm}\#define L\+E\+\_\+\+E\+V\+E\+N\+T\+\_\+\+I\+N\+I\+T\+\_\+\+H\+A\+N\+D\+L\+ER~{\bf C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+I\+N\+IT}}\hypertarget{le__event_loop_8h_a47faa85db57fa5243f12a4a1e55fbfec}{}\label{le__event_loop_8h_a47faa85db57fa5243f12a4a1e55fbfec}


Deprecated name for \hyperlink{wifi_service_8c_a0392d452f926ce36c4852de26b5eca12}{C\+O\+M\+P\+O\+N\+E\+N\+T\+\_\+\+I\+N\+IT}. 



\subsection{Typedef Documentation}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Deferred\+Func\+\_\+t@{le\+\_\+event\+\_\+\+Deferred\+Func\+\_\+t}}
\index{le\+\_\+event\+\_\+\+Deferred\+Func\+\_\+t@{le\+\_\+event\+\_\+\+Deferred\+Func\+\_\+t}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Deferred\+Func\+\_\+t}{le_event_DeferredFunc_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf void}($\ast$ le\+\_\+event\+\_\+\+Deferred\+Func\+\_\+t) ({\bf void} $\ast$param1\+Ptr, {\bf void} $\ast$param2\+Ptr)}\hypertarget{le__event_loop_8h_a6f86581d4d2bf24647d5efaff1046d5d}{}\label{le__event_loop_8h_a6f86581d4d2bf24647d5efaff1046d5d}
Prototype for deferred functions look like this\+: 
\begin{DoxyParams}{Parameters}
{\em param1\+Ptr} & \mbox{[}in\mbox{]} Value passed in as param1\+Ptr to \hyperlink{le__event_loop_8h_a6dcc88f96060c5bc107a81a978132f38}{le\+\_\+event\+\_\+\+Queue\+Function()}. \\
\hline
{\em param2\+Ptr} & \mbox{[}in\mbox{]} Value passed in as param2\+Ptr to \hyperlink{le__event_loop_8h_a6dcc88f96060c5bc107a81a978132f38}{le\+\_\+event\+\_\+\+Queue\+Function()}.\\
\hline
\end{DoxyParams}
See \hyperlink{c_eventLoop_c_event_deferredFunctionCalls}{Deferred Function Calls} for more information. \index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Handler\+Func\+\_\+t@{le\+\_\+event\+\_\+\+Handler\+Func\+\_\+t}}
\index{le\+\_\+event\+\_\+\+Handler\+Func\+\_\+t@{le\+\_\+event\+\_\+\+Handler\+Func\+\_\+t}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Handler\+Func\+\_\+t}{le_event_HandlerFunc_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf void}($\ast$ le\+\_\+event\+\_\+\+Handler\+Func\+\_\+t) ({\bf void} $\ast$report\+Ptr)}\hypertarget{le__event_loop_8h_ada421dec46f51fcb3421ef7058f16944}{}\label{le__event_loop_8h_ada421dec46f51fcb3421ef7058f16944}
Prototype for publish-\/subscribe event handler functions look like this\+:


\begin{DoxyParams}{Parameters}
{\em report\+Ptr} & \mbox{[}in\mbox{]} Pointer to the event report payload.\\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
The report\+Ptr is only valid until the handler function returns. 
\end{DoxyWarning}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t@{le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t}}
\index{le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t@{le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t}{le_event_HandlerRef_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct le\+\_\+event\+\_\+\+Handler$\ast$ {\bf le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t}}\hypertarget{le__event_loop_8h_ae7ab96b8e3441b3d484fcf52aa7a9dad}{}\label{le__event_loop_8h_ae7ab96b8e3441b3d484fcf52aa7a9dad}
Handler reference.

Used to refer to handlers that have been added for events. Only needed if you want to set the handler\textquotesingle{}s context pointer or need to remove the handler later. \index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Id\+\_\+t@{le\+\_\+event\+\_\+\+Id\+\_\+t}}
\index{le\+\_\+event\+\_\+\+Id\+\_\+t@{le\+\_\+event\+\_\+\+Id\+\_\+t}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Id\+\_\+t}{le_event_Id_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct le\+\_\+event\+\_\+\+Id$\ast$ {\bf le\+\_\+event\+\_\+\+Id\+\_\+t}}\hypertarget{le__event_loop_8h_ae6e351b38bc95954f159d16d19d2d55c}{}\label{le__event_loop_8h_ae6e351b38bc95954f159d16d19d2d55c}
Event ID.

An Event ID ties event reports to event handlers. See \hyperlink{c_eventLoop_c_event_publishSubscribe}{Publish-\/\+Subscribe Events} for more details. \index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Layered\+Handler\+Func\+\_\+t@{le\+\_\+event\+\_\+\+Layered\+Handler\+Func\+\_\+t}}
\index{le\+\_\+event\+\_\+\+Layered\+Handler\+Func\+\_\+t@{le\+\_\+event\+\_\+\+Layered\+Handler\+Func\+\_\+t}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Layered\+Handler\+Func\+\_\+t}{le_event_LayeredHandlerFunc_t}}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf void}($\ast$ le\+\_\+event\+\_\+\+Layered\+Handler\+Func\+\_\+t) ({\bf void} $\ast$report\+Ptr, {\bf void} $\ast$second\+Layer\+Func)}\hypertarget{le__event_loop_8h_a325afcc96343fde371e4c63639ace2ef}{}\label{le__event_loop_8h_a325afcc96343fde371e4c63639ace2ef}
Prototype for the first layer of a layered publish-\/subscribe event handler function look like this\+:


\begin{DoxyParams}{Parameters}
{\em report\+Ptr} & \mbox{[}in\mbox{]} Pointer to the event report payload.\\
\hline
{\em second\+Layer\+Func} & \mbox{[}in\mbox{]} Address of the second layer handler function.\\
\hline
\end{DoxyParams}
\begin{DoxyWarning}{Warning}
The report\+Ptr is only valid until the handler function returns. 
\end{DoxyWarning}


\subsection{Function Documentation}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Add\+Handler@{le\+\_\+event\+\_\+\+Add\+Handler}}
\index{le\+\_\+event\+\_\+\+Add\+Handler@{le\+\_\+event\+\_\+\+Add\+Handler}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Add\+Handler(const char $\ast$name, le\+\_\+event\+\_\+\+Id\+\_\+t event\+Id, le\+\_\+event\+\_\+\+Handler\+Func\+\_\+t handler\+Func)}{le_event_AddHandler(const char *name, le_event_Id_t eventId, le_event_HandlerFunc_t handlerFunc)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t} le\+\_\+event\+\_\+\+Add\+Handler (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{name, }
\item[{{\bf le\+\_\+event\+\_\+\+Id\+\_\+t}}]{event\+Id, }
\item[{{\bf le\+\_\+event\+\_\+\+Handler\+Func\+\_\+t}}]{handler\+Func}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_ae65a65b4111618f47d7e6d57a48289e5}{}\label{le__event_loop_8h_ae65a65b4111618f47d7e6d57a48289e5}
Adds a handler function for a publish-\/subscribe event ID.

Tells the calling thread event loop to call a specified handler function when a defined event reaches the front of the event queue.

\begin{DoxyReturn}{Returns}
Handler reference, only needed to remove the handler (using \hyperlink{event_loop_8c_ae31a85d4acbef72451b5411a613eea58}{le\+\_\+event\+\_\+\+Remove\+Handler()} ). Can be ignored if the handler will never be removed.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Doesn\textquotesingle{}t return on failure, there\textquotesingle{}s no need to check the return value for errors.
\end{DoxyNote}
Adds a handler function for a publish-\/subscribe event ID.

Tells the calling thread\textquotesingle{}s event loop to call a given handler function when a given event reaches the front of the event queue.

\begin{DoxyReturn}{Returns}
A handler reference, which is only needed for later removal of the handler (using \hyperlink{event_loop_8c_ae31a85d4acbef72451b5411a613eea58}{le\+\_\+event\+\_\+\+Remove\+Handler()} ). Can be ignored if the handler will never be removed.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Doesn\textquotesingle{}t return on failure, so there\textquotesingle{}s no need to check the return value for errors. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em name} & The name of the handler. \\
\hline
\mbox{\tt in}  & {\em event\+Id} & The event ID. \\
\hline
\mbox{\tt in}  & {\em handler\+Func} & Handler function. \\
\hline
\end{DoxyParams}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Add\+Layered\+Handler@{le\+\_\+event\+\_\+\+Add\+Layered\+Handler}}
\index{le\+\_\+event\+\_\+\+Add\+Layered\+Handler@{le\+\_\+event\+\_\+\+Add\+Layered\+Handler}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Add\+Layered\+Handler(const char $\ast$name, le\+\_\+event\+\_\+\+Id\+\_\+t event\+Id, le\+\_\+event\+\_\+\+Layered\+Handler\+Func\+\_\+t first\+Layer\+Func, void $\ast$second\+Layer\+Func)}{le_event_AddLayeredHandler(const char *name, le_event_Id_t eventId, le_event_LayeredHandlerFunc_t firstLayerFunc, void *secondLayerFunc)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t} le\+\_\+event\+\_\+\+Add\+Layered\+Handler (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{name, }
\item[{{\bf le\+\_\+event\+\_\+\+Id\+\_\+t}}]{event\+Id, }
\item[{{\bf le\+\_\+event\+\_\+\+Layered\+Handler\+Func\+\_\+t}}]{first\+Layer\+Func, }
\item[{{\bf void} $\ast$}]{second\+Layer\+Func}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_a8b906d38935f64953482f42c745e1c18}{}\label{le__event_loop_8h_a8b906d38935f64953482f42c745e1c18}
Adds a layered handler function for a publish-\/subscribe event ID.

Tells the calling thread event loop to call a specified handler function when a defined event reaches the front of the event queue. Passes the required handler functions when called.

This is intended for use in implementing \hyperlink{c_eventLoop_c_event_layeredPublishSubscribe}{Layered Publish-\/\+Subscribe Handlers}.

\begin{DoxyReturn}{Returns}
Handler reference, only needed for later removal of the handler (using \hyperlink{event_loop_8c_ae31a85d4acbef72451b5411a613eea58}{le\+\_\+event\+\_\+\+Remove\+Handler()} ). Can be ignored if the handler will never be removed.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Doesn\textquotesingle{}t return on failure, there\textquotesingle{}s no need to check the return value for errors.
\end{DoxyNote}
Adds a layered handler function for a publish-\/subscribe event ID.

Tells the calling thread\textquotesingle{}s event loop to call a given handler function when a given event reaches the front of the event queue. Passes another handler function to that handler function when it is called.

This is intended for use in implementing c\+\_\+event\+\_\+\+Layered\+Handlers.

\begin{DoxyReturn}{Returns}
A handler reference, which is only needed for later removal of the handler (using \hyperlink{event_loop_8c_ae31a85d4acbef72451b5411a613eea58}{le\+\_\+event\+\_\+\+Remove\+Handler()} ). Can be ignored if the handler will never be removed.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Doesn\textquotesingle{}t return on failure, so there\textquotesingle{}s no need to check the return value for errors. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em name} & The name of the handler. \\
\hline
\mbox{\tt in}  & {\em event\+Id} & The event ID. \\
\hline
\mbox{\tt in}  & {\em first\+Layer\+Func} & Pointer to first-\/layer handler func. \\
\hline
\mbox{\tt in}  & {\em second\+Layer\+Func} & Pointer to second-\/layer handler func. \\
\hline
\end{DoxyParams}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Create\+Id@{le\+\_\+event\+\_\+\+Create\+Id}}
\index{le\+\_\+event\+\_\+\+Create\+Id@{le\+\_\+event\+\_\+\+Create\+Id}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Create\+Id(const char $\ast$name, size\+\_\+t payload\+Size)}{le_event_CreateId(const char *name, size_t payloadSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+event\+\_\+\+Id\+\_\+t} le\+\_\+event\+\_\+\+Create\+Id (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{name, }
\item[{size\+\_\+t}]{payload\+Size}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_a41a96eb3affb07184b519164cf54e213}{}\label{le__event_loop_8h_a41a96eb3affb07184b519164cf54e213}
Create a new event ID.

\begin{DoxyReturn}{Returns}
Event ID.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Doesn\textquotesingle{}t return on failure, there\textquotesingle{}s no need to check the return value for errors.
\end{DoxyNote}
Create a new event ID.

\begin{DoxyReturn}{Returns}
Event ID.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Doesn\textquotesingle{}t return on failure, so there\textquotesingle{}s no need to check the return value for errors. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em name} & Name of the event ID. (Named for diagnostic purposes.) \\
\hline
\mbox{\tt in}  & {\em payload\+Size} & Data payload size (in bytes) of the event reports (can be 0). \\
\hline
\end{DoxyParams}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Create\+Id\+With\+Ref\+Counting@{le\+\_\+event\+\_\+\+Create\+Id\+With\+Ref\+Counting}}
\index{le\+\_\+event\+\_\+\+Create\+Id\+With\+Ref\+Counting@{le\+\_\+event\+\_\+\+Create\+Id\+With\+Ref\+Counting}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Create\+Id\+With\+Ref\+Counting(const char $\ast$name)}{le_event_CreateIdWithRefCounting(const char *name)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+event\+\_\+\+Id\+\_\+t} le\+\_\+event\+\_\+\+Create\+Id\+With\+Ref\+Counting (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{name}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_a31bef8276ad0e911fd84fb710d58ca2b}{}\label{le__event_loop_8h_a31bef8276ad0e911fd84fb710d58ca2b}
Create a new event ID to report events where the payload is a pointer to a reference-\/counted memory pool object allocated using the \hyperlink{c_memory}{Dynamic Memory Allocation A\+PI}.

\begin{DoxyReturn}{Returns}
Event ID.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Doesn\textquotesingle{}t return on failure, there\textquotesingle{}s no need to check the return value for errors.
\end{DoxyNote}
Create a new event ID that can be used to report events whose payload is a pointer to a reference-\/counted memory pool object that was allocated using the \hyperlink{c_memory}{Dynamic Memory Allocation A\+PI}.

\begin{DoxyReturn}{Returns}
Event ID.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Doesn\textquotesingle{}t return on failure, so there\textquotesingle{}s no need to check the return value for errors. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em name} & Name of the event ID. (Named for diagnostic purposes.) \\
\hline
\end{DoxyParams}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Get\+Context\+Ptr@{le\+\_\+event\+\_\+\+Get\+Context\+Ptr}}
\index{le\+\_\+event\+\_\+\+Get\+Context\+Ptr@{le\+\_\+event\+\_\+\+Get\+Context\+Ptr}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Get\+Context\+Ptr(void)}{le_event_GetContextPtr(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void}$\ast$ le\+\_\+event\+\_\+\+Get\+Context\+Ptr (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_a1c73916295cc9e17af07e02756aa86c9}{}\label{le__event_loop_8h_a1c73916295cc9e17af07e02756aa86c9}
Fetches the context pointer for the currently running event handler.

Can only be called from within an event handler function.

\begin{DoxyReturn}{Returns}
Context pointer that was set using \hyperlink{event_loop_8c_ae0c4307a9715794c720e525032aa0bfd}{le\+\_\+event\+\_\+\+Set\+Context\+Ptr()}, or N\+U\+LL if \hyperlink{event_loop_8c_ae0c4307a9715794c720e525032aa0bfd}{le\+\_\+event\+\_\+\+Set\+Context\+Ptr()} was not called.
\end{DoxyReturn}
Fetches the context pointer for the currently running event handler.

Can only be called from within an event handler function.

\begin{DoxyReturn}{Returns}
The context pointer that was provided when the event handler was \char`\"{}added\char`\"{}. 
\end{DoxyReturn}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Get\+Fd@{le\+\_\+event\+\_\+\+Get\+Fd}}
\index{le\+\_\+event\+\_\+\+Get\+Fd@{le\+\_\+event\+\_\+\+Get\+Fd}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Get\+Fd(void)}{le_event_GetFd(void)}}]{\setlength{\rightskip}{0pt plus 5cm}int le\+\_\+event\+\_\+\+Get\+Fd (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_a12ce7f92f4bc6f5167d5a6ef86d7d0b1}{}\label{le__event_loop_8h_a12ce7f92f4bc6f5167d5a6ef86d7d0b1}
Fetches a file descriptor that will appear readable to poll(), select(), epoll\+\_\+wait(), etc. when the calling thread\textquotesingle{}s Event Loop needs servicing (via a call to \hyperlink{event_loop_8c_a096222e98f6a0d92a79722018a752b58}{le\+\_\+event\+\_\+\+Service\+Loop()}).

\begin{DoxyWarning}{Warning}
Only intended for use when integrating with legacy P\+O\+S\+I\+X-\/based software that cannot be easily refactored to use the Legato Event Loop. The preferred approach is to call \hyperlink{event_loop_8c_ae313b457994371c658be9fe0494a01ff}{le\+\_\+event\+\_\+\+Run\+Loop()}.
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
The file descriptor.
\end{DoxyReturn}
Fetches a file descriptor that will appear readable to poll() and select() when the calling thread\textquotesingle{}s Event Loop needs servicing (via a call to \hyperlink{event_loop_8c_a096222e98f6a0d92a79722018a752b58}{le\+\_\+event\+\_\+\+Service\+Loop()}).

\begin{DoxyWarning}{Warning}
This function is only intended for use when integrating with legacy P\+O\+S\+I\+X-\/based software that cannot be easily refactored to use the Legato Event Loop. The preferred approach is to call \hyperlink{event_loop_8c_ae313b457994371c658be9fe0494a01ff}{le\+\_\+event\+\_\+\+Run\+Loop()}.
\end{DoxyWarning}
\begin{DoxyReturn}{Returns}
The file descriptor. 
\end{DoxyReturn}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Queue\+Function@{le\+\_\+event\+\_\+\+Queue\+Function}}
\index{le\+\_\+event\+\_\+\+Queue\+Function@{le\+\_\+event\+\_\+\+Queue\+Function}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Queue\+Function(le\+\_\+event\+\_\+\+Deferred\+Func\+\_\+t func, void $\ast$param1\+Ptr, void $\ast$param2\+Ptr)}{le_event_QueueFunction(le_event_DeferredFunc_t func, void *param1Ptr, void *param2Ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+event\+\_\+\+Queue\+Function (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+event\+\_\+\+Deferred\+Func\+\_\+t}}]{func, }
\item[{{\bf void} $\ast$}]{param1\+Ptr, }
\item[{{\bf void} $\ast$}]{param2\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_a6dcc88f96060c5bc107a81a978132f38}{}\label{le__event_loop_8h_a6dcc88f96060c5bc107a81a978132f38}
Queue a function onto the calling thread\textquotesingle{}s Event Queue. When it reaches the head of the Event Queue, it will be called by the calling thread\textquotesingle{}s Event Loop. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em func} & The function to be called later. \\
\hline
\mbox{\tt in}  & {\em param1\+Ptr} & Value to be passed to the function when called. \\
\hline
\mbox{\tt in}  & {\em param2\+Ptr} & Value to be passed to the function when called. \\
\hline
\end{DoxyParams}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Queue\+Function\+To\+Thread@{le\+\_\+event\+\_\+\+Queue\+Function\+To\+Thread}}
\index{le\+\_\+event\+\_\+\+Queue\+Function\+To\+Thread@{le\+\_\+event\+\_\+\+Queue\+Function\+To\+Thread}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Queue\+Function\+To\+Thread(le\+\_\+thread\+\_\+\+Ref\+\_\+t thread, le\+\_\+event\+\_\+\+Deferred\+Func\+\_\+t func, void $\ast$param1\+Ptr, void $\ast$param2\+Ptr)}{le_event_QueueFunctionToThread(le_thread_Ref_t thread, le_event_DeferredFunc_t func, void *param1Ptr, void *param2Ptr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+event\+\_\+\+Queue\+Function\+To\+Thread (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+thread\+\_\+\+Ref\+\_\+t}}]{thread, }
\item[{{\bf le\+\_\+event\+\_\+\+Deferred\+Func\+\_\+t}}]{func, }
\item[{{\bf void} $\ast$}]{param1\+Ptr, }
\item[{{\bf void} $\ast$}]{param2\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_a228da2d1f53ffa74517f108b0dcfa4d9}{}\label{le__event_loop_8h_a228da2d1f53ffa74517f108b0dcfa4d9}
Queue a function onto a specific thread\textquotesingle{}s Event Queue. When it reaches the head of that Event Queue, it will be called by that thread\textquotesingle{}s Event Loop. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em thread} & The thread to queue the function to. \\
\hline
\mbox{\tt in}  & {\em func} & The function. \\
\hline
\mbox{\tt in}  & {\em param1\+Ptr} & Value to be passed to the function when called. \\
\hline
\mbox{\tt in}  & {\em param2\+Ptr} & Value to be passed to the function when called. \\
\hline
\end{DoxyParams}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Remove\+Handler@{le\+\_\+event\+\_\+\+Remove\+Handler}}
\index{le\+\_\+event\+\_\+\+Remove\+Handler@{le\+\_\+event\+\_\+\+Remove\+Handler}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Remove\+Handler(le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t handler\+Ref)}{le_event_RemoveHandler(le_event_HandlerRef_t handlerRef)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+event\+\_\+\+Remove\+Handler (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t}}]{handler\+Ref}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_ae31a85d4acbef72451b5411a613eea58}{}\label{le__event_loop_8h_ae31a85d4acbef72451b5411a613eea58}
Remove Handler

Removes a previously added event handler function. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handler\+Ref} & Handler reference. \\
\hline
\end{DoxyParams}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Report@{le\+\_\+event\+\_\+\+Report}}
\index{le\+\_\+event\+\_\+\+Report@{le\+\_\+event\+\_\+\+Report}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Report(le\+\_\+event\+\_\+\+Id\+\_\+t event\+Id, void $\ast$payload\+Ptr, size\+\_\+t payload\+Size)}{le_event_Report(le_event_Id_t eventId, void *payloadPtr, size_t payloadSize)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+event\+\_\+\+Report (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+event\+\_\+\+Id\+\_\+t}}]{event\+Id, }
\item[{{\bf void} $\ast$}]{payload\+Ptr, }
\item[{size\+\_\+t}]{payload\+Size}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_ae3ffe6990b70fb572b4eef06739b4f54}{}\label{le__event_loop_8h_ae3ffe6990b70fb572b4eef06739b4f54}
Report an Event

Queues an Event Report to any and all event loops that have handlers for that event.

\begin{DoxyNote}{Note}
Copies the event report payload, so it is safe to release or reuse the buffer that payload\+Ptr points to as soon as \hyperlink{event_loop_8c_ae3ffe6990b70fb572b4eef06739b4f54}{le\+\_\+event\+\_\+\+Report()} returns.
\end{DoxyNote}
Report an Event

Queues an Event Report to any and all event loops that have handlers for that event.

\begin{DoxyNote}{Note}
This copies the event report payload, so it is safe to release or reuse the buffer that payload\+Ptr points to as soon as \hyperlink{event_loop_8c_ae3ffe6990b70fb572b4eef06739b4f54}{le\+\_\+event\+\_\+\+Report()} returns. 
\end{DoxyNote}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em event\+Id} & The event ID. \\
\hline
\mbox{\tt in}  & {\em payload\+Ptr} & Pointer to the payload bytes to be copied into the report. \\
\hline
\mbox{\tt in}  & {\em payload\+Size} & The number of bytes of payload to copy into the report. \\
\hline
\end{DoxyParams}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Report\+With\+Ref\+Counting@{le\+\_\+event\+\_\+\+Report\+With\+Ref\+Counting}}
\index{le\+\_\+event\+\_\+\+Report\+With\+Ref\+Counting@{le\+\_\+event\+\_\+\+Report\+With\+Ref\+Counting}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Report\+With\+Ref\+Counting(le\+\_\+event\+\_\+\+Id\+\_\+t event\+Id, void $\ast$object\+Ptr)}{le_event_ReportWithRefCounting(le_event_Id_t eventId, void *objectPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+event\+\_\+\+Report\+With\+Ref\+Counting (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+event\+\_\+\+Id\+\_\+t}}]{event\+Id, }
\item[{{\bf void} $\ast$}]{object\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_af0277165493b512216fabb6086ec7d9c}{}\label{le__event_loop_8h_af0277165493b512216fabb6086ec7d9c}
Sends an Event Report with a pointer to a reference-\/counted object as its payload. The pointer must have been obtained from a memory pool using the \hyperlink{c_memory}{Dynamic Memory Allocation A\+PI}.

Calling this function passes ownership of the reference to the Event Loop A\+PI. The Event Loop A\+PI will ensure that the reference is properly counted while it passes through the event report dispatching system. Each handler will receive one counted reference to the object, so the handler is responsible for releasing the object when it is finished with it.

Sends an Event Report with a pointer to a reference-\/counted object as its payload. The pointer must have been obtained from a memory pool using the \hyperlink{c_memory}{Dynamic Memory Allocation A\+PI}.

The Event Loop A\+PI will ensure that the reference is properly counted while it passes through the event report dispatching system. Each handler will receive one counted reference to the object, which the handler will then be responsible for releasing. Do not release the reference that you pass into \hyperlink{event_loop_8c_af0277165493b512216fabb6086ec7d9c}{le\+\_\+event\+\_\+\+Report\+With\+Ref\+Counting()}. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em event\+Id} & The event ID. \\
\hline
\mbox{\tt in}  & {\em object\+Ptr} & Pointer to an object allocated from a memory pool (using the \hyperlink{c_memory}{Dynamic Memory Allocation A\+PI}). \\
\hline
\end{DoxyParams}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Run\+Loop@{le\+\_\+event\+\_\+\+Run\+Loop}}
\index{le\+\_\+event\+\_\+\+Run\+Loop@{le\+\_\+event\+\_\+\+Run\+Loop}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Run\+Loop(void)}{le_event_RunLoop(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+event\+\_\+\+Run\+Loop (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_ae313b457994371c658be9fe0494a01ff}{}\label{le__event_loop_8h_ae313b457994371c658be9fe0494a01ff}
Runs the event loop for the calling thread.

This starts processing events by the calling thread.

Can only be called once for each thread, and must never be called in the process\textquotesingle{}s main thread.

\begin{DoxyNote}{Note}
Function never returns.
\end{DoxyNote}
Runs the event loop for the calling thread.

This starts the processing of events by the calling thread.

This function can only be called at most once for each thread, and must never be called in the process\textquotesingle{}s main thread.

\begin{DoxyNote}{Note}
This function never returns. 
\end{DoxyNote}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Service\+Loop@{le\+\_\+event\+\_\+\+Service\+Loop}}
\index{le\+\_\+event\+\_\+\+Service\+Loop@{le\+\_\+event\+\_\+\+Service\+Loop}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Service\+Loop(void)}{le_event_ServiceLoop(void)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf le\+\_\+result\+\_\+t} le\+\_\+event\+\_\+\+Service\+Loop (
\begin{DoxyParamCaption}
\item[{{\bf void}}]{}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_a096222e98f6a0d92a79722018a752b58}{}\label{le__event_loop_8h_a096222e98f6a0d92a79722018a752b58}
Services the calling thread\textquotesingle{}s Event Loop.

\begin{DoxyWarning}{Warning}
Only intended for use when integrating with legacy P\+O\+S\+I\+X-\/based software that can\textquotesingle{}t be easily refactored to use the Legato Event Loop. The preferred approach is to call \hyperlink{event_loop_8c_ae313b457994371c658be9fe0494a01ff}{le\+\_\+event\+\_\+\+Run\+Loop()}.
\end{DoxyWarning}
See also\+: \hyperlink{event_loop_8c_a12ce7f92f4bc6f5167d5a6ef86d7d0b1}{le\+\_\+event\+\_\+\+Get\+Fd()}.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if there is more to be done. DO N\+OT GO B\+A\+CK TO S\+L\+E\+EP without calling \hyperlink{event_loop_8c_a096222e98f6a0d92a79722018a752b58}{le\+\_\+event\+\_\+\+Service\+Loop()} again.
\item L\+E\+\_\+\+W\+O\+U\+L\+D\+\_\+\+B\+L\+O\+CK if there is nothing left to do for now and it is safe to go back to sleep.
\end{DoxyItemize}
\end{DoxyReturn}
Services the calling thread\textquotesingle{}s Event Loop.

\begin{DoxyWarning}{Warning}
This function is only intended for use when integrating with legacy P\+O\+S\+I\+X-\/based software that cannot be easily refactored to use the Legato Event Loop. The preferred approach is to call \hyperlink{event_loop_8c_ae313b457994371c658be9fe0494a01ff}{le\+\_\+event\+\_\+\+Run\+Loop()}.
\end{DoxyWarning}
See also\+: \hyperlink{event_loop_8c_a12ce7f92f4bc6f5167d5a6ef86d7d0b1}{le\+\_\+event\+\_\+\+Get\+Fd()}.

\begin{DoxyReturn}{Returns}

\begin{DoxyItemize}
\item L\+E\+\_\+\+OK if there is more to be done.
\item L\+E\+\_\+\+W\+O\+U\+L\+D\+\_\+\+B\+L\+O\+CK if there were no events to process. 
\end{DoxyItemize}
\end{DoxyReturn}
\index{le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}!le\+\_\+event\+\_\+\+Set\+Context\+Ptr@{le\+\_\+event\+\_\+\+Set\+Context\+Ptr}}
\index{le\+\_\+event\+\_\+\+Set\+Context\+Ptr@{le\+\_\+event\+\_\+\+Set\+Context\+Ptr}!le\+\_\+event\+Loop.\+h@{le\+\_\+event\+Loop.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+event\+\_\+\+Set\+Context\+Ptr(le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t handler\+Ref, void $\ast$context\+Ptr)}{le_event_SetContextPtr(le_event_HandlerRef_t handlerRef, void *contextPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} le\+\_\+event\+\_\+\+Set\+Context\+Ptr (
\begin{DoxyParamCaption}
\item[{{\bf le\+\_\+event\+\_\+\+Handler\+Ref\+\_\+t}}]{handler\+Ref, }
\item[{{\bf void} $\ast$}]{context\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__event_loop_8h_ae0c4307a9715794c720e525032aa0bfd}{}\label{le__event_loop_8h_ae0c4307a9715794c720e525032aa0bfd}
Sets the context pointer for a given event handler.

This can later be retrieved using \hyperlink{le__event_loop_8h_a1c73916295cc9e17af07e02756aa86c9}{le\+\_\+event\+\_\+\+Get\+Context\+Ptr()} from within the handler function when it is called. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em handler\+Ref} & Handler whose context pointer is to be set. \\
\hline
\mbox{\tt in}  & {\em context\+Ptr} & Context pointer value. \\
\hline
\end{DoxyParams}
