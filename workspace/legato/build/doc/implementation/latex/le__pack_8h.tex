\hypertarget{le__pack_8h}{}\section{framework/include/le\+\_\+pack.h File Reference}
\label{le__pack_8h}\index{framework/include/le\+\_\+pack.\+h@{framework/include/le\+\_\+pack.\+h}}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{le__pack_8h_a6e3dcf20abe5e8e3762ace1f37756dcd}{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE}(value)
\item 
\#define \hyperlink{le__pack_8h_a02f51f8337eb3ee165f3ae42a836c8ed}{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+A\+R\+R\+AY}(buffer\+Ptr, size\+Ptr, array\+Ptr, array\+Count, array\+Max\+Count, pack\+Func, result\+Ptr)
\item 
\#define \hyperlink{le__pack_8h_a84fef29cc3d953ebeb007500742e4be6}{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE}(value\+Ptr)
\item 
\#define \hyperlink{le__pack_8h_a3f883217eec8aee69536751ea52ccdec}{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+A\+R\+R\+AY}(buffer\+Ptr, size\+Ptr, array\+Ptr, array\+Count\+Ptr, array\+Max\+Count, unpack\+Func, result\+Ptr)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{le__pack_8h_a3fd9b6634bd102bab44b4828546fef04}{le\+\_\+pack\+\_\+\+Pack\+Uint8} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint8\+\_\+t value)
\item 
static bool \hyperlink{le__pack_8h_acc4f02f9075ef95cbe9fa8c3c82bdd15}{le\+\_\+pack\+\_\+\+Pack\+Uint16} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint16\+\_\+t value)
\item 
static bool \hyperlink{le__pack_8h_aaccae2e8f6f8c35a74dea6d093390e7b}{le\+\_\+pack\+\_\+\+Pack\+Uint32} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint32\+\_\+t value)
\item 
static bool \hyperlink{le__pack_8h_ac043b09c0a0fe06ec8197ad57c7ae95d}{le\+\_\+pack\+\_\+\+Pack\+Uint64} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint64\+\_\+t value)
\item 
static bool \hyperlink{le__pack_8h_ac2d743bd159eb176795b833307411ce0}{le\+\_\+pack\+\_\+\+Pack\+Int8} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int8\+\_\+t value)
\item 
static bool \hyperlink{le__pack_8h_a7f501c624043ae6eed9e57cd843b3b09}{le\+\_\+pack\+\_\+\+Pack\+Int16} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int16\+\_\+t value)
\item 
static bool \hyperlink{le__pack_8h_ae4008bb553d9c76db4b067e61c7bfe9a}{le\+\_\+pack\+\_\+\+Pack\+Int32} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int32\+\_\+t value)
\item 
static bool \hyperlink{le__pack_8h_a510e7de2b77da44d375ccc7803799b67}{le\+\_\+pack\+\_\+\+Pack\+Int64} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int64\+\_\+t value)
\item 
static bool \hyperlink{le__pack_8h_a3f3793e8d3354605ee11180a54d0685b}{le\+\_\+pack\+\_\+\+Pack\+Size} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, size\+\_\+t value)
\item 
static bool \hyperlink{le__pack_8h_a4598d738c462e6916597a52f1bab19d9}{le\+\_\+pack\+\_\+\+Pack\+Bool} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, bool value)
\item 
static bool \hyperlink{le__pack_8h_adaf5c4a5f73950a6e54e10dfed0b5835}{le\+\_\+pack\+\_\+\+Pack\+Char} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, char value)
\item 
static bool \hyperlink{le__pack_8h_a5e3dc79f7527ebb131bf9a48bcdac8b5}{le\+\_\+pack\+\_\+\+Pack\+Double} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, double value)
\item 
static bool \hyperlink{le__pack_8h_ad47f59c8e02a25b5a4d17bb3071c64ca}{le\+\_\+pack\+\_\+\+Pack\+Result} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, \hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} value)
\item 
static bool \hyperlink{le__pack_8h_a3a9b13afab21da57b6e906114352972d}{le\+\_\+pack\+\_\+\+Pack\+On\+Off} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, \hyperlink{le__basics_8h_ae2138c90c41d30e2d510be01d8b374da}{le\+\_\+onoff\+\_\+t} value)
\item 
static bool \hyperlink{le__pack_8h_a9bec119cc87fdc9278e5a406bb1faf73}{le\+\_\+pack\+\_\+\+Pack\+Reference} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ref)
\item 
static bool \hyperlink{le__pack_8h_a99592e97d04c1c8be2870f0c3fcc36a2}{le\+\_\+pack\+\_\+\+Pack\+String} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, const char $\ast$string\+Ptr, uint32\+\_\+t max\+String\+Count)
\item 
static bool \hyperlink{le__pack_8h_aacd64e8aa29070451a0b3687f5c8afa1}{le\+\_\+pack\+\_\+\+Pack\+Array\+Header} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$array\+Ptr, size\+\_\+t element\+Size, size\+\_\+t array\+Count, size\+\_\+t array\+Max\+Count)
\item 
static bool \hyperlink{le__pack_8h_afc88f6def28cdddce70672d3f9730032}{le\+\_\+pack\+\_\+\+Unpack\+Uint8} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint8\+\_\+t $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_a4afb705a1c791b41ca4c3240a4144d81}{le\+\_\+pack\+\_\+\+Unpack\+Uint16} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint16\+\_\+t $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_a351b48f9f4602a2374862fede224aaa3}{le\+\_\+pack\+\_\+\+Unpack\+Uint32} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint32\+\_\+t $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_a92cc79f11f06664ef1e3ad60906d7ca2}{le\+\_\+pack\+\_\+\+Unpack\+Uint64} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint64\+\_\+t $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_a2c6301f685909467d3ae32bcdc1c6ea7}{le\+\_\+pack\+\_\+\+Unpack\+Int8} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int8\+\_\+t $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_a1336796e47d7dbfaf3cad4880f89b6b5}{le\+\_\+pack\+\_\+\+Unpack\+Int16} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int16\+\_\+t $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_a68d77fadedff8ce202cc00d4d0645ddb}{le\+\_\+pack\+\_\+\+Unpack\+Int32} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int32\+\_\+t $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_a928f0e54371ac56476275c0d087367af}{le\+\_\+pack\+\_\+\+Unpack\+Int64} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int64\+\_\+t $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_ab6073919e830bf6c9cad6b2e6e18f65d}{le\+\_\+pack\+\_\+\+Unpack\+Size} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, size\+\_\+t $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_aa3cfe85dba2ad3a617ef0a3cdb6cc028}{le\+\_\+pack\+\_\+\+Unpack\+Bool} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, bool $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_a71f3a149fe113e4676c87636329836eb}{le\+\_\+pack\+\_\+\+Unpack\+Char} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, char $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_ae98ee0f0ada53b94b7924ccf34c4122e}{le\+\_\+pack\+\_\+\+Unpack\+Double} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, double $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_a3bea56e10b56419d1ccbec7dd63301b9}{le\+\_\+pack\+\_\+\+Unpack\+Result} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, \hyperlink{le__basics_8h_a1cca095ed6ebab24b57a636382a6c86c}{le\+\_\+result\+\_\+t} $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_a92fa35e40a34f09df7d01eb68d7ae52d}{le\+\_\+pack\+\_\+\+Unpack\+On\+Off} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, \hyperlink{le__basics_8h_ae2138c90c41d30e2d510be01d8b374da}{le\+\_\+onoff\+\_\+t} $\ast$value\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_a87b266af7445256a48b4eb3c4e386f44}{le\+\_\+pack\+\_\+\+Unpack\+Reference} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$ref\+Ptr)
\item 
static bool \hyperlink{le__pack_8h_aea4ba842e347564fb273ee103a831009}{le\+\_\+pack\+\_\+\+Unpack\+String} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, char $\ast$string\+Ptr, uint32\+\_\+t buffer\+Size, uint32\+\_\+t max\+String\+Count)
\item 
static bool \hyperlink{le__pack_8h_ab3c2cc5baf75940d1cc2c777a004b76f}{le\+\_\+pack\+\_\+\+Unpack\+Array\+Header} (uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, const \hyperlink{_t_e_m_p_l_a_t_e__cdef_8h_ac9c84fa68bbad002983e35ce3663c686}{void} $\ast$array\+Ptr, size\+\_\+t element\+Size, size\+\_\+t $\ast$array\+Count\+Ptr, size\+\_\+t array\+Max\+Count)
\end{DoxyCompactItemize}


\subsection{Macro Definition Documentation}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE@{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE}}
\index{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE@{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE}{LE_PACK_PACK_SIMPLE_VALUE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE(
\begin{DoxyParamCaption}
\item[{}]{value}
\end{DoxyParamCaption}
)}\hypertarget{le__pack_8h_a6e3dcf20abe5e8e3762ace1f37756dcd}{}\label{le__pack_8h_a6e3dcf20abe5e8e3762ace1f37756dcd}
{\bfseries Value\+:}
\begin{DoxyCode}
\textcolor{keywordflow}{if} (*sizePtr < \textcolor{keyword}{sizeof}(value))                      \(\backslash\)
    \{                                                  \(\backslash\)
        return \textcolor{keyword}{false};                                  \(\backslash\)
    \}                                                  \(\backslash\)
                                                       \(\backslash\)
    memcpy(*bufferPtr, &(value), \textcolor{keyword}{sizeof}(value));                \(\backslash\)
                                                                \(\backslash\)
    *bufferPtr = *bufferPtr + \textcolor{keyword}{sizeof}(value);                    \(\backslash\)
    *sizePtr -= \textcolor{keyword}{sizeof}(value);                                  \(\backslash\)
                                                                \(\backslash\)
    return \textcolor{keyword}{true}
\end{DoxyCode}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+A\+R\+R\+AY@{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+A\+R\+R\+AY}}
\index{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+A\+R\+R\+AY@{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+A\+R\+R\+AY}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+A\+R\+R\+AY}{LE_PACK_PACKARRAY}}]{\setlength{\rightskip}{0pt plus 5cm}\#define L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+A\+R\+R\+AY(
\begin{DoxyParamCaption}
\item[{}]{buffer\+Ptr, }
\item[{}]{size\+Ptr, }
\item[{}]{array\+Ptr, }
\item[{}]{array\+Count, }
\item[{}]{array\+Max\+Count, }
\item[{}]{pack\+Func, }
\item[{}]{result\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__pack_8h_a02f51f8337eb3ee165f3ae42a836c8ed}{}\label{le__pack_8h_a02f51f8337eb3ee165f3ae42a836c8ed}
{\bfseries Value\+:}
\begin{DoxyCode}
\textcolor{keywordflow}{do} \{                                                                \(\backslash\)
        *(resultPtr) = \hyperlink{le__pack_8h_aacd64e8aa29070451a0b3687f5c8afa1}{le\_pack\_PackArrayHeader}((bufferPtr), (sizePtr), \(\backslash\)
                                               (arrayPtr), \textcolor{keyword}{sizeof}((arrayPtr)[0]), \(\backslash\)
                                               (arrayCount), (arrayMaxCount)); \hyperlink{service_directory_8c_a1d84aa99c70d8cb8f479b606b96ae7e0}{\(\backslash\)}
\hyperlink{service_directory_8c_a1d84aa99c70d8cb8f479b606b96ae7e0}{        if} (*(resultPtr))                                               \(\backslash\)
        \{                                                               \(\backslash\)
            uint32\_t i;                                                 \(\backslash\)
            size\_t newSizePtr = *(sizePtr) - \textcolor{keyword}{sizeof}((arrayPtr)[0])*(arrayMaxCount); \(\backslash\)
            for (i = 0; i < (arrayCount); ++i)                          \(\backslash\)
            \{                                                           \hyperlink{le__log_8h_ac0dbbef91dc0fed449d0092ff0557b39}{\(\backslash\)}
\hyperlink{le__log_8h_ac0dbbef91dc0fed449d0092ff0557b39}{                LE\_ASSERT}(packFunc((bufferPtr), (sizePtr), (arrayPtr)[i])); \(\backslash\)
            \}                                                           \hyperlink{le__log_8h_ac0dbbef91dc0fed449d0092ff0557b39}{\(\backslash\)}
\hyperlink{le__log_8h_ac0dbbef91dc0fed449d0092ff0557b39}{            LE\_ASSERT}(*(sizePtr) >= newSizePtr);                        \(\backslash\)
            *(sizePtr) = newSizePtr;                                    \(\backslash\)
            *(resultPtr) = \textcolor{keyword}{true};                                        \(\backslash\)
        \}                                                               \(\backslash\)
    \} \textcolor{keywordflow}{while} (0)
\end{DoxyCode}
Pack an array into a buffer, incrementing the buffer pointer and decrementing the available size.

\begin{DoxyNote}{Note}
Always decrements available size according to the max possible size used, not actual size used. Will assert if provided string is larger than maximum allowable string. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE@{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE}}
\index{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE@{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE}{LE_PACK_UNPACK_SIMPLE_VALUE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+\_\+\+S\+I\+M\+P\+L\+E\+\_\+\+V\+A\+L\+UE(
\begin{DoxyParamCaption}
\item[{}]{value\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__pack_8h_a84fef29cc3d953ebeb007500742e4be6}{}\label{le__pack_8h_a84fef29cc3d953ebeb007500742e4be6}
{\bfseries Value\+:}
\begin{DoxyCode}
\textcolor{keywordflow}{if} (*sizePtr < \textcolor{keyword}{sizeof}(*(valuePtr)))                         \(\backslash\)
    \{                                                           \(\backslash\)
        return \textcolor{keyword}{false};                                           \(\backslash\)
    \}                                                           \(\backslash\)
                                                                \(\backslash\)
    memcpy((valuePtr), *bufferPtr, \textcolor{keyword}{sizeof}(*(valuePtr)));        \(\backslash\)
                                                                \(\backslash\)
    *bufferPtr = (*bufferPtr) + \textcolor{keyword}{sizeof}(*(valuePtr));            \(\backslash\)
    *sizePtr -= \textcolor{keyword}{sizeof}(*(valuePtr));                            \(\backslash\)
                                                                \(\backslash\)
    return \textcolor{keyword}{true}
\end{DoxyCode}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+A\+R\+R\+AY@{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+A\+R\+R\+AY}}
\index{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+A\+R\+R\+AY@{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+A\+R\+R\+AY}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+A\+R\+R\+AY}{LE_PACK_UNPACKARRAY}}]{\setlength{\rightskip}{0pt plus 5cm}\#define L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+U\+N\+P\+A\+C\+K\+A\+R\+R\+AY(
\begin{DoxyParamCaption}
\item[{}]{buffer\+Ptr, }
\item[{}]{size\+Ptr, }
\item[{}]{array\+Ptr, }
\item[{}]{array\+Count\+Ptr, }
\item[{}]{array\+Max\+Count, }
\item[{}]{unpack\+Func, }
\item[{}]{result\+Ptr}
\end{DoxyParamCaption}
)}\hypertarget{le__pack_8h_a3f883217eec8aee69536751ea52ccdec}{}\label{le__pack_8h_a3f883217eec8aee69536751ea52ccdec}
{\bfseries Value\+:}
\begin{DoxyCode}
\textcolor{keywordflow}{do} \{                                                                \hyperlink{service_directory_8c_a1d84aa99c70d8cb8f479b606b96ae7e0}{\(\backslash\)}
\hyperlink{service_directory_8c_a1d84aa99c70d8cb8f479b606b96ae7e0}{        if} (!\hyperlink{le__pack_8h_ab3c2cc5baf75940d1cc2c777a004b76f}{le\_pack\_UnpackArrayHeader}((bufferPtr), (sizePtr),          
       \(\backslash\)
                                       (arrayPtr), \textcolor{keyword}{sizeof}((arrayPtr)[0]), \(\backslash\)
                                       (arrayCountPtr), (arrayMaxCount))) \(\backslash\)
        \{                                                               \(\backslash\)
            *(resultPtr) = \textcolor{keyword}{false};                                       \(\backslash\)
        \}                                                               \hyperlink{supervisor_8c_a0544c3fe466e421738dae463968b70ba}{\(\backslash\)}
\hyperlink{supervisor_8c_a0544c3fe466e421738dae463968b70ba}{        else}                                                            \(\backslash\)
        \{                                                               \(\backslash\)
            uint32\_t i;                                                 \(\backslash\)
            size\_t newSizePtr = *(sizePtr) - \textcolor{keyword}{sizeof}((arrayPtr)[0])*(arrayMaxCount); \(\backslash\)
            for (i = 0; i < *(arrayCountPtr); ++i)                      \(\backslash\)
            \{                                                           \hyperlink{le__log_8h_ac0dbbef91dc0fed449d0092ff0557b39}{\(\backslash\)}
\hyperlink{le__log_8h_ac0dbbef91dc0fed449d0092ff0557b39}{                LE\_ASSERT}(unpackFunc((bufferPtr), (sizePtr), &(arrayPtr)[i])); \(\backslash\)
            \}                                                           \hyperlink{le__log_8h_ac0dbbef91dc0fed449d0092ff0557b39}{\(\backslash\)}
\hyperlink{le__log_8h_ac0dbbef91dc0fed449d0092ff0557b39}{            LE\_ASSERT}(*(sizePtr) >= newSizePtr);                        \(\backslash\)
            *(sizePtr) = newSizePtr;                                    \(\backslash\)
            *(resultPtr) = \textcolor{keyword}{true};                                        \(\backslash\)
        \}                                                               \(\backslash\)
    \} \textcolor{keywordflow}{while} (0)
\end{DoxyCode}
Unpack an array into from buffer, incrementing the buffer pointer and decrementing the available size.

\begin{DoxyNote}{Note}
Always decrements available size according to the max possible size used, not actual size used. Will assert if provided string is larger than maximum allowable string. 
\end{DoxyNote}


\subsection{Function Documentation}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Array\+Header@{le\+\_\+pack\+\_\+\+Pack\+Array\+Header}}
\index{le\+\_\+pack\+\_\+\+Pack\+Array\+Header@{le\+\_\+pack\+\_\+\+Pack\+Array\+Header}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Array\+Header(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, const void $\ast$array\+Ptr, size\+\_\+t element\+Size, size\+\_\+t array\+Count, size\+\_\+t array\+Max\+Count)}{le_pack_PackArrayHeader(uint8_t **bufferPtr, size_t *sizePtr, const void *arrayPtr, size_t elementSize, size_t arrayCount, size_t arrayMaxCount)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Array\+Header (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{const {\bf void} $\ast$}]{array\+Ptr, }
\item[{size\+\_\+t}]{element\+Size, }
\item[{size\+\_\+t}]{array\+Count, }
\item[{size\+\_\+t}]{array\+Max\+Count}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_aacd64e8aa29070451a0b3687f5c8afa1}{}\label{le__pack_8h_aacd64e8aa29070451a0b3687f5c8afa1}
Pack the size information for an array into a buffer, incrementing the buffer pointer and decrementing the available size.

\begin{DoxyNote}{Note}
Users of this A\+PI should generally use L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+A\+R\+R\+AY macro instead which also packs the array data. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Bool@{le\+\_\+pack\+\_\+\+Pack\+Bool}}
\index{le\+\_\+pack\+\_\+\+Pack\+Bool@{le\+\_\+pack\+\_\+\+Pack\+Bool}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Bool(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, bool value)}{le_pack_PackBool(uint8_t **bufferPtr, size_t *sizePtr, bool value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Bool (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{bool}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a4598d738c462e6916597a52f1bab19d9}{}\label{le__pack_8h_a4598d738c462e6916597a52f1bab19d9}
Pack a bool into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Char@{le\+\_\+pack\+\_\+\+Pack\+Char}}
\index{le\+\_\+pack\+\_\+\+Pack\+Char@{le\+\_\+pack\+\_\+\+Pack\+Char}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Char(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, char value)}{le_pack_PackChar(uint8_t **bufferPtr, size_t *sizePtr, char value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Char (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{char}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_adaf5c4a5f73950a6e54e10dfed0b5835}{}\label{le__pack_8h_adaf5c4a5f73950a6e54e10dfed0b5835}
Pack a char into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Double@{le\+\_\+pack\+\_\+\+Pack\+Double}}
\index{le\+\_\+pack\+\_\+\+Pack\+Double@{le\+\_\+pack\+\_\+\+Pack\+Double}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Double(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, double value)}{le_pack_PackDouble(uint8_t **bufferPtr, size_t *sizePtr, double value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Double (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{double}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a5e3dc79f7527ebb131bf9a48bcdac8b5}{}\label{le__pack_8h_a5e3dc79f7527ebb131bf9a48bcdac8b5}
Pack a double into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Int16@{le\+\_\+pack\+\_\+\+Pack\+Int16}}
\index{le\+\_\+pack\+\_\+\+Pack\+Int16@{le\+\_\+pack\+\_\+\+Pack\+Int16}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Int16(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int16\+\_\+t value)}{le_pack_PackInt16(uint8_t **bufferPtr, size_t *sizePtr, int16_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Int16 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{int16\+\_\+t}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a7f501c624043ae6eed9e57cd843b3b09}{}\label{le__pack_8h_a7f501c624043ae6eed9e57cd843b3b09}
Pack a int16\+\_\+t into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Int32@{le\+\_\+pack\+\_\+\+Pack\+Int32}}
\index{le\+\_\+pack\+\_\+\+Pack\+Int32@{le\+\_\+pack\+\_\+\+Pack\+Int32}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Int32(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int32\+\_\+t value)}{le_pack_PackInt32(uint8_t **bufferPtr, size_t *sizePtr, int32_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Int32 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{int32\+\_\+t}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_ae4008bb553d9c76db4b067e61c7bfe9a}{}\label{le__pack_8h_ae4008bb553d9c76db4b067e61c7bfe9a}
Pack a int32\+\_\+t into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Int64@{le\+\_\+pack\+\_\+\+Pack\+Int64}}
\index{le\+\_\+pack\+\_\+\+Pack\+Int64@{le\+\_\+pack\+\_\+\+Pack\+Int64}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Int64(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int64\+\_\+t value)}{le_pack_PackInt64(uint8_t **bufferPtr, size_t *sizePtr, int64_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Int64 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{int64\+\_\+t}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a510e7de2b77da44d375ccc7803799b67}{}\label{le__pack_8h_a510e7de2b77da44d375ccc7803799b67}
Pack a int64\+\_\+t into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Int8@{le\+\_\+pack\+\_\+\+Pack\+Int8}}
\index{le\+\_\+pack\+\_\+\+Pack\+Int8@{le\+\_\+pack\+\_\+\+Pack\+Int8}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Int8(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int8\+\_\+t value)}{le_pack_PackInt8(uint8_t **bufferPtr, size_t *sizePtr, int8_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Int8 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{int8\+\_\+t}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_ac2d743bd159eb176795b833307411ce0}{}\label{le__pack_8h_ac2d743bd159eb176795b833307411ce0}
Pack a int8\+\_\+t into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+On\+Off@{le\+\_\+pack\+\_\+\+Pack\+On\+Off}}
\index{le\+\_\+pack\+\_\+\+Pack\+On\+Off@{le\+\_\+pack\+\_\+\+Pack\+On\+Off}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+On\+Off(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, le\+\_\+onoff\+\_\+t value)}{le_pack_PackOnOff(uint8_t **bufferPtr, size_t *sizePtr, le_onoff_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+On\+Off (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{{\bf le\+\_\+onoff\+\_\+t}}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a3a9b13afab21da57b6e906114352972d}{}\label{le__pack_8h_a3a9b13afab21da57b6e906114352972d}
Pack le\+\_\+onoff\+\_\+t into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Reference@{le\+\_\+pack\+\_\+\+Pack\+Reference}}
\index{le\+\_\+pack\+\_\+\+Pack\+Reference@{le\+\_\+pack\+\_\+\+Pack\+Reference}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Reference(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, const void $\ast$ref)}{le_pack_PackReference(uint8_t **bufferPtr, size_t *sizePtr, const void *ref)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Reference (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{const {\bf void} $\ast$}]{ref}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a9bec119cc87fdc9278e5a406bb1faf73}{}\label{le__pack_8h_a9bec119cc87fdc9278e5a406bb1faf73}
Pack a reference into a buffer, incrementing the buffer pointer and decrementing the available size. \index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Result@{le\+\_\+pack\+\_\+\+Pack\+Result}}
\index{le\+\_\+pack\+\_\+\+Pack\+Result@{le\+\_\+pack\+\_\+\+Pack\+Result}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Result(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, le\+\_\+result\+\_\+t value)}{le_pack_PackResult(uint8_t **bufferPtr, size_t *sizePtr, le_result_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Result (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{{\bf le\+\_\+result\+\_\+t}}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_ad47f59c8e02a25b5a4d17bb3071c64ca}{}\label{le__pack_8h_ad47f59c8e02a25b5a4d17bb3071c64ca}
Pack a le\+\_\+result\+\_\+t into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Size@{le\+\_\+pack\+\_\+\+Pack\+Size}}
\index{le\+\_\+pack\+\_\+\+Pack\+Size@{le\+\_\+pack\+\_\+\+Pack\+Size}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Size(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, size\+\_\+t value)}{le_pack_PackSize(uint8_t **bufferPtr, size_t *sizePtr, size_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Size (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{size\+\_\+t}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a3f3793e8d3354605ee11180a54d0685b}{}\label{le__pack_8h_a3f3793e8d3354605ee11180a54d0685b}
Pack a size\+\_\+t into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
Packed sizes are limited to 2$^\wedge$32-\/1, regardless of platform 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+String@{le\+\_\+pack\+\_\+\+Pack\+String}}
\index{le\+\_\+pack\+\_\+\+Pack\+String@{le\+\_\+pack\+\_\+\+Pack\+String}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+String(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, const char $\ast$string\+Ptr, uint32\+\_\+t max\+String\+Count)}{le_pack_PackString(uint8_t **bufferPtr, size_t *sizePtr, const char *stringPtr, uint32_t maxStringCount)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+String (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{const char $\ast$}]{string\+Ptr, }
\item[{uint32\+\_\+t}]{max\+String\+Count}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a99592e97d04c1c8be2870f0c3fcc36a2}{}\label{le__pack_8h_a99592e97d04c1c8be2870f0c3fcc36a2}
Pack a string into a buffer, incrementing the buffer pointer and decrementing the available size.

\begin{DoxyNote}{Note}
Always decrements available size according to the max possible size used, not actual size used. Will assert if provided string is larger than maximum allowable string. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Uint16@{le\+\_\+pack\+\_\+\+Pack\+Uint16}}
\index{le\+\_\+pack\+\_\+\+Pack\+Uint16@{le\+\_\+pack\+\_\+\+Pack\+Uint16}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Uint16(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint16\+\_\+t value)}{le_pack_PackUint16(uint8_t **bufferPtr, size_t *sizePtr, uint16_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Uint16 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{uint16\+\_\+t}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_acc4f02f9075ef95cbe9fa8c3c82bdd15}{}\label{le__pack_8h_acc4f02f9075ef95cbe9fa8c3c82bdd15}
Pack a uint16\+\_\+t into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Uint32@{le\+\_\+pack\+\_\+\+Pack\+Uint32}}
\index{le\+\_\+pack\+\_\+\+Pack\+Uint32@{le\+\_\+pack\+\_\+\+Pack\+Uint32}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Uint32(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint32\+\_\+t value)}{le_pack_PackUint32(uint8_t **bufferPtr, size_t *sizePtr, uint32_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Uint32 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{uint32\+\_\+t}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_aaccae2e8f6f8c35a74dea6d093390e7b}{}\label{le__pack_8h_aaccae2e8f6f8c35a74dea6d093390e7b}
Pack a uint32\+\_\+t into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Uint64@{le\+\_\+pack\+\_\+\+Pack\+Uint64}}
\index{le\+\_\+pack\+\_\+\+Pack\+Uint64@{le\+\_\+pack\+\_\+\+Pack\+Uint64}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Uint64(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint64\+\_\+t value)}{le_pack_PackUint64(uint8_t **bufferPtr, size_t *sizePtr, uint64_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Uint64 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{uint64\+\_\+t}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_ac043b09c0a0fe06ec8197ad57c7ae95d}{}\label{le__pack_8h_ac043b09c0a0fe06ec8197ad57c7ae95d}
Pack a uint64\+\_\+t into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Pack\+Uint8@{le\+\_\+pack\+\_\+\+Pack\+Uint8}}
\index{le\+\_\+pack\+\_\+\+Pack\+Uint8@{le\+\_\+pack\+\_\+\+Pack\+Uint8}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Pack\+Uint8(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint8\+\_\+t value)}{le_pack_PackUint8(uint8_t **bufferPtr, size_t *sizePtr, uint8_t value)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Pack\+Uint8 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{uint8\+\_\+t}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a3fd9b6634bd102bab44b4828546fef04}{}\label{le__pack_8h_a3fd9b6634bd102bab44b4828546fef04}
Pack a uint8\+\_\+t into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Array\+Header@{le\+\_\+pack\+\_\+\+Unpack\+Array\+Header}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Array\+Header@{le\+\_\+pack\+\_\+\+Unpack\+Array\+Header}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Array\+Header(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, const void $\ast$array\+Ptr, size\+\_\+t element\+Size, size\+\_\+t $\ast$array\+Count\+Ptr, size\+\_\+t array\+Max\+Count)}{le_pack_UnpackArrayHeader(uint8_t **bufferPtr, size_t *sizePtr, const void *arrayPtr, size_t elementSize, size_t *arrayCountPtr, size_t arrayMaxCount)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Array\+Header (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{const {\bf void} $\ast$}]{array\+Ptr, }
\item[{size\+\_\+t}]{element\+Size, }
\item[{size\+\_\+t $\ast$}]{array\+Count\+Ptr, }
\item[{size\+\_\+t}]{array\+Max\+Count}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_ab3c2cc5baf75940d1cc2c777a004b76f}{}\label{le__pack_8h_ab3c2cc5baf75940d1cc2c777a004b76f}
Pack the size information for an array into a buffer, incrementing the buffer pointer and decrementing the available size.

\begin{DoxyNote}{Note}
Users of this A\+PI should generally use L\+E\+\_\+\+P\+A\+C\+K\+\_\+\+P\+A\+C\+K\+A\+R\+R\+AY macro instead which also packs the array data. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Bool@{le\+\_\+pack\+\_\+\+Unpack\+Bool}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Bool@{le\+\_\+pack\+\_\+\+Unpack\+Bool}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Bool(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, bool $\ast$value\+Ptr)}{le_pack_UnpackBool(uint8_t **bufferPtr, size_t *sizePtr, bool *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Bool (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{bool $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_aa3cfe85dba2ad3a617ef0a3cdb6cc028}{}\label{le__pack_8h_aa3cfe85dba2ad3a617ef0a3cdb6cc028}
Unpack a bool from a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Char@{le\+\_\+pack\+\_\+\+Unpack\+Char}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Char@{le\+\_\+pack\+\_\+\+Unpack\+Char}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Char(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, char $\ast$value\+Ptr)}{le_pack_UnpackChar(uint8_t **bufferPtr, size_t *sizePtr, char *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Char (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{char $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a71f3a149fe113e4676c87636329836eb}{}\label{le__pack_8h_a71f3a149fe113e4676c87636329836eb}
Unpack a char from a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Double@{le\+\_\+pack\+\_\+\+Unpack\+Double}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Double@{le\+\_\+pack\+\_\+\+Unpack\+Double}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Double(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, double $\ast$value\+Ptr)}{le_pack_UnpackDouble(uint8_t **bufferPtr, size_t *sizePtr, double *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Double (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{double $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_ae98ee0f0ada53b94b7924ccf34c4122e}{}\label{le__pack_8h_ae98ee0f0ada53b94b7924ccf34c4122e}
Unpack a double from a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Int16@{le\+\_\+pack\+\_\+\+Unpack\+Int16}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Int16@{le\+\_\+pack\+\_\+\+Unpack\+Int16}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Int16(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int16\+\_\+t $\ast$value\+Ptr)}{le_pack_UnpackInt16(uint8_t **bufferPtr, size_t *sizePtr, int16_t *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Int16 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{int16\+\_\+t $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a1336796e47d7dbfaf3cad4880f89b6b5}{}\label{le__pack_8h_a1336796e47d7dbfaf3cad4880f89b6b5}
Unpack a int16\+\_\+t from a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Int32@{le\+\_\+pack\+\_\+\+Unpack\+Int32}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Int32@{le\+\_\+pack\+\_\+\+Unpack\+Int32}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Int32(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int32\+\_\+t $\ast$value\+Ptr)}{le_pack_UnpackInt32(uint8_t **bufferPtr, size_t *sizePtr, int32_t *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Int32 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{int32\+\_\+t $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a68d77fadedff8ce202cc00d4d0645ddb}{}\label{le__pack_8h_a68d77fadedff8ce202cc00d4d0645ddb}
Unpack a int32\+\_\+t from a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Int64@{le\+\_\+pack\+\_\+\+Unpack\+Int64}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Int64@{le\+\_\+pack\+\_\+\+Unpack\+Int64}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Int64(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int64\+\_\+t $\ast$value\+Ptr)}{le_pack_UnpackInt64(uint8_t **bufferPtr, size_t *sizePtr, int64_t *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Int64 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{int64\+\_\+t $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a928f0e54371ac56476275c0d087367af}{}\label{le__pack_8h_a928f0e54371ac56476275c0d087367af}
Unpack a int64\+\_\+t from a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Int8@{le\+\_\+pack\+\_\+\+Unpack\+Int8}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Int8@{le\+\_\+pack\+\_\+\+Unpack\+Int8}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Int8(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, int8\+\_\+t $\ast$value\+Ptr)}{le_pack_UnpackInt8(uint8_t **bufferPtr, size_t *sizePtr, int8_t *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Int8 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{int8\+\_\+t $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a2c6301f685909467d3ae32bcdc1c6ea7}{}\label{le__pack_8h_a2c6301f685909467d3ae32bcdc1c6ea7}
Unpack a int8\+\_\+t from a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+On\+Off@{le\+\_\+pack\+\_\+\+Unpack\+On\+Off}}
\index{le\+\_\+pack\+\_\+\+Unpack\+On\+Off@{le\+\_\+pack\+\_\+\+Unpack\+On\+Off}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+On\+Off(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, le\+\_\+onoff\+\_\+t $\ast$value\+Ptr)}{le_pack_UnpackOnOff(uint8_t **bufferPtr, size_t *sizePtr, le_onoff_t *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+On\+Off (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{{\bf le\+\_\+onoff\+\_\+t} $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a92fa35e40a34f09df7d01eb68d7ae52d}{}\label{le__pack_8h_a92fa35e40a34f09df7d01eb68d7ae52d}
Pack le\+\_\+onoff\+\_\+t into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Reference@{le\+\_\+pack\+\_\+\+Unpack\+Reference}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Reference@{le\+\_\+pack\+\_\+\+Unpack\+Reference}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Reference(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, void $\ast$ref\+Ptr)}{le_pack_UnpackReference(uint8_t **bufferPtr, size_t *sizePtr, void *refPtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Reference (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{{\bf void} $\ast$}]{ref\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a87b266af7445256a48b4eb3c4e386f44}{}\label{le__pack_8h_a87b266af7445256a48b4eb3c4e386f44}
Unpack a reference from a buffer, incrementing the buffer pointer and decrementing the available size. 
\begin{DoxyParams}{Parameters}
{\em ref\+Ptr} & Pointer to the reference. Declared as void $\ast$ to allow implicit conversion from pointer to reference types. \\
\hline
\end{DoxyParams}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Result@{le\+\_\+pack\+\_\+\+Unpack\+Result}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Result@{le\+\_\+pack\+\_\+\+Unpack\+Result}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Result(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, le\+\_\+result\+\_\+t $\ast$value\+Ptr)}{le_pack_UnpackResult(uint8_t **bufferPtr, size_t *sizePtr, le_result_t *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Result (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{{\bf le\+\_\+result\+\_\+t} $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a3bea56e10b56419d1ccbec7dd63301b9}{}\label{le__pack_8h_a3bea56e10b56419d1ccbec7dd63301b9}
Unpack a le\+\_\+result\+\_\+t from a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Size@{le\+\_\+pack\+\_\+\+Unpack\+Size}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Size@{le\+\_\+pack\+\_\+\+Unpack\+Size}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Size(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, size\+\_\+t $\ast$value\+Ptr)}{le_pack_UnpackSize(uint8_t **bufferPtr, size_t *sizePtr, size_t *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Size (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{size\+\_\+t $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_ab6073919e830bf6c9cad6b2e6e18f65d}{}\label{le__pack_8h_ab6073919e830bf6c9cad6b2e6e18f65d}
Pack a size\+\_\+t into a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
Packed sizes are limited to 2$^\wedge$32-\/1, regardless of platform 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+String@{le\+\_\+pack\+\_\+\+Unpack\+String}}
\index{le\+\_\+pack\+\_\+\+Unpack\+String@{le\+\_\+pack\+\_\+\+Unpack\+String}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+String(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, char $\ast$string\+Ptr, uint32\+\_\+t buffer\+Size, uint32\+\_\+t max\+String\+Count)}{le_pack_UnpackString(uint8_t **bufferPtr, size_t *sizePtr, char *stringPtr, uint32_t bufferSize, uint32_t maxStringCount)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+String (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{char $\ast$}]{string\+Ptr, }
\item[{uint32\+\_\+t}]{buffer\+Size, }
\item[{uint32\+\_\+t}]{max\+String\+Count}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_aea4ba842e347564fb273ee103a831009}{}\label{le__pack_8h_aea4ba842e347564fb273ee103a831009}
Unpack a string from a buffer, incrementing the buffer pointer and decrementing the available size.

\begin{DoxyNote}{Note}
Always decrements available size according to the max possible size used, not actual size used. Will assert if provided string is larger than maximum allowable string. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Uint16@{le\+\_\+pack\+\_\+\+Unpack\+Uint16}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Uint16@{le\+\_\+pack\+\_\+\+Unpack\+Uint16}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Uint16(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint16\+\_\+t $\ast$value\+Ptr)}{le_pack_UnpackUint16(uint8_t **bufferPtr, size_t *sizePtr, uint16_t *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Uint16 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{uint16\+\_\+t $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a4afb705a1c791b41ca4c3240a4144d81}{}\label{le__pack_8h_a4afb705a1c791b41ca4c3240a4144d81}
Unpack a uint16\+\_\+t from a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Uint32@{le\+\_\+pack\+\_\+\+Unpack\+Uint32}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Uint32@{le\+\_\+pack\+\_\+\+Unpack\+Uint32}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Uint32(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint32\+\_\+t $\ast$value\+Ptr)}{le_pack_UnpackUint32(uint8_t **bufferPtr, size_t *sizePtr, uint32_t *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Uint32 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{uint32\+\_\+t $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a351b48f9f4602a2374862fede224aaa3}{}\label{le__pack_8h_a351b48f9f4602a2374862fede224aaa3}
Unpack a uint32\+\_\+t from a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Uint64@{le\+\_\+pack\+\_\+\+Unpack\+Uint64}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Uint64@{le\+\_\+pack\+\_\+\+Unpack\+Uint64}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Uint64(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint64\+\_\+t $\ast$value\+Ptr)}{le_pack_UnpackUint64(uint8_t **bufferPtr, size_t *sizePtr, uint64_t *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Uint64 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{uint64\+\_\+t $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_a92cc79f11f06664ef1e3ad60906d7ca2}{}\label{le__pack_8h_a92cc79f11f06664ef1e3ad60906d7ca2}
Unpack a uint64\+\_\+t from a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
\index{le\+\_\+pack.\+h@{le\+\_\+pack.\+h}!le\+\_\+pack\+\_\+\+Unpack\+Uint8@{le\+\_\+pack\+\_\+\+Unpack\+Uint8}}
\index{le\+\_\+pack\+\_\+\+Unpack\+Uint8@{le\+\_\+pack\+\_\+\+Unpack\+Uint8}!le\+\_\+pack.\+h@{le\+\_\+pack.\+h}}
\subsubsection[{\texorpdfstring{le\+\_\+pack\+\_\+\+Unpack\+Uint8(uint8\+\_\+t $\ast$$\ast$buffer\+Ptr, size\+\_\+t $\ast$size\+Ptr, uint8\+\_\+t $\ast$value\+Ptr)}{le_pack_UnpackUint8(uint8_t **bufferPtr, size_t *sizePtr, uint8_t *valuePtr)}}]{\setlength{\rightskip}{0pt plus 5cm}static bool le\+\_\+pack\+\_\+\+Unpack\+Uint8 (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$$\ast$}]{buffer\+Ptr, }
\item[{size\+\_\+t $\ast$}]{size\+Ptr, }
\item[{uint8\+\_\+t $\ast$}]{value\+Ptr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\hypertarget{le__pack_8h_afc88f6def28cdddce70672d3f9730032}{}\label{le__pack_8h_afc88f6def28cdddce70672d3f9730032}
Unpack a uint8\+\_\+t from a buffer, incrementing the buffer pointer and decrementing the available size, as appropriate.

\begin{DoxyNote}{Note}
By making this an inline function, gcc can often optimize out the size check if the buffer size is known at compile time. 
\end{DoxyNote}
