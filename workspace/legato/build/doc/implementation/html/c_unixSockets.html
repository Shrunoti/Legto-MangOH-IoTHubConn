<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: Unix Domain Sockets API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('c_unixSockets.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Unix Domain Sockets API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="unix_socket_8h.html">Click here for the API reference documentation.</a></p>
<hr/>
<h1><a class="anchor" id="toc"></a>
Table of Contents</h1>
<ul>
<li><a class="el" href="c_unixSockets.html#c_unixSocketsIntro">Introduction</a></li>
<li><a class="el" href="c_unixSockets.html#c_unixSocketsCreatingSingle">Creating a Single Socket</a></li>
<li><a class="el" href="c_unixSockets.html#c_unixSocketsCreatingPair">Creating a Pair of Connected Sockets</a></li>
<li><a class="el" href="c_unixSockets.html#c_unixSocketsConnecting">Listening and Connecting</a></li>
<li><a class="el" href="c_unixSockets.html#c_unixSocketsSendingAndReceiving">Sending and Receiving</a></li>
<li><a class="el" href="c_unixSockets.html#c_unixSocketsGettingCredentialsDirect">Getting Credentials Directly from a Connected Socket</a></li>
<li><a class="el" href="c_unixSockets.html#c_unixSocketsDeleting">Deleting a Socket</a></li>
</ul>
<hr/>
<h1><a class="anchor" id="c_unixSocketsIntro"></a>
Introduction</h1>
<p>Unix domain sockets are a powerful and relatively efficient means of communicating between processes in Unix systems. However, the use of Unix domain sockets is not without pitfalls, some of which can result in security holes or race conditions. Therefore, Unix domain sockets should be avoided, unless fully understood and carefully managed. Use the Legato messaging system(s) instead.</p>
<p>Unix Domain Sockets can be <b>named</b> or <b>unnamed</b>.</p>
<p>A <b>named</b> socket appears in the file system as a "socket" type file, and is addressed using a file system path.</p>
<p>An <b>unnamed</b> socket does not appear in the file system and essentially has no address. It won't receive anything unless it is <b>connected</b> to another socket.</p>
<dl class="section note"><dt>Note</dt><dd>In Linux, Unix Domain sockets can also be "abstract", where an abstract socket has a name but does not appear in the file system. However, this is not portable to other Unix platforms (like BSD), and can be a security hole, since the abstract namespace does not support file system permissions and can be accessed from inside chroot() jails.</dd></dl>
<p>Unix Domain Sockets can also be <b>datagram-</b>, <b>stream-</b>, or <b> sequenced-packet- </b> oriented, just like UDP, TCP, and SCTP sockets, respectively. Unlike UDP datagram sockets, however, Unix Domain datagram sockets are guaranteed to deliver every datagram in the order in which they were sent.</p>
<p>An added bonus of Unix Domain sockets is that they can be used to <b> pass file descriptors </b> between processes. Furthermore, they allow one process to <b> check the credentials </b> (Process ID, User ID, and Group ID) of another process on the other end of a connection. The OS checks the validity of the credentials, so the recipient can be certain that they are valid.</p>
<h1><a class="anchor" id="c_unixSocketsCreatingSingle"></a>
Creating a Single Socket</h1>
<p>Use <a class="el" href="unix_socket_8h.html#af4c4d4e3521f296f0bfc4f398d3cafd9">unixSocket_CreateDatagramNamed()</a> to create a single, named datagram socket whose address is a given file system path.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> socketFd;</div><div class="line"><a class="code" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> result;</div><div class="line"></div><div class="line">result = <a class="code" href="unix_socket_8h.html#af4c4d4e3521f296f0bfc4f398d3cafd9">unixSocket_CreateDatagramNamed</a>(<span class="stringliteral">&quot;/tmp/my_app/server_socket&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="le__log_8h.html#a7a3e66a87026cc9e57bcb748840ab41b">LE_FATAL_IF</a>(result != LE_OK, <span class="stringliteral">&quot;Failed to create socket!&quot;</span>);</div></div><!-- fragment --><p>This seems simple enough on the surface, but beware of pitfalls here.</p>
<p>If the socket name corresponds to a location in a non-volatile file system (e.g., a flash file system), then the socket will consume a small amount of space in that file system. Furthermore, creating and deleting sockets in a non-volatile file system will wear the backing store (e.g., the flash memory device), thereby shortening its life. It is highly recommended that sockets be placed in RAM-based file systems (e.g., tmpfs) to avoid these issues.</p>
<p>Of course, the location you choose must be managed very carefully. In particular, the only way to portably guarantee that unauthorized processes don't hijack your socket address is to put it in a directory that has its permissions set such that unauthorized processes can't search (execute permission) or write that directory.</p>
<p>Also beware that it is possible to leave socket bindings lying around in the file system after a process dies. This will consume system resources and could lead to a memory leak if successive incarnations of the process use different socket names. Furthermore, if every incarnation of the process uses the same socket name, then socket creation will fail if an old socket with the same name is still there. As a result, its a good idea to remove the socket from the filesystem using unlink() when your process dies. However, even if your process has clean-up code that unlinks a socket from the filesystem when it terminates, your process may not always get the opportunity to run that code (e.g., if it receives SIG_KILL). Therefore, your system design must ensure that your sockets get cleaned up somehow, even if your process doesn't terminate gracefully.</p>
<p>To create a single, named stream socket, use unixSocket_CreateStreamNamed().</p>
<p>To create a single, named sequenced-packet socket, use <a class="el" href="unix_socket_8h.html#a1a9716076a305c1e918584568da28907">unixSocket_CreateSeqPacketNamed()</a>.</p>
<p>To create a single, unnamed datagram socket, use unixSocket_CreateDatagramUnnamed().</p>
<p>To create a single, unnamed stream socket, use unixSocket_CreateStreamUnnamed().</p>
<p>To create a single, unnamed sequenced-packet socket, use <a class="el" href="unix_socket_8h.html#abb4b00a74449a57fdfa4fd1a642fb37a">unixSocket_CreateSeqPacketUnnamed()</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000055">Todo:</a></b></dt><dd>Implement additional functions, as needed.</dd></dl>
<h1><a class="anchor" id="c_unixSocketsCreatingPair"></a>
Creating a Pair of Connected Sockets</h1>
<p>Use <a class="el" href="unix_socket_8h.html#a662207caa2695a24ff5abdbd82342a66">unixSocket_CreateDatagramPair()</a> to create a pair of unnamed datagram sockets that are connected to each other.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> socketFd1;</div><div class="line"><span class="keywordtype">int</span> socketFd2;</div><div class="line"><a class="code" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> result;</div><div class="line"></div><div class="line">result = <a class="code" href="unix_socket_8h.html#a662207caa2695a24ff5abdbd82342a66">unixSocket_CreateDatagramPair</a>(&amp;socketFd1, &amp;socketFd2);</div><div class="line"></div><div class="line"><a class="code" href="le__log_8h.html#a7a3e66a87026cc9e57bcb748840ab41b">LE_FATAL_IF</a>(result != LE_OK, <span class="stringliteral">&quot;Failed to create socket pair!&quot;</span>);</div></div><!-- fragment --><p>To create a pair of unnamed, connected stream sockets, use unixSocket_CreateStreamPair().</p>
<p>To create a pair of unnamed, connected sequenced-packet sockets, use <a class="el" href="unix_socket_8h.html#a9eb8d8b2e6802827529abf2ad90f6ff6">unixSocket_CreateSeqPacketPair()</a>.</p>
<h1><a class="anchor" id="c_unixSocketsConnecting"></a>
Listening and Connecting</h1>
<p>Unix domain sockets work the same as Internet network sockets, with respect to listening, accepting, and connecting. Refer to the man pages for listen(), accept() and connect() for more information.</p>
<p>When a socket is a listening socket, the socket will appear readable to a File Descriptor Monitor (see <a class="el" href="c_fdMonitor.html">File Descriptor Monitor API</a>) when a connection is waiting to be accepted. That is, a connection handler can be registered by registering a handler for the <code>POLLIN</code> event type.</p>
<h1><a class="anchor" id="c_unixSocketsSendingAndReceiving"></a>
Sending and Receiving</h1>
<p>Sending data on a socket can be done using the standard POSIX APIs for sending (write(), writev(), send(), sendto(), sendmsg(), etc.).</p>
<p>Receiving data from a socket can be done using the standard POSIX APIs for receiving (read(), readv(), recv(), recvfrom(), recvmsg(), etc.).</p>
<p>Likewise, the standard POSIX select() and poll() functions (and variants of those) can be used to know when it is "clear-to-send" to a socket or when there is data available to be read from a socket. However, it is best when working in the Legato framework to use the file descriptor monitoring features of the <a class="el" href="c_eventLoop.html">Event Loop API</a> for this.</p>
<p>The standard way to send file descriptors and authenticated credentials (PID, UID, GID) through a Unix Domain socket is sendmsg() and recvmsg(). Those are particularly nasty APIs. To make life easier, the Legato framework provides its own sending and receiving functions that (in addition to providing normal data message delivery) allow a file descriptor and/or authenticated process credentials to be sent between processes.</p>
<ul>
<li><a class="el" href="unix_socket_8h.html#af81ee1e16e1ee2edbb8610fbb4e34ebe">unixSocket_SendMsg()</a> sends a message containing any combination of normal data, a file descriptor, and authenticated credentials.</li>
<li><a class="el" href="unix_socket_8h.html#ab64d779b38aa59e2a433a38f613fe191">unixSocket_ReceiveMsg()</a> receives a message containing any combination of normal data, a file descriptor, and authenticated credentials.</li>
</ul>
<p>When file descriptors are sent, they are duplicated in the receiving process as if they had been created using the POSIX dup() function. This means that they remain open in the sending process and must be closed by the sending process when it doesn't need them anymore.</p>
<p>Authentication of credentials is done at the receiving socket, and this feature is normally turned off by default (presumably to save overhead in the common case where authentication is not needed). To enable the authentication of credentials, <a class="el" href="unix_socket_8h.html#a814c92589fc434132bc1cfbfc5b37e5b">unixSocket_EnableAuthentication()</a> must be called on the receiving socket.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <a class="code" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> PassFdToConnectedPeer(<span class="keywordtype">int</span> sendSocketFd, <span class="keywordtype">int</span> fdToSend)</div><div class="line">{</div><div class="line">    <span class="comment">// NOTE: My socket is connected, so I don&#39;t need to specify a destination address.</span></div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="unix_socket_8c.html#af81ee1e16e1ee2edbb8610fbb4e34ebe">unixSocket_SendMsg</a>(sendSocketFd, NULL, NULL, 0, fdToSend, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    <a class="code" href="app_stop_client_8c.html#ac9aa243805b0ac0687f9c2e9b5bdb8ef">close</a>(fdToSend); <span class="comment">// I don&#39;t need the fd locally anymore, so close my copy of it.</span></div><div class="line">}</div></div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>When sending ancillary data (fds or credentials) over a stream socket, at least one byte of data must accompany the ancillary data. This is a limitation of the underlying OS. Datagram and sequenced-packet sockets don't have this limitation.</dd></dl>
<p>A regular <a class="el" href="c_eventLoop.html">Event Loop API</a> file descriptor monitor can be used to detect the arrival of an ancillary data message. The indication that is provided when a message containing ancillary data arrives is indistinguishable from the indication provided when normal data arrives.</p>
<div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> SocketReadyForReadingHandler</div><div class="line">(</div><div class="line">    <span class="keywordtype">int</span> socketFd</div><div class="line">)</div><div class="line">{</div><div class="line">    <span class="keywordtype">char</span> dataBuff[MAX_MESSAGE_DATA_BYTES];</div><div class="line">    <span class="keywordtype">size_t</span> numDataBytes = <span class="keyword">sizeof</span>(dataBuff);</div><div class="line">    <span class="keywordtype">int</span> <a class="code" href="app_stop_client_8c.html#a44f21d5190b5a6df8089f54799628d7e">fd</a>;</div><div class="line">    <span class="keyword">struct </span>ucred credentials;</div><div class="line"></div><div class="line">    result = <a class="code" href="unix_socket_8c.html#ab64d779b38aa59e2a433a38f613fe191">unixSocket_ReceiveMsg</a>(socketFd,</div><div class="line">                                   NULL,    <span class="comment">// addrBuffPtr - I don&#39;t need the sender&#39;s address.</span></div><div class="line">                                   0,       <span class="comment">// addrBuffSize</span></div><div class="line">                                   dataBuff,</div><div class="line">                                   &amp;numDataBytes,</div><div class="line">                                   &amp;fd,</div><div class="line">                                   &amp;credentials);</div><div class="line">    <span class="keywordflow">if</span> (result != LE_OK)</div><div class="line">    {</div><div class="line">        <a class="code" href="le__log_8h.html#a353590f91b3143a7ba3a416ae5a50c3d">LE_ERROR</a>(<span class="stringliteral">&quot;Socket receive failed. Error = %d (%s).&quot;</span>, result, <a class="code" href="le__log_8h.html#a99402d6a983f318e5b8bfcdf5dfe9024">LE_RESULT_TXT</a>(result));</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (numDataBytes &gt; 0)</div><div class="line">        {</div><div class="line">            <span class="comment">// Got some data!</span></div><div class="line">            ...</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (fd &gt; -1)</div><div class="line">        {</div><div class="line">            <span class="comment">// Got a file descriptor!</span></div><div class="line">            ...</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (credentials.pid != 0)</div><div class="line">        {</div><div class="line">            <span class="comment">// Got some credentials!</span></div><div class="line">            ...</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="c_unixSocketsGettingCredentialsDirect"></a>
Getting Credentials Directly from a Connected Socket</h1>
<p>Although it is possible to explicitly send credentials over Unix domain sockets, it is often not necessary to do so. Instead, you can often just use getsockopt() to fetch credentials directly from a local connected socket.</p>
<p>If you have a connected Unix domain stream or sequenced-packet socket, you can use getsockopt() to fetch the credentials of <b>the process that called bind()</b> on the socket at the other end of the connection.</p>
<p>If you have any kind of connected Unix domain socket that was created using socketpair() or one of the helper functions built on top of socketpair (<a class="el" href="unix_socket_8h.html#a662207caa2695a24ff5abdbd82342a66">unixSocket_CreateDatagramPair()</a>, unixSocket_CreateStreamPair(), or <a class="el" href="unix_socket_8h.html#a9eb8d8b2e6802827529abf2ad90f6ff6">unixSocket_CreateSeqPacketPair()</a>), you can also use getsockopt() to fetch the credentials of <b>the process that created that socket</b>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ucred credentials;</div><div class="line">socklen_t size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>ucred);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &amp;credentials, &amp;size) != 0)</div><div class="line">{</div><div class="line">    <a class="code" href="le__log_8h.html#a54b4b07f5396e19a8d9fca74238f4795">LE_FATAL</a>(<span class="stringliteral">&quot;Failed to obtain credentials from socket.  Errno = %d (%m)&quot;</span>, <a class="code" href="supervisor_8c.html#a0a4ccfdbe1cf7b37afc60d34e748b066">errno</a>);</div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="le__log_8h.html#a23e6d206faa64f612045d688cdde5808">LE_INFO</a>(<span class="stringliteral">&quot;Credentials of peer process:  pid = %d;  uid = %d;  gid = %d.&quot;</span>,</div><div class="line">        credentials.pid,</div><div class="line">        credentials.uid,</div><div class="line">        credentials.gid);</div></div><!-- fragment --><h1><a class="anchor" id="c_unixSocketsDeleting"></a>
Deleting a Socket</h1>
<p>The standard POSIX <a class="el" href="app_stop_client_8c.html#ac9aa243805b0ac0687f9c2e9b5bdb8ef">close()</a> function can be used to delete a socket. However, is recommended that the function <a class="el" href="file_descriptor_8c.html#ac66047067b00ef0ccc70e0ee7d70dd79">fd_Close()</a> be used.</p>
<hr/>
<p>Copyright (C) Sierra Wireless Inc. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
