<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: framework/include/le_pathIter.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('le__path_iter_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">le_pathIter.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="le__path_iter_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0facb15e56e7ef896384eca415a7147a"><td class="memItemLeft" align="right" valign="top">typedef struct le_pathIter_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a></td></tr>
<tr class="separator:a0facb15e56e7ef896384eca415a7147a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a73fac1b657b752b17395c66fb1ae324b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#a73fac1b657b752b17395c66fb1ae324b">le_pathIter_Create</a> (const char *pathPtr, const char *separatorPtr, const char *parentSpecPtr, const char *currentSpecPtr)</td></tr>
<tr class="separator:a73fac1b657b752b17395c66fb1ae324b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a38b307f9fdc0de82552e96a5a2d1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#a35a38b307f9fdc0de82552e96a5a2d1d">le_pathIter_CreateForUnix</a> (const char *pathPtr)</td></tr>
<tr class="separator:a35a38b307f9fdc0de82552e96a5a2d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50349a6c2afa4415d65a6efd443894d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#a50349a6c2afa4415d65a6efd443894d3">le_pathIter_Clone</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> originalRef)</td></tr>
<tr class="separator:a50349a6c2afa4415d65a6efd443894d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b57267a2c0db0210aab96c66459f9a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#a6b57267a2c0db0210aab96c66459f9a1">le_pathIter_Delete</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:a6b57267a2c0db0210aab96c66459f9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586cd64de7f1a6797da3a17896946ee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#a586cd64de7f1a6797da3a17896946ee5">le_pathIter_GetSeparator</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>, char *bufferPtr, size_t bufferSize)</td></tr>
<tr class="separator:a586cd64de7f1a6797da3a17896946ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1707a310401be209aeada07f6d0f43f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#af1707a310401be209aeada07f6d0f43f">le_pathIter_GetParentSpecifier</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>, char *bufferPtr, size_t bufferSize)</td></tr>
<tr class="separator:af1707a310401be209aeada07f6d0f43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12ea9bbe193fd9239abd10a4b07feba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#ac12ea9bbe193fd9239abd10a4b07feba">le_pathIter_GetCurrentSpecifier</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>, char *bufferPtr, size_t bufferSize)</td></tr>
<tr class="separator:ac12ea9bbe193fd9239abd10a4b07feba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1c39584a779518395b41f957765283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#a4a1c39584a779518395b41f957765283">le_pathIter_GetPath</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>, char *bufferPtr, size_t bufferSize)</td></tr>
<tr class="separator:a4a1c39584a779518395b41f957765283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4352480ab3c9ffb09e740f2899d504e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#af4352480ab3c9ffb09e740f2899d504e">le_pathIter_GoToStart</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:af4352480ab3c9ffb09e740f2899d504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c0b90132171b3f3cf5cfb614329b13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#ab1c0b90132171b3f3cf5cfb614329b13">le_pathIter_GoToEnd</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:ab1c0b90132171b3f3cf5cfb614329b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83a619dcc34ecf03da1859b3da2f57f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#ad83a619dcc34ecf03da1859b3da2f57f">le_pathIter_GoToNext</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:ad83a619dcc34ecf03da1859b3da2f57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a740759fe5c3b0a18e39dd8c73466b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#a92a740759fe5c3b0a18e39dd8c73466b">le_pathIter_GoToPrev</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:a92a740759fe5c3b0a18e39dd8c73466b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00916d853b3a869748b0195cc2a8f11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#ab00916d853b3a869748b0195cc2a8f11">le_pathIter_GetCurrentNode</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>, char *bufferPtr, size_t bufferSize)</td></tr>
<tr class="separator:ab00916d853b3a869748b0195cc2a8f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04be1341536a3e330a815171e7cdbf7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#a04be1341536a3e330a815171e7cdbf7a">le_pathIter_Truncate</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:a04be1341536a3e330a815171e7cdbf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6aa59696c54d2523009037cc78f9725"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#ae6aa59696c54d2523009037cc78f9725">le_pathIter_Append</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>, const char *pathStr)</td></tr>
<tr class="separator:ae6aa59696c54d2523009037cc78f9725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657f779873a2220f463f705298c1399f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#a657f779873a2220f463f705298c1399f">le_pathIter_IsAbsolute</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:a657f779873a2220f463f705298c1399f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ceddae696158d04fdbc1802614c5d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__path_iter_8h.html#ab4ceddae696158d04fdbc1802614c5d6">le_pathIter_IsEmpty</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:ab4ceddae696158d04fdbc1802614c5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Legato <a class="el" href="c_pathIter.html">Path Iterator API</a> include file.</p>
<p>Copyright (C) Sierra Wireless Inc. license. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a0facb15e56e7ef896384eca415a7147a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct le_pathIter_t* <a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Objects of this type are used to iterate and manipulate path strings. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae6aa59696c54d2523009037cc78f9725"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_Append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the new string path and combine it with the object's existing path.</p>
<dl class="section note"><dt>Note</dt><dd>This function looks for the current and parent node strings and treats them specially. So, (assuming defaults,) combining the path "/a/b" with the path "../x" will give you the combined path of: "/a/x".</dd>
<dd>
Appending a non-relative path onto an existing path effectivly replaces the current path, for example, appending /a/rooted/path, onto the existing /a/seperate/path will given you the path: /a/rooted/path.</dd>
<dd>
This will automatically reset the internal iterator to point at the end of the newly formed path. Also, this function always appends to the end of a path, ignoring the current position of the iterator.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_OVERFLOW if the output buffer is too small for the new string. LE_UNDERFLOW if combining the path the new path tries to traverse past the root. For example: "/a/b" + "../../../x" will result in LE_UNDERFLOW. However if the base path is relative, "a/b", then the resulting string will be "../x" and a return code of LE_OK. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The path object to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathStr</td><td>The new path segment to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50349a6c2afa4415d65a6efd443894d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> le_pathIter_Clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>originalRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a clone of an existing path iterator object.</p>
<dl class="section return"><dt>Returns</dt><dd>A new path iterator object that is a duplicate of the original one. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">originalRef</td><td>The path object to duplicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73fac1b657b752b17395c66fb1ae324b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> le_pathIter_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separatorPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parentSpecPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>currentSpecPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new path iterator object. On creation, the default position of the iterator is at the end of the path.</p>
<dl class="section return"><dt>Returns</dt><dd>A new path object setup with the given parameters.</dd></dl>
<p>Create a new path iterator object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Optional. Pointer to the inital path to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separatorPtr</td><td>Required. Path separator to use. The separator can not be NULL or empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parentSpecPtr</td><td>Optional. Used to traverse upwards in a path. Leave as NULL or empty to not use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currentSpecPtr</td><td>Optional. Used to refer to a current node. Much like how a '.' is use in a filesystem path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35a38b307f9fdc0de82552e96a5a2d1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> le_pathIter_CreateForUnix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new path iterator object that is pre-configured for Unix styled paths. On creation, the default position of the iterator is at the end of the path.</p>
<p>The parameters are configured as follows:</p>
<ul>
<li>separator: "/"</li>
<li>parentSpec: ".."</li>
<li>currentSpec: "."</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>A new path iterator object that's ready for iterating on Unix style paths.</dd></dl>
<p>Create a new path iterator object that is pre-configured for Unix styled paths.</p>
<dl class="section return"><dt>Returns</dt><dd>A new path iterator object that's ready for iterating on Unix paths. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Optional. Create an iterator for this path, or start with an empty path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b57267a2c0db0210aab96c66459f9a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_pathIter_Delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete an iterator object and free it's memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab00916d853b3a869748b0195cc2a8f11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GetCurrentNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the text for the node the itrator is pointing at.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if succesful. LE_OVERFLOW if the bufferPtr is too small to hold the whole string. LE_NOT_FOUND if the iterator is at the end of the path. Or if the path is empty, or simply consists of a separator.</dd></dl>
<p>Get the text for the node the iterator is pointing at.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if succesful. LE_OVERFLOW if the bufferPtr is too small to hold the whole string. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bufferPtr</td><td>The utf-8 formatted text buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size in bytes of the text buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac12ea9bbe193fd9239abd10a4b07feba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GetCurrentSpecifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the iterators string for the current node specifier. For Unix style paths for this is ".". If an empty string is used, then this is ignored for the purposes of appending and normalizing paths.</p>
<p>Read the iterators string for the current node specifier. The for Unix style paths for this is ".". If an empty string is used, then this is ignored for the purposes of appending and normalizing paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bufferPtr</td><td>The string buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of the string buffer being written to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1707a310401be209aeada07f6d0f43f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GetParentSpecifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the string that represents parent nodes in a path string. By for Unix style paths this is "..". If an empty string is used, then it is ignored for the purposes of appending and normalizing paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bufferPtr</td><td>The string buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of the buffer being written to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a1c39584a779518395b41f957765283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GetPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a copy of the path currently contained within the iterator.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the copy is successful. LE_OVERFLOW if the buffer isn't big enough for the path string.</dd></dl>
<p>Get a copy of the path currently contained within the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bufferPtr</td><td>The string buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of the buffer being written to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a586cd64de7f1a6797da3a17896946ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GetSeparator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the string that is being used to represent path separators in this iterator object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bufferPtr</td><td>The string buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of the buffer being written to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1c0b90132171b3f3cf5cfb614329b13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GoToEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Jump the iterator to the end of the path.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the move was successful. LE_NOT_FOUND if the path is empty, or only contains a separator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad83a619dcc34ecf03da1859b3da2f57f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GoToNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move to the next node in the path.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the itrator was successful in jumping to the next node. LE_NOT_FOUND is returned if there are no more nodes to move to in the path. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92a740759fe5c3b0a18e39dd8c73466b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GoToPrev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move to the previous node in the path.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the iterator was successfuly moved, LE_NOT_FOUND if there are no prior nodes to move to. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4352480ab3c9ffb09e740f2899d504e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GoToStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Jump the iterator to the beginning of the path.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the move was successful. LE_NOT_FOUND if the path is empty, or only contains a separator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a657f779873a2220f463f705298c1399f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_pathIter_IsAbsolute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is this an absolute or relative path?</p>
<dl class="section return"><dt>Returns</dt><dd>True if the path is absolute, that is that it begins with a separator. False if the path is considered relative.</dd></dl>
<p>Is this an absolute or relative path?</p>
<dl class="section return"><dt>Returns</dt><dd>True if the path is rooted, that is that it begins with a separator. False if the path is considered relative. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4ceddae696158d04fdbc1802614c5d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_pathIter_IsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is the path object holding an empty string?</p>
<dl class="section return"><dt>Returns</dt><dd>True if the path is empty, false if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterRef</td><td>The path object to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04be1341536a3e330a815171e7cdbf7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_pathIter_Truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate the path at the current iterator node. If the iterator is at the beginning of the path, then the whole path is cleared. If the iterator is at the end of the path, then nothing happens.</p>
<p>Once done, then the iterator will be pointing at the new end of the path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
