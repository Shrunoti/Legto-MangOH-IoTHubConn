<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: Design of the mk tools (mksys, mkapp, mkcomp, and mkexe)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mkToolsDesign.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Design of the mk tools (mksys, mkapp, mkcomp, and mkexe) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="mkToolsDesign_Decomposition"></a>
Design Decomposition</h1>
<p>The mk tools are broken into the following main parts:</p>
<ul>
<li><a class="el" href="mkToolsDesign.html#mkToolsDesign_parser">Parser</a></li>
<li><a class="el" href="mkToolsDesign.html#mkToolsDesign_parseTrees">Parse Trees</a></li>
<li><a class="el" href="mkToolsDesign.html#mkToolsDesign_modellers">Modellers</a></li>
<li><a class="el" href="mkToolsDesign.html#mkToolsDesign_conceptualModel">Conceptual Model</a></li>
<li><a class="el" href="mkToolsDesign.html#mkToolsDesign_buildScriptGenerator">Build Script Generator</a></li>
<li><a class="el" href="mkToolsDesign.html#mkToolsDesign_appConfigGenerator">App Configuration Generator</a></li>
<li><a class="el" href="mkToolsDesign.html#mkToolsDesign_codeGenerator">Code Generator</a></li>
<li><a class="el" href="mkToolsDesign.html#mkToolsDesign_commandLineInterpreter">Command-Line Interpreter</a></li>
<li><a class="el" href="mkToolsDesign.html#mkToolsDesign_ninjaBuildTool">Ninja Build Tool</a></li>
</ul>
<h2><a class="anchor" id="mkToolsDesign_parser"></a>
Parser</h2>
<pre class="fragment">Parse .cdef, .adef, and .sdef files and builds in-memory Parse Trees.  Different parsing
algorithms parse different types and versions of .Xdef files and generate the
associated Parse Trees.
</pre><h2><a class="anchor" id="mkToolsDesign_parseTrees"></a>
Parse Trees</h2>
<pre class="fragment">A model of a parsed .Xdef file.  Keeps track of the structure of the definition file
and exactly what file and line number a given part of the definition comes from.
Parse trees are versioned according to the .Xdef file format version.
</pre><h2><a class="anchor" id="mkToolsDesign_modellers"></a>
Modellers</h2>
<pre class="fragment">Converts a Parse Tree into a Conceptual Model.
Different versions of modellers know how to generate the Conceptual Model from different
versions of the Parse Tree.
</pre><h2><a class="anchor" id="mkToolsDesign_conceptualModel"></a>
Conceptual Model</h2>
<pre class="fragment">Conceptual model of component/app/system/executable being built.
There is only one version of the Conceptual Model in any given release of the mk tools.
</pre><h2><a class="anchor" id="mkToolsDesign_buildScriptGenerator"></a>
Build Script Generator</h2>
<pre class="fragment">Generates a build script for the "project" being built, based on the Conceptual Model.
</pre><h2><a class="anchor" id="mkToolsDesign_appConfigGenerator"></a>
App Configuration Generator</h2>
<pre class="fragment">Generates the configuration data files needed by the installer on-target.
</pre><h2><a class="anchor" id="mkToolsDesign_codeGenerator"></a>
Code Generator</h2>
<pre class="fragment">Generates C code files, such _main.c for executables and interfaces.h for components.
</pre><h2><a class="anchor" id="mkToolsDesign_commandLineInterpreter"></a>
Command-Line Interpreter</h2>
<pre class="fragment">Interprets the command-line to determine what to build.
Drives the Parsers, Modellers, App Configuration Generator, Build Script Generator and
the ninja build tool.

The Command Line Interpreter will look for the @ref build.ninja file for the project.
If it exists, the Command Line Interpreter will just exec() ninja.  A rule in the
build.ninja file tells ninja how to detect whether the build.ninja file needs to be
regenerated, and if so, how to run the mk tools again to regenerate the build.ninja file.

Steps executed by the mk tools when build.ninja doesn't exist are:

 - create the working directory (if it doesn't already exist)
 - save the command-line arguments and environment variables used to run the tool.
 - generate _main.c files for executables declared in .adef files
 - generate _componentMain.c and interface.h files for components.
 - generate .c and .h files for .api files used by components
 - generate configuration files
 - generate build.ninja

The command-line arguments and environment variables are remembered so that they can
be checked when the same tool is run again later, because command-line arguments and
environment variable settings can affect the def file parsing and code generation, so
if any have changed, the def files must be re-parsed and the code must be re-generated.
</pre><h2><a class="anchor" id="mkToolsDesign_ninjaBuildTool"></a>
Ninja Build Tool</h2>
<pre class="fragment">The Ninja build tool is documented at http://martine.github.io/ninja/.

The build.ninja script will drive
 - generating IPC API code
 - compiling
 - linking
 - copying bundled files into the staging area
 - generating application hash
 - update-packing
</pre><h1><a class="anchor" id="mkToolsDesign_workingDirs"></a>
Working Directory Structures</h1>
<p>The mk tools are designed to put any intermediate build artifacts in a "working" directory, separate from the source directory.</p>
<p>The location of the working directory can be specified on the command-line using the '-w' option. If not specified, a default directory path, beginning with "./_build" will be generated.</p>
<h2><a class="anchor" id="mkToolsDesign_workingDirs_systems"></a>
Systems' Working Directories</h2>
<p>The working directory structure for mksys contains these directories:</p>
<ul>
<li>app/ - working directories for the apps, one per app, named with the app name.</li>
<li>api/ - working directories for generated api files.</li>
<li>component/ - working directories for the components.</li>
<li>staging/ - directory where the system is "staged" in preparation for packing into an update pack.</li>
</ul>
<p>See:</p><ul>
<li><a class="el" href="mkToolsDesign.html#mkToolsDesign_workingDirs_app">app Directory</a></li>
<li><a class="el" href="mkToolsDesign.html#mkToolsDesign_workingDirs_component">component Directory</a></li>
<li><a class="el" href="mkToolsDesign.html#mkToolsDesign_workingDirs_api">api Directory</a></li>
</ul>
<h2><a class="anchor" id="mkToolsDesign_workingDirs_app"></a>
app Directory</h2>
<p>Applications' working directories contain these subdirectories:</p>
<ul>
<li>obj/ - generated object files specific to this application</li>
<li>src/ - generated source code specific to this application</li>
<li>staging/ - directories and files to be installed on target</li>
</ul>
<h3><a class="anchor" id="mkToolsDesign_workingDirs_app_obj"></a>
obj Directory</h3>
<p>The application's "obj" directory contains .o files for each generated .c file in the "src" directory. The directory structure under the "obj" directory mirrors that of the "src" directory.</p>
<ul>
<li>obj/exeName/_main.c.o</li>
</ul>
<h3><a class="anchor" id="mkToolsDesign_workingDirs_app_src"></a>
src Directory</h3>
<p>The application's "src" directory contains generated .c files for executables' <a class="el" href="start_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main()</a> functions and component instance libraries. These are kept in a subdirectory named after the executable.</p>
<ul>
<li>src/exeName/_main.c</li>
</ul>
<h3><a class="anchor" id="mkToolsDesign_workingDirs_app_staging"></a>
staging Directory</h3>
<p>The final application bundle is simply an archive file containing the contents of the application's staging directory. The "update-pack" tool can be used to prepare this for delivery to a target device operating in the field.</p>
<p>The application's "staging" directory will contain the following files and directories:</p>
<ul>
<li>staging/read-only/ - read-only files.</li>
<li>staging/read-only/bin/ - executable files.</li>
<li>staging/read-only/lib/ - library files.</li>
<li>staging/writeable/ - writeable files listed in "bundles" sections of .cdef files and the .adef.</li>
<li>staging/root.cfg - Configuration settings for the "system" configuration tree.</li>
</ul>
<p>Finally, a file called "info.properties" is placed in the root of the staging directory. This file contains information about the application, such as the version of the Legato application framework that used to build the app and the application's <a class="el" href="class_m_d5.html">MD5</a> checksum. The file conforms to a strict subset of the standard Java .properties file format. The name and value on each line is always separated using an equals sign (=).</p>
<ul>
<li>staging/info.properties</li>
</ul>
<p>Note that the info.properties file is not included in the app's md5 checksum calculation (it can't because it contains the md5 checksum). This file is for use by development and deployment tools to display information to humans and to check whether an app file contains the same app that is installed on a device.</p>
<h2><a class="anchor" id="mkToolsDesign_workingDirs_api"></a>
api Directory</h2>
<p>For each .api file used, a directory will be created under the "api" directory. In that directory will be generated any source code files that could be shared between different components and interface instances.</p>
<p>To support the case where there are multiple .api files that share the same file name (but are kept in different directories), the generated api files are kept in a directory named with the <a class="el" href="class_m_d5.html">MD5</a> hash of the canonical path to the .api file.</p>
<p>For example, if the file foo.api is required and/or provided with the local instance name "prefix" (i.e., if "prefix = foo.api" appears in a Component.cdef), and the <a class="el" href="class_m_d5.html">MD5</a> hash of the canonical path of the foo.api file is b426b059840d56bd3ca8691607ce8c8c, then the following files will be created under the working directory, as needed:</p>
<ul>
<li>api/b426b059840d56bd3ca8691607ce8c8c/client/prefix_interface.h</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/client/prefix_messages.h</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/client/prefix_client.c</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/client/prefix_client.c.o</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/client/prefix_client.c.o.d</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/server/prefix_server.h</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/server/prefix_messages.h</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/server/prefix_server.c</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/server/prefix_server.c.o</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/server/prefix_server.c.o.d</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/async_server/prefix_server.h</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/async_server/prefix_messages.h</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/async_server/prefix_server.c</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/async_server/prefix_server.c.o</li>
<li>api/b426b059840d56bd3ca8691607ce8c8c/async_server/prefix_server.c.o.d</li>
</ul>
<h2><a class="anchor" id="mkToolsDesign_workingDirs_component"></a>
component Directory</h2>
<p>For each component used, a directory will be created under the "component" directory.</p>
<p>Different apps can share components with each other, so the components are built once, outside of the app directories. But, an app can also have a component that has the same name as a different component used by another app. For example, apps A and B can each have a different "foo" component. To prevent this from causing a conflict, while still supporting sharing of the same component, each component is built in a directory that is named using the md5 hash of the canonical path to the component's Component.cdef file.</p>
<ul>
<li>component/5b62d5ac3eab1b61af70dd41c2a17ad8/...</li>
</ul>
<p>Each component working directory contains these subdirectories:</p>
<ul>
<li>obj - generated object files specific to this component</li>
<li>src - generated source code files specific to this component</li>
</ul>
<p>For any C or C++ source file listed in the "sources" section of the Component.cdef, a .o file will be created under the "obj" directory. To prevent conflicts when there are multiple .c files with the same name, the .o file is named with the <a class="el" href="class_m_d5.html">MD5</a> sum of the path to the source code file. For example:</p>
<ul>
<li>component/5b62d5ac3eab1b61af70dd41c2a17ad8/obj/a97795c626103bc8b140854afdd27948.o</li>
</ul>
<h2><a class="anchor" id="mkToolsDesign_workingDirs_app_exe_comp"></a>
Working Directories for mkapp, mkexe and mkcomp</h2>
<p>The mkapp tool's working directory structure is essentially the same as mksys's, except that there is no system staging directory and the 'app/&lt;app-name&gt;' directory contents are moved to the top level.</p>
<ul>
<li>src/ - generated source code specific to this application</li>
<li>obj/ - generated object files specific to this application</li>
<li>staging/ - directories and files to be installed on target</li>
<li>component/ - working directories for the components.</li>
<li>api/ - working directories for generated api files.</li>
</ul>
<p>The mkexe and mkcomp tools have similar working directory structures to mkapp's working directory structure, but without the "staging" directory. The "staging" directory isn't needed because these tools don't bundle all their output together into a single file like mkapp and mksys do. Instead, the command line is used to provide file paths for the locations where generated library files and/or executables should be put.</p>
<dl class="section note"><dt>Note</dt><dd>In the future, the component's "staging" directory may be used by mkcomp when building distributable component bundles.</dd></dl>
<h1><a class="anchor" id="mkToolsDesign_MemoryManagement"></a>
Memory Management</h1>
<p>Objects in the parse tree and the conceptual model are created using 'new' and plain pointers are used to refer to them.</p>
<p>Essentially, nothing in the parse tree or the conceptual model is deleted, so destructors and smart pointers are unnecessary.</p>
<p>Because pointers are used as references and everything of significance is allocated from the heap, there's no need for copy or move constructors or operators.</p>
<p>Also, the program is short-lived, so memory leaks are not a concern.</p>
<h1><a class="anchor" id="mkToolsDesign_FutureEnhancements"></a>
Future Enhancements</h1>
<p>To offer an automatic definition file upgrade feature, Translators can be created to generate the latest version of definition files from the various versions of Parse Trees that are supported. E.g., parse using old version, then modify the parse tree to the new version and regenerate the file.</p>
<p>Digital signing of system and application update files can be added to the update-pack stage of the build.</p>
<p>We could allow the "bundles" section to be used in the .sdef. This would allow applications to share files by using their "requires" section to bind-mount those files into their sandboxes.</p>
<p>The mksys tool could analyze all the apps and identify any identical files that appear in more than one app with read-only permissions. These files could be moved to a "staging/share" directory under the system's working directory and a "requires" bind-mount could be added to the applications' root.cfg files to make them available to the applications.</p>
<hr/>
<p>Copyright (C) Sierra Wireless Inc. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
