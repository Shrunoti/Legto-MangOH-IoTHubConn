<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: framework/liblegato/linux/eventLoop.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('event_loop_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">eventLoop.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="legato_8h_source.html">legato.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="event_loop_8h_source.html">eventLoop.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="thread_8h_source.html">thread.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fd_monitor_8h_source.html">fdMonitor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="limit_8h_source.html">limit.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="file_descriptor_8h_source.html">fileDescriptor.h</a>&quot;</code><br />
<code>#include &lt;pthread.h&gt;</code><br />
<code>#include &lt;sys/eventfd.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_event__t.html">Event_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_handler__t.html">Handler_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_report__t.html">Report_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_pub_sub_event_report__t.html">PubSubEventReport_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_queued_function_report__t.html">QueuedFunctionReport_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afc006591e1289be0aef777083bf22b8a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#afc006591e1289be0aef777083bf22b8a">MAX_EPOLL_EVENTS</a>&#160;&#160;&#160;32</td></tr>
<tr class="memdesc:afc006591e1289be0aef777083bf22b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of events that can be received from epoll_wait() at one time.  <a href="#afc006591e1289be0aef777083bf22b8a">More...</a><br /></td></tr>
<tr class="separator:afc006591e1289be0aef777083bf22b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b1dafb589cb517c72e928a91456f9d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a56b1dafb589cb517c72e928a91456f9d">DEFAULT_QUEUED_FUNCTION_POOL_SIZE</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:a56b1dafb589cb517c72e928a91456f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94a9c4d23e95d17f4a8efbdab735ba22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a94a9c4d23e95d17f4a8efbdab735ba22">DEFAULT_REPORT_POOL_SIZE</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a94a9c4d23e95d17f4a8efbdab735ba22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d13db8d6554c3f06eef4f1e3871e8b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#ac5d13db8d6554c3f06eef4f1e3871e8b">DEFAULT_HANDLER_POOL_SIZE</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:ac5d13db8d6554c3f06eef4f1e3871e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d6efcf53ecee3acba66177ce2d7340"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#ac3d6efcf53ecee3acba66177ce2d7340">DEFAULT_EVENT_POOL_SIZE</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:ac3d6efcf53ecee3acba66177ce2d7340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6aa8edcd99914757600b5d3b259bb7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a5f6aa8edcd99914757600b5d3b259bb7">TRACE</a>(...)&#160;&#160;&#160;<a class="el" href="le__log_8h.html#a331fb6c78ccddeafc455ad9c64e42008">LE_TRACE</a>(<a class="el" href="timer_8c.html#a84d541f37420ace8bdf697deca689deb">TraceRef</a>, ##__VA_ARGS__)</td></tr>
<tr class="separator:a5f6aa8edcd99914757600b5d3b259bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6aa6009a5d10e60073e8a02b4d55823a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a6aa6009a5d10e60073e8a02b4d55823a">EventReportType_t</a> { <a class="el" href="event_loop_8c.html#a6aa6009a5d10e60073e8a02b4d55823aa75db70ed276e35b29de3abd962b4d0da">LE_EVENT_REPORT_PLAIN</a>, 
<a class="el" href="event_loop_8c.html#a6aa6009a5d10e60073e8a02b4d55823aacf432e547f386226407301e46a24acb2">LE_EVENT_REPORT_COUNTED_REF</a>, 
<a class="el" href="event_loop_8c.html#a6aa6009a5d10e60073e8a02b4d55823aa5c4f67bf1cc09f270e328765f134780b">LE_EVENT_REPORT_QUEUED_FUNC</a>
 }</td></tr>
<tr class="separator:a6aa6009a5d10e60073e8a02b4d55823a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af0723d6a1abc51cacd316dd0bbddd407"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#af0723d6a1abc51cacd316dd0bbddd407">Lock</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:af0723d6a1abc51cacd316dd0bbddd407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84b4170029c14cdc1433dc933a9096f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#ae84b4170029c14cdc1433dc933a9096f">Unlock</a> (int restoreTo)</td></tr>
<tr class="separator:ae84b4170029c14cdc1433dc933a9096f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420b6126203dae423f97289aa242afbf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_event__t.html">Event_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a420b6126203dae423f97289aa242afbf">CreateEvent</a> (const char *name, size_t payloadSize, bool isRefCounted)</td></tr>
<tr class="separator:a420b6126203dae423f97289aa242afbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e310bc4bc89aa40a11d47c27eac775b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a1e310bc4bc89aa40a11d47c27eac775b">DeleteHandler</a> (<a class="el" href="struct_handler__t.html">Handler_t</a> *handlerPtr)</td></tr>
<tr class="separator:a1e310bc4bc89aa40a11d47c27eac775b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ac93e53ebd4d4562663fe52b8861f5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a30ac93e53ebd4d4562663fe52b8861f5">WriteEventFd</a> (<a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a> *perThreadRecPtr)</td></tr>
<tr class="separator:a30ac93e53ebd4d4562663fe52b8861f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabc84fd2037d7af4f5beae690720b8f4"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#aabc84fd2037d7af4f5beae690720b8f4">ReadEventFd</a> (<a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a> *perThreadRecPtr)</td></tr>
<tr class="separator:aabc84fd2037d7af4f5beae690720b8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0618e90ba973977bcb7e479c6b5476fd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a0618e90ba973977bcb7e479c6b5476fd">ProcessOneEventReport</a> (<a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a> *perThreadRecPtr)</td></tr>
<tr class="separator:a0618e90ba973977bcb7e479c6b5476fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e664761de3a3f9efb889a806ee4665"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#ab2e664761de3a3f9efb889a806ee4665">ProcessEventReports</a> (<a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a> *perThreadRecPtr)</td></tr>
<tr class="separator:ab2e664761de3a3f9efb889a806ee4665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ea7c0ab19c26ec37856296dac352b6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a74ea7c0ab19c26ec37856296dac352b6">PubSubHandlerFunc</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *reportPtr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *secondLayerFunc)</td></tr>
<tr class="separator:a74ea7c0ab19c26ec37856296dac352b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055d1d094daf1aad03623bc37c0f748d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a055d1d094daf1aad03623bc37c0f748d">QueueFunction</a> (<a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a> *perThreadRecPtr, <a class="el" href="le__event_loop_8h.html#a6f86581d4d2bf24647d5efaff1046d5d">le_event_DeferredFunc_t</a> func, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *param1Ptr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *param2Ptr)</td></tr>
<tr class="separator:a055d1d094daf1aad03623bc37c0f748d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771d94c450093d2eecc38b567d1d4db2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a771d94c450093d2eecc38b567d1d4db2">CallComponentInitializer</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *param1Ptr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *param2Ptr)</td></tr>
<tr class="separator:a771d94c450093d2eecc38b567d1d4db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6df48de0849c25c65fbbe990e2373c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a3b6df48de0849c25c65fbbe990e2373c">event_Init</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a3b6df48de0849c25c65fbbe990e2373c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6e9dfa4a3132be6af0ddc596a0b5ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a4a6e9dfa4a3132be6af0ddc596a0b5ae">event_InitThread</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a4a6e9dfa4a3132be6af0ddc596a0b5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f47538628b95ec110d84f607f2c902d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a0f47538628b95ec110d84f607f2c902d">event_QueueComponentInit</a> (const <a class="el" href="event_loop_8h.html#a3c98aee63f730f59025a7cc80d26ea33">event_ComponentInitFunc_t</a> func)</td></tr>
<tr class="separator:a0f47538628b95ec110d84f607f2c902d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad107c64cf0b47b44adf77712c7fcbdd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#ad107c64cf0b47b44adf77712c7fcbdd3">event_DestructThread</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:ad107c64cf0b47b44adf77712c7fcbdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7408cd46c9bfcfe353d49e44d59885d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a7408cd46c9bfcfe353d49e44d59885d7">event_SetCurrentContextPtr</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *contextPtr)</td></tr>
<tr class="separator:a7408cd46c9bfcfe353d49e44d59885d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a96eb3affb07184b519164cf54e213"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a41a96eb3affb07184b519164cf54e213">le_event_CreateId</a> (const char *name, size_t payloadSize)</td></tr>
<tr class="separator:a41a96eb3affb07184b519164cf54e213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bef8276ad0e911fd84fb710d58ca2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a31bef8276ad0e911fd84fb710d58ca2b">le_event_CreateIdWithRefCounting</a> (const char *name)</td></tr>
<tr class="separator:a31bef8276ad0e911fd84fb710d58ca2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae65a65b4111618f47d7e6d57a48289e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#ae65a65b4111618f47d7e6d57a48289e5">le_event_AddHandler</a> (const char *name, <a class="el" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a> eventId, <a class="el" href="le__event_loop_8h.html#ada421dec46f51fcb3421ef7058f16944">le_event_HandlerFunc_t</a> handlerFunc)</td></tr>
<tr class="separator:ae65a65b4111618f47d7e6d57a48289e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b906d38935f64953482f42c745e1c18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a8b906d38935f64953482f42c745e1c18">le_event_AddLayeredHandler</a> (const char *name, <a class="el" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a> eventId, <a class="el" href="le__event_loop_8h.html#a325afcc96343fde371e4c63639ace2ef">le_event_LayeredHandlerFunc_t</a> firstLayerFunc, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *secondLayerFunc)</td></tr>
<tr class="separator:a8b906d38935f64953482f42c745e1c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31a85d4acbef72451b5411a613eea58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#ae31a85d4acbef72451b5411a613eea58">le_event_RemoveHandler</a> (<a class="el" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a> handlerRef)</td></tr>
<tr class="separator:ae31a85d4acbef72451b5411a613eea58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ffe6990b70fb572b4eef06739b4f54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#ae3ffe6990b70fb572b4eef06739b4f54">le_event_Report</a> (<a class="el" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a> eventId, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *<a class="el" href="log_tool_8c.html#ad6392d3bc0da4dd08be44c538eb44b32">payloadPtr</a>, size_t payloadSize)</td></tr>
<tr class="separator:ae3ffe6990b70fb572b4eef06739b4f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0277165493b512216fabb6086ec7d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#af0277165493b512216fabb6086ec7d9c">le_event_ReportWithRefCounting</a> (<a class="el" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a> eventId, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *objectPtr)</td></tr>
<tr class="separator:af0277165493b512216fabb6086ec7d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c4307a9715794c720e525032aa0bfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#ae0c4307a9715794c720e525032aa0bfd">le_event_SetContextPtr</a> (<a class="el" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a> handlerRef, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *contextPtr)</td></tr>
<tr class="separator:ae0c4307a9715794c720e525032aa0bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c73916295cc9e17af07e02756aa86c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a1c73916295cc9e17af07e02756aa86c9">le_event_GetContextPtr</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a1c73916295cc9e17af07e02756aa86c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcc88f96060c5bc107a81a978132f38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a6dcc88f96060c5bc107a81a978132f38">le_event_QueueFunction</a> (<a class="el" href="le__event_loop_8h.html#a6f86581d4d2bf24647d5efaff1046d5d">le_event_DeferredFunc_t</a> func, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *param1Ptr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *param2Ptr)</td></tr>
<tr class="separator:a6dcc88f96060c5bc107a81a978132f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228da2d1f53ffa74517f108b0dcfa4d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a228da2d1f53ffa74517f108b0dcfa4d9">le_event_QueueFunctionToThread</a> (<a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> thread, <a class="el" href="le__event_loop_8h.html#a6f86581d4d2bf24647d5efaff1046d5d">le_event_DeferredFunc_t</a> func, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *param1Ptr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *param2Ptr)</td></tr>
<tr class="separator:a228da2d1f53ffa74517f108b0dcfa4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae313b457994371c658be9fe0494a01ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#ae313b457994371c658be9fe0494a01ff">le_event_RunLoop</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:ae313b457994371c658be9fe0494a01ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ce7f92f4bc6f5167d5a6ef86d7d0b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a12ce7f92f4bc6f5167d5a6ef86d7d0b1">le_event_GetFd</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a12ce7f92f4bc6f5167d5a6ef86d7d0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096222e98f6a0d92a79722018a752b58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a096222e98f6a0d92a79722018a752b58">le_event_ServiceLoop</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a096222e98f6a0d92a79722018a752b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2811b51fca595f9625be30902820816c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a2811b51fca595f9625be30902820816c">EventPool</a></td></tr>
<tr class="separator:a2811b51fca595f9625be30902820816c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde56bfeae36bd92d3cfdb4df30267d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structle__sls___list__t.html">le_sls_List_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#abde56bfeae36bd92d3cfdb4df30267d6">EventList</a> = <a class="el" href="le__singly_linked_list_8h.html#a2e1013c24e2c826dbba37a761c5d9f44">LE_SLS_LIST_INIT</a></td></tr>
<tr class="separator:abde56bfeae36bd92d3cfdb4df30267d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064d209e4eaa951f501a7ca768d37300"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a064d209e4eaa951f501a7ca768d37300">HandlerPool</a></td></tr>
<tr class="separator:a064d209e4eaa951f501a7ca768d37300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e7e634b1ab8f7cf1f52c70d45c5a2e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a04e7e634b1ab8f7cf1f52c70d45c5a2e">QueuedFunctionPool</a></td></tr>
<tr class="separator:a04e7e634b1ab8f7cf1f52c70d45c5a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dad78d8cec4a7bf55097f99f3bd5567"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__safe_ref_8h.html#aaf8fb3412fb840cb50366856affaf69b">le_ref_MapRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a3dad78d8cec4a7bf55097f99f3bd5567">EventRefMap</a></td></tr>
<tr class="separator:a3dad78d8cec4a7bf55097f99f3bd5567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4c388ffca0e59babf74ee12bd18f13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__safe_ref_8h.html#aaf8fb3412fb840cb50366856affaf69b">le_ref_MapRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a9c4c388ffca0e59babf74ee12bd18f13">HandlerRefMap</a></td></tr>
<tr class="separator:a9c4c388ffca0e59babf74ee12bd18f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc03085ccf7c38e092cdf06bf6b98ea6"><td class="memItemLeft" align="right" valign="top">static pthread_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#abc03085ccf7c38e092cdf06bf6b98ea6">Mutex</a> = PTHREAD_MUTEX_INITIALIZER</td></tr>
<tr class="separator:abc03085ccf7c38e092cdf06bf6b98ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d541f37420ace8bdf697deca689deb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__log_8h.html#a055e29785e8d1c5bf1b3a230df8d65b7">le_log_TraceRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="event_loop_8c.html#a84d541f37420ace8bdf697deca689deb">TraceRef</a></td></tr>
<tr class="separator:a84d541f37420ace8bdf697deca689deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Legato <a class="el" href="c_eventLoop.html">Event Loop API</a> implementation. </p><hr/>
<h1><a class="anchor" id="eventLoop_EventIds"></a>
Event IDs</h1>
<p>Note that Event IDs are actually Safe References (see <a class="el" href="c_safeRef.html">Safe References API</a>). Safe References are also used for Handler References. </p><hr/>
<h1><a class="anchor" id="eventLoop_DataStructures"></a>
Data Structures</h1>
<p>The main classes in this implementation are:</p>
<ul>
<li><b> Events </b> - One per Event ID, these keep track of the ID and what Handlers are registered against them. They also each have a pool from which their Reports are allocated. Note: Events are never deleted.</li>
<li><b> Handlers </b> - One per registered handler function. These keep track of the function, the diagnostic name, the context pointer, and what thread is supposed to run the handler.</li>
<li><b> Reports </b> - Objects containing actual event report payload. These objects are what get queued onto a thread's Event Queue.</li>
</ul>
<p>In addition, thread-specific data structures are kept in a special <b> Per-Thread Record </b>, which the thread module keeps inside the Thread object on our behalf (we can fetch a pointer to it by calling <a class="el" href="thread_8c.html#a5938f5ecc8545e73e10e8d1f17f73c87">thread_GetEventRecPtr()</a> ). See <a class="el" href="event_loop_8h.html">eventLoop.h</a> for more information.</p>
<pre class="fragment">*
*      Thread ---&gt; Per-Thread Record --+--&gt; Event Queue --+--&gt; Report
*         ^                            |
*         |                            +--&gt; Handler List --+---------+
*         |                                                          |
*         +----------------------------------------------------+     |
*                                                              |     |
*                          +-------------------------------+   |     |
*                          |                               |   |     |
*                          V                               |   |     |
*      Event List --+--&gt; Event --+--&gt; Handler List --+--&gt; Handler &lt;--+
*                                |
*                                +--&gt; ID
*                                |
*                                +--&gt; Report Pool
* </pre><h1><a class="anchor" id="eventLoop_LinuxImplementation"></a>
Linux Event Loop Implementation</h1>
<p>There are two types of Event Report that can be added to an Event Queue:</p>
<ul>
<li>Queued Function</li>
<li>Publish-Subscribe Event Report - Different size objects, depending on what payload they carry.</li>
</ul>
<p>All the different types of Event Report all have the same base structure. Their payload is different, though.</p>
<p>The Event Loop for each thread uses an epoll fd to test for events (see 'man epoll').</p>
<p>Included in the set of file descriptors that are being monitored by epoll is an eventfd (see 'man eventfd') monitored in "level-triggered" mode.</p>
<p>Whenever an Event Report is added to the Event Queue for a thread, the number 1 is written to that thread's eventfd. When Event Reports are popped off a thread's Event Queue, that thread's eventfd is read to decrement it. As long as the eventfd's value is greater than 0, epoll_wait() will return immediately, reporting that there is something to read from that fd.</p>
<p>The Event Loop is an infinite loop that calls epoll_wait() and then responds to any fd events that epoll_wait() reports. If epoll_wait() reports an event on the eventfd, then an Event Report is popped off the Event Queue and processed. If epoll_wait() reports an event on any other fd, FD Event Reports are created and pushed onto Event Queues according to what handlers are registered for those events. All pending Event Reports are processed until the Event Queue is empty before returning to epoll_wait(). (NOTE: This choice was made to save system call overhead in times of heavy load. Unfortunately, it also means that if event handlers always add new events to the queue, then epoll_wait() will never be called and therefore fd events will never be detected.) </p><hr/>
<h1><a class="anchor" id="eventLoop_Multithreading"></a>
Multithreading</h1>
<p>Everything can be shared between multiple threads, and therefore must be protected from multithreaded race conditions. A Mutex is provided for that purpose, and it can be locked and unlocked using the functions <a class="el" href="event_loop_8c.html#af0723d6a1abc51cacd316dd0bbddd407">Lock()</a> and <a class="el" href="event_loop_8c.html#ae84b4170029c14cdc1433dc933a9096f">Unlock()</a>. </p><hr/>
<p>Copyright (C) Sierra Wireless Inc. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ac3d6efcf53ecee3acba66177ce2d7340"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_EVENT_POOL_SIZE&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default number of objects in the process-wide Event Pool, from which the Event objects are allocated. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000033">Todo:</a></b></dt><dd>Make this configurable. </dd></dl>

</div>
</div>
<a class="anchor" id="ac5d13db8d6554c3f06eef4f1e3871e8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_HANDLER_POOL_SIZE&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default number of objects in the process-wide Handler Pool, from which all Handler objects are allocated. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000032">Todo:</a></b></dt><dd>Make this configurable. </dd></dl>

</div>
</div>
<a class="anchor" id="a56b1dafb589cb517c72e928a91456f9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_QUEUED_FUNCTION_POOL_SIZE&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default number of objects in the process-wide Queued Function Report Pool, from which Queued Function reports are allocated. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000030">Todo:</a></b></dt><dd>Make this configurable. </dd></dl>

</div>
</div>
<a class="anchor" id="a94a9c4d23e95d17f4a8efbdab735ba22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DEFAULT_REPORT_POOL_SIZE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The default number of objects in a per-Event-ID Report Pool. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000031">Todo:</a></b></dt><dd>Make this configurable. </dd></dl>

</div>
</div>
<a class="anchor" id="afc006591e1289be0aef777083bf22b8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_EPOLL_EVENTS&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of events that can be received from epoll_wait() at one time. </p>

</div>
</div>
<a class="anchor" id="a5f6aa8edcd99914757600b5d3b259bb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TRACE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="le__log_8h.html#a331fb6c78ccddeafc455ad9c64e42008">LE_TRACE</a>(<a class="el" href="timer_8c.html#a84d541f37420ace8bdf697deca689deb">TraceRef</a>, ##__VA_ARGS__)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Macro used to generate trace output in this module. Takes the same parameters as <a class="el" href="le__log_8h.html#a2a91ea8857cf190fde71d85ba930a498" title="Debug message. ">LE_DEBUG()</a> et. al. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a6aa6009a5d10e60073e8a02b4d55823a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="event_loop_8c.html#a6aa6009a5d10e60073e8a02b4d55823a">EventReportType_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerates the different types of Event Report. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a6aa6009a5d10e60073e8a02b4d55823aa75db70ed276e35b29de3abd962b4d0da"></a>LE_EVENT_REPORT_PLAIN&#160;</td><td class="fielddoc">
<p>Publish-Subscribe Event Report containing plain-old data. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6aa6009a5d10e60073e8a02b4d55823aacf432e547f386226407301e46a24acb2"></a>LE_EVENT_REPORT_COUNTED_REF&#160;</td><td class="fielddoc">
<p>Publish-Subscribe Event Report containing poiner to reference-counted object allocated from a memory pool. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a6aa6009a5d10e60073e8a02b4d55823aa5c4f67bf1cc09f270e328765f134780b"></a>LE_EVENT_REPORT_QUEUED_FUNC&#160;</td><td class="fielddoc">
<p>Queued Function. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a771d94c450093d2eecc38b567d1d4db2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> CallComponentInitializer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>param1Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>param2Ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queued function that executes a component initialization handler function whose address is passed in as the first parameter to the queued function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param1Ptr</td><td>Pointer to the component's initialization function. </td></tr>
    <tr><td class="paramname">param2Ptr</td><td>not used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a420b6126203dae423f97289aa242afbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_event__t.html">Event_t</a>* CreateEvent </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>payloadSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isRefCounted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new Event object.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the Event object.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Doesn't return on failure, so there's no need to check the return value for errors. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000034">Todo:</a></b></dt><dd>Make this configurable. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the event ID. (Named for diagnostic purposes.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">payloadSize</td><td>Data payload size (in bytes) of the event reports (can be 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isRefCounted</td><td>true = the payload will be a pointer to a ref-counted object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e310bc4bc89aa40a11d47c27eac775b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> DeleteHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_handler__t.html">Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handlerPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes a Handler object.</p>
<dl class="section warning"><dt>Warning</dt><dd>Assumes that the Mutex lock is already held. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerPtr</td><td>Pointer to the handler to be deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad107c64cf0b47b44adf77712c7fcbdd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> event_DestructThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destruct the Event Loop for a given thread.</p>
<p>This function must be called exactly once at thread shutdown, after any other Event module or Event Loop API functions are called by that thread, and before the Thread object is deleted. </p>

</div>
</div>
<a class="anchor" id="a3b6df48de0849c25c65fbbe990e2373c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> event_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the Event Loop module.</p>
<p>This function must be called exactly once at process start-up, before any other Event module or Event Loop API functions are called. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000035">Todo:</a></b></dt><dd>Make this configurable. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000036">Todo:</a></b></dt><dd>Make this configurable. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000037">Todo:</a></b></dt><dd>Make this configurable. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000038">Todo:</a></b></dt><dd>Make this configurable. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a6e9dfa4a3132be6af0ddc596a0b5ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> event_InitThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the Event Loop for a given thread.</p>
<p>This function must be called exactly once at thread start-up, before any other Event module or Event Loop API functions (other than <a class="el" href="event_loop_8c.html#a3b6df48de0849c25c65fbbe990e2373c">event_Init()</a> ) are called by that thread.</p>
<dl class="section note"><dt>Note</dt><dd>The process main thread must call <a class="el" href="event_loop_8c.html#a3b6df48de0849c25c65fbbe990e2373c">event_Init()</a> first, then <a class="el" href="event_loop_8c.html#a4a6e9dfa4a3132be6af0ddc596a0b5ae">event_InitThread()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f47538628b95ec110d84f607f2c902d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> event_QueueComponentInit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="event_loop_8h.html#a3c98aee63f730f59025a7cc80d26ea33">event_ComponentInitFunc_t</a>&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defer the component initializer for later execution.</p>
<p>This function must be called at process start-up, before le_event_Runloop() is called for the main thread.</p>
<p>It takes a pointer to a Component Initialization Functions to be called when the event loop is started (i.e., when <a class="el" href="event_loop_8c.html#ae313b457994371c658be9fe0494a01ff">le_event_RunLoop()</a> is called) for the process's main thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The initialization function to call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7408cd46c9bfcfe353d49e44d59885d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> event_SetCurrentContextPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>contextPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the context pointer for the currently running thread.</p>
<p>This can later be retrieved using <a class="el" href="event_loop_8c.html#a1c73916295cc9e17af07e02756aa86c9">le_event_GetContextPtr()</a> from within the same thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td>Context pointer value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae65a65b4111618f47d7e6d57a48289e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a> le_event_AddHandler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a>&#160;</td>
          <td class="paramname"><em>eventId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__event_loop_8h.html#ada421dec46f51fcb3421ef7058f16944">le_event_HandlerFunc_t</a>&#160;</td>
          <td class="paramname"><em>handlerFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a handler function for a publish-subscribe event ID.</p>
<p>Tells the calling thread's event loop to call a given handler function when a given event reaches the front of the event queue.</p>
<dl class="section return"><dt>Returns</dt><dd>A handler reference, which is only needed for later removal of the handler (using <a class="el" href="event_loop_8c.html#ae31a85d4acbef72451b5411a613eea58">le_event_RemoveHandler()</a> ). Can be ignored if the handler will never be removed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Doesn't return on failure, so there's no need to check the return value for errors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventId</td><td>The event ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerFunc</td><td>Handler function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b906d38935f64953482f42c745e1c18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a> le_event_AddLayeredHandler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a>&#160;</td>
          <td class="paramname"><em>eventId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__event_loop_8h.html#a325afcc96343fde371e4c63639ace2ef">le_event_LayeredHandlerFunc_t</a>&#160;</td>
          <td class="paramname"><em>firstLayerFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>secondLayerFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a layered handler function for a publish-subscribe event ID.</p>
<p>Tells the calling thread's event loop to call a given handler function when a given event reaches the front of the event queue. Passes another handler function to that handler function when it is called.</p>
<p>This is intended for use in implementing c_event_LayeredHandlers.</p>
<dl class="section return"><dt>Returns</dt><dd>A handler reference, which is only needed for later removal of the handler (using <a class="el" href="event_loop_8c.html#ae31a85d4acbef72451b5411a613eea58">le_event_RemoveHandler()</a> ). Can be ignored if the handler will never be removed.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Doesn't return on failure, so there's no need to check the return value for errors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The name of the handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eventId</td><td>The event ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstLayerFunc</td><td>Pointer to first-layer handler func. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondLayerFunc</td><td>Pointer to second-layer handler func. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a41a96eb3affb07184b519164cf54e213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a> le_event_CreateId </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>payloadSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new event ID.</p>
<dl class="section return"><dt>Returns</dt><dd>Event ID.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Doesn't return on failure, so there's no need to check the return value for errors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the event ID. (Named for diagnostic purposes.) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">payloadSize</td><td>Data payload size (in bytes) of the event reports (can be 0). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a31bef8276ad0e911fd84fb710d58ca2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a> le_event_CreateIdWithRefCounting </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new event ID that can be used to report events whose payload is a pointer to a reference-counted memory pool object that was allocated using the <a class="el" href="c_memory.html">Dynamic Memory Allocation API</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Event ID.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Doesn't return on failure, so there's no need to check the return value for errors. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the event ID. (Named for diagnostic purposes.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c73916295cc9e17af07e02756aa86c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* le_event_GetContextPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches the context pointer for the currently running event handler.</p>
<p>Can only be called from within an event handler function.</p>
<dl class="section return"><dt>Returns</dt><dd>The context pointer that was provided when the event handler was "added". </dd></dl>

</div>
</div>
<a class="anchor" id="a12ce7f92f4bc6f5167d5a6ef86d7d0b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int le_event_GetFd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches a file descriptor that will appear readable to poll() and select() when the calling thread's Event Loop needs servicing (via a call to <a class="el" href="event_loop_8c.html#a096222e98f6a0d92a79722018a752b58">le_event_ServiceLoop()</a>).</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is only intended for use when integrating with legacy POSIX-based software that cannot be easily refactored to use the Legato Event Loop. The preferred approach is to call <a class="el" href="event_loop_8c.html#ae313b457994371c658be9fe0494a01ff">le_event_RunLoop()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The file descriptor. </dd></dl>

</div>
</div>
<a class="anchor" id="a6dcc88f96060c5bc107a81a978132f38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_event_QueueFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__event_loop_8h.html#a6f86581d4d2bf24647d5efaff1046d5d">le_event_DeferredFunc_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>param1Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>param2Ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queue a function onto the calling thread's Event Queue. When it reaches the head of the Event Queue, it will be called by the calling thread's Event Loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to be called later. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param1Ptr</td><td>Value to be passed to the function when called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param2Ptr</td><td>Value to be passed to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a228da2d1f53ffa74517f108b0dcfa4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_event_QueueFunctionToThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__event_loop_8h.html#a6f86581d4d2bf24647d5efaff1046d5d">le_event_DeferredFunc_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>param1Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>param2Ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queue a function onto a specific thread's Event Queue. When it reaches the head of that Event Queue, it will be called by that thread's Event Loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The thread to queue the function to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param1Ptr</td><td>Value to be passed to the function when called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param2Ptr</td><td>Value to be passed to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae31a85d4acbef72451b5411a613eea58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_event_RemoveHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a>&#160;</td>
          <td class="paramname"><em>handlerRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove Handler</p>
<p>Removes a previously added event handler function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerRef</td><td>Handler reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3ffe6990b70fb572b4eef06739b4f54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_event_Report </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a>&#160;</td>
          <td class="paramname"><em>eventId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>payloadPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>payloadSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Report an Event</p>
<p>Queues an Event Report to any and all event loops that have handlers for that event.</p>
<dl class="section note"><dt>Note</dt><dd>This copies the event report payload, so it is safe to release or reuse the buffer that payloadPtr points to as soon as <a class="el" href="event_loop_8c.html#ae3ffe6990b70fb572b4eef06739b4f54">le_event_Report()</a> returns. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eventId</td><td>The event ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">payloadPtr</td><td>Pointer to the payload bytes to be copied into the report. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">payloadSize</td><td>The number of bytes of payload to copy into the report. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0277165493b512216fabb6086ec7d9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_event_ReportWithRefCounting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__event_loop_8h.html#ae6e351b38bc95954f159d16d19d2d55c">le_event_Id_t</a>&#160;</td>
          <td class="paramname"><em>eventId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>objectPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends an Event Report with a pointer to a reference-counted object as its payload. The pointer must have been obtained from a memory pool using the <a class="el" href="c_memory.html">Dynamic Memory Allocation API</a>.</p>
<p>The Event Loop API will ensure that the reference is properly counted while it passes through the event report dispatching system. Each handler will receive one counted reference to the object, which the handler will then be responsible for releasing. Do not release the reference that you pass into <a class="el" href="event_loop_8c.html#af0277165493b512216fabb6086ec7d9c">le_event_ReportWithRefCounting()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eventId</td><td>The event ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objectPtr</td><td>Pointer to an object allocated from a memory pool (using the <a class="el" href="c_memory.html">Dynamic Memory Allocation API</a>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae313b457994371c658be9fe0494a01ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_event_RunLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs the event loop for the calling thread.</p>
<p>This starts the processing of events by the calling thread.</p>
<p>This function can only be called at most once for each thread, and must never be called in the process's main thread.</p>
<dl class="section note"><dt>Note</dt><dd>This function never returns. </dd></dl>

</div>
</div>
<a class="anchor" id="a096222e98f6a0d92a79722018a752b58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_event_ServiceLoop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Services the calling thread's Event Loop.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function is only intended for use when integrating with legacy POSIX-based software that cannot be easily refactored to use the Legato Event Loop. The preferred approach is to call <a class="el" href="event_loop_8c.html#ae313b457994371c658be9fe0494a01ff">le_event_RunLoop()</a>.</dd></dl>
<p>See also: <a class="el" href="event_loop_8c.html#a12ce7f92f4bc6f5167d5a6ef86d7d0b1">le_event_GetFd()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if there is more to be done.</li>
<li>LE_WOULD_BLOCK if there were no events to process. </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ae0c4307a9715794c720e525032aa0bfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_event_SetContextPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__event_loop_8h.html#ae7ab96b8e3441b3d484fcf52aa7a9dad">le_event_HandlerRef_t</a>&#160;</td>
          <td class="paramname"><em>handlerRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>contextPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the context pointer for a given event handler.</p>
<p>This can later be retrieved using <a class="el" href="event_loop_8c.html#a1c73916295cc9e17af07e02756aa86c9">le_event_GetContextPtr()</a> from within the handler function when it is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerRef</td><td>Handler whose context pointer is to be set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td>Context pointer value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0723d6a1abc51cacd316dd0bbddd407"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Guards against thread cancellation and locks the mutex.</p>
<dl class="section return"><dt>Returns</dt><dd>Old state of cancelability. </dd></dl>

</div>
</div>
<a class="anchor" id="ab2e664761de3a3f9efb889a806ee4665"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> ProcessEventReports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a> *&#160;</td>
          <td class="paramname"><em>perThreadRecPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Process Event Reports from the calling thread's Event Queue until the queue is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">perThreadRecPtr</td><td>Ptr to the calling thread's per-thread record. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0618e90ba973977bcb7e479c6b5476fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> ProcessOneEventReport </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a> *&#160;</td>
          <td class="paramname"><em>perThreadRecPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Process one event report from the calling thread's Event Queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">perThreadRecPtr</td><td>Ptr to the calling thread's per-thread record. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74ea7c0ab19c26ec37856296dac352b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> PubSubHandlerFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>reportPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>secondLayerFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>First-layer handler function that is used to implement the single-layer API using the two-layer API.</p>
<p>When someone registers a one-layer handler function using <a class="el" href="event_loop_8c.html#ae65a65b4111618f47d7e6d57a48289e5">le_event_AddHandler()</a>, <a class="el" href="event_loop_8c.html#ae65a65b4111618f47d7e6d57a48289e5">le_event_AddHandler()</a> calls <a class="el" href="event_loop_8c.html#a8b906d38935f64953482f42c745e1c18">le_event_AddLayeredHandler()</a> with this function as the first layer handler function and the actual (client) handler function as the second layer function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reportPtr</td><td>Pointer to the report payload. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondLayerFunc</td><td>Address of the client's handler function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a055d1d094daf1aad03623bc37c0f748d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> QueueFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a> *&#160;</td>
          <td class="paramname"><em>perThreadRecPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__event_loop_8h.html#a6f86581d4d2bf24647d5efaff1046d5d">le_event_DeferredFunc_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>param1Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>param2Ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Queue a function onto a specific thread's Event Queue (could belong to the calling thread or could belong to some other thread).</p>
<dl class="section warning"><dt>Warning</dt><dd>Assumes the mutex is locked and the thread is protected from cancellation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">perThreadRecPtr</td><td>Pointer to the thread's event data record. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function to be called later. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param1Ptr</td><td>Value to be passed to the function when called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param2Ptr</td><td>Value to be passed to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aabc84fd2037d7af4f5beae690720b8f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t ReadEventFd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a> *&#160;</td>
          <td class="paramname"><em>perThreadRecPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a thread's Event File Descriptor. This fetches the value of the Event FD (which is the number of event reports on the Event Queue) and resets the Event FD value to zero.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of Event Reports on the thread's Event Queue. </dd></dl>

</div>
</div>
<a class="anchor" id="ae84b4170029c14cdc1433dc933a9096f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> Unlock </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>restoreTo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlocks the mutex and releases the thread cancellation guard created by <a class="el" href="event_loop_8c.html#af0723d6a1abc51cacd316dd0bbddd407">Lock()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">restoreTo</td><td>Old state of cancellability to be restored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a30ac93e53ebd4d4562663fe52b8861f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> WriteEventFd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a> *&#160;</td>
          <td class="paramname"><em>perThreadRecPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write to a thread's Event File Descriptor. This increments it by one.</p>
<p>This must be done exactly once for each Event Report pushed onto the thread's Event Queue. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="abde56bfeae36bd92d3cfdb4df30267d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structle__sls___list__t.html">le_sls_List_t</a> EventList = <a class="el" href="le__singly_linked_list_8h.html#a2e1013c24e2c826dbba37a761c5d9f44">LE_SLS_LIST_INIT</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Event List</p>
<p>This stores all the Event objects in the process. It is mainly here for diagnostics tools to use.</p>
<dl class="section warning"><dt>Warning</dt><dd>This can be accessed by multiple threads. Use the Mutex to protect it from races. </dd></dl>

</div>
</div>
<a class="anchor" id="a2811b51fca595f9625be30902820816c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a> EventPool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Event Pool</p>
<p>Pool from which Event objects are allocated.</p>
<dl class="section note"><dt>Note</dt><dd>Pools are thread safe. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dad78d8cec4a7bf55097f99f3bd5567"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__safe_ref_8h.html#aaf8fb3412fb840cb50366856affaf69b">le_ref_MapRef_t</a> EventRefMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Safe Reference Map to be used to create Safe References to use as Event IDs.</p>
<dl class="section warning"><dt>Warning</dt><dd>This can be accessed by multiple threads. Use the Mutex to protect it from races. </dd></dl>

</div>
</div>
<a class="anchor" id="a064d209e4eaa951f501a7ca768d37300"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a> HandlerPool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Handler Pool</p>
<p>This is the pool from which Handler objects are allocated. </p>

</div>
</div>
<a class="anchor" id="a9c4c388ffca0e59babf74ee12bd18f13"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__safe_ref_8h.html#aaf8fb3412fb840cb50366856affaf69b">le_ref_MapRef_t</a> HandlerRefMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The Safe Reference Map to be used to create Handler References.</p>
<dl class="section warning"><dt>Warning</dt><dd>This can be accessed by multiple threads. Use the Mutex to protect it from races. </dd></dl>

</div>
</div>
<a class="anchor" id="abc03085ccf7c38e092cdf06bf6b98ea6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t Mutex = PTHREAD_MUTEX_INITIALIZER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mutex is used to protect all data structures, other than the Init Handler List, from multithreaded race conditions. Threads wishing to access anything under the Event List or the Per-Thread Records must hold this lock while doing so. </p>

</div>
</div>
<a class="anchor" id="a04e7e634b1ab8f7cf1f52c70d45c5a2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a> QueuedFunctionPool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pool from which Queued Function Event Reports are allocated. </p>

</div>
</div>
<a class="anchor" id="a84d541f37420ace8bdf697deca689deb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__log_8h.html#a055e29785e8d1c5bf1b3a230df8d65b7">le_log_TraceRef_t</a> TraceRef</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trace reference used for controlling tracing in this module. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
