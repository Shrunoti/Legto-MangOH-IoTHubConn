<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: framework/liblegato/linux/cgroups.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('cgroups_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cgroups.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="cgroups_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad2eee571b4d42dc6b59514081d9de77c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a> { <a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77ca6cfa769c26998032f2a4329d89dcc969">CGRP_SUBSYS_CPU</a> = 0, 
<a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77cae31e665a64f789a3d7b2c095f295cabb">CGRP_SUBSYS_MEM</a>, 
<a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77ca0c790090ba7ac7ecd5ea550bc19ce292">CGRP_SUBSYS_FREEZE</a>, 
<a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77cad0de2d0cb1e87e79de36cbdbbc3503d3">CGRP_NUM_SUBSYSTEMS</a>
 }</td></tr>
<tr class="separator:ad2eee571b4d42dc6b59514081d9de77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4195cb6b70449bb93493a6226f97d7ce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#a4195cb6b70449bb93493a6226f97d7ce">cgrp_FreezeState_t</a> { <a class="el" href="cgroups_8h.html#a4195cb6b70449bb93493a6226f97d7cea94f91d6150c57f9640d21c3894296d37">CGRP_FROZEN</a> = 0, 
<a class="el" href="cgroups_8h.html#a4195cb6b70449bb93493a6226f97d7cea6f6c61acc46ef95eb9e378a6070693c8">CGRP_THAWED</a>
 }</td></tr>
<tr class="separator:a4195cb6b70449bb93493a6226f97d7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8735d2e07614a24397d740f30243bdff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#a8735d2e07614a24397d740f30243bdff">cgrp_Init</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a8735d2e07614a24397d740f30243bdff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160b66801eaad9d32c2e8ae11befc304"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#a160b66801eaad9d32c2e8ae11befc304">cgrp_Create</a> (<a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a> subsystem, const char *cgroupNamePtr)</td></tr>
<tr class="separator:a160b66801eaad9d32c2e8ae11befc304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16293818696bec9ee17c741e70153f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#ab16293818696bec9ee17c741e70153f0">cgrp_AddProc</a> (<a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a> subsystem, const char *cgroupNamePtr, pid_t pidToAdd)</td></tr>
<tr class="separator:ab16293818696bec9ee17c741e70153f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0c1fa94dbb1626bb47f85f822ef58d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#a1b0c1fa94dbb1626bb47f85f822ef58d">cgrp_GetThreadList</a> (<a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a> subsystem, const char *cgroupNamePtr, pid_t *tidListPtr, size_t maxTids)</td></tr>
<tr class="separator:a1b0c1fa94dbb1626bb47f85f822ef58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2eb43d67a99b474e4c6a484b444f81b"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#af2eb43d67a99b474e4c6a484b444f81b">cgrp_GetProcessesList</a> (<a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a> subsystem, const char *cgroupNamePtr, pid_t *idListPtr, size_t maxIds)</td></tr>
<tr class="separator:af2eb43d67a99b474e4c6a484b444f81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49aeee12bf5f7b8adeff02764103d9df"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#a49aeee12bf5f7b8adeff02764103d9df">cgrp_SendSig</a> (<a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a> subsystem, const char *cgroupNamePtr, int sig)</td></tr>
<tr class="separator:a49aeee12bf5f7b8adeff02764103d9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b46d738fa7ccc3b917b5b29368892d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#af5b46d738fa7ccc3b917b5b29368892d">cgrp_IsEmpty</a> (<a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a> subsystem, const char *cgroupNamePtr)</td></tr>
<tr class="separator:af5b46d738fa7ccc3b917b5b29368892d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af811323b51196a31f2417b54e02e79d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#af811323b51196a31f2417b54e02e79d3">cgrp_Delete</a> (<a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a> subsystem, const char *cgroupNamePtr)</td></tr>
<tr class="separator:af811323b51196a31f2417b54e02e79d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133106fb988771994e749b8d27bf7f12"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#a133106fb988771994e749b8d27bf7f12">cgrp_SubSysName</a> (<a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a> subsystem)</td></tr>
<tr class="separator:a133106fb988771994e749b8d27bf7f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83dc21bd1c3901bbce4315ab37ee7e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#ad83dc21bd1c3901bbce4315ab37ee7e6">cgrp_cpu_SetShare</a> (const char *cgroupNamePtr, size_t share)</td></tr>
<tr class="separator:ad83dc21bd1c3901bbce4315ab37ee7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c04562acf22ce2cdef0738b509c1dbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#a3c04562acf22ce2cdef0738b509c1dbd">cgrp_mem_SetLimit</a> (const char *cgroupNamePtr, size_t limit)</td></tr>
<tr class="separator:a3c04562acf22ce2cdef0738b509c1dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2607ffaf6eb2e2588d6b91d631c6f66d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#a2607ffaf6eb2e2588d6b91d631c6f66d">cgrp_frz_Freeze</a> (const char *cgroupNamePtr)</td></tr>
<tr class="separator:a2607ffaf6eb2e2588d6b91d631c6f66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c491bdd4e05c125397fe66b655eb12d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#a3c491bdd4e05c125397fe66b655eb12d">cgrp_frz_Thaw</a> (const char *cgroupNamePtr)</td></tr>
<tr class="separator:a3c491bdd4e05c125397fe66b655eb12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53ddc667632d27dc19d1efc0b617d03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cgroups_8h.html#a4195cb6b70449bb93493a6226f97d7ce">cgrp_FreezeState_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#ad53ddc667632d27dc19d1efc0b617d03">cgrp_frz_GetState</a> (const char *cgroupNamePtr)</td></tr>
<tr class="separator:ad53ddc667632d27dc19d1efc0b617d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183413112024ffa9813f1f87d268f6a4"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#a183413112024ffa9813f1f87d268f6a4">cgrp_GetMemUsed</a> (const char *cgroupNamePtr)</td></tr>
<tr class="separator:a183413112024ffa9813f1f87d268f6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dc8c45c6be255a140bb1f5838eccff"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cgroups_8h.html#ae9dc8c45c6be255a140bb1f5838eccff">cgrp_GetMaxMemUsed</a> (const char *cgroupNamePtr)</td></tr>
<tr class="separator:ae9dc8c45c6be255a140bb1f5838eccff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="cgroups_8h.html#c_cgrp_layout">Hierarchy Layout</a> <br />
 <a class="el" href="cgroups_8h.html#c_cgrp_init">Initialization</a> <br />
 <a class="el" href="cgroups_8h.html#c_cgrp_create">Creating cgroups</a> <br />
 <a class="el" href="cgroups_8h.html#c_cgrp_settingAttributes">Setting cgroup Attributes</a> <br />
 <a class="el" href="cgroups_8h.html#c_cgrp_addingProcesses">Adding Processes to a cgroup</a> <br />
 <a class="el" href="cgroups_8h.html#c_cgrp_delete">Deleting cgroups</a> <br />
 <a class="el" href="cgroups_8h.html#c_cgrp_threadSafety">Thread Safety</a> <br />
</p>
<p>Cgroups, short for control groups, is a Linux kernel feature that allows hierarchal groupings of processes. Each group can then be configured with specific attributes that apply to the entire group. Control groups should not be confused with process groups as this is a different concept.</p>
<p>A cgroup can contain other sub-groups and can be arranged in a tree structure similar to directories in a file system. However, unlike a file system cgroups can have multiple roots. These separate cgroup trees are called hierarchies. For example, a system's cgroups could be arranged in the following manner:</p>
<pre class="fragment">                   Hierarchy1                      Hierarchy2
                     /    \                          /     \
                group1    group2                 group1    group2
                /    \                                         \
          subgroup1  subgroup2                             subgroup1
</pre><p>Attributes that a cgroup can have are available through kernel sub-systems. For example, the memory sub-system can be used to set the memory limit for all processes in a cgroup. A hierarchy must have at least one sub-system attached to it and in general a sub-system can only be attached to a single hierarchy.</p>
<p>A process can only be a part of one cgroup in each hierarchy. Having separate hierarchies allows for more flexible control of cgroups.</p>
<p>In practice cgroups are used mainly for limiting system resources.</p>
<h1><a class="anchor" id="c_cgrp_layout"></a>
Hierarchy Layout</h1>
<p>In this implementation of cgroups each sub-system is attached to its own hierarchy. In other words there is a one-to-one mapping of hierarchy and sub-systems so the terms hierarchy and sub-system will be used interchangeably henceforth.</p>
<h1><a class="anchor" id="c_cgrp_init"></a>
Initialization</h1>
<p>On system start-up the <a class="el" href="cgroups_8h.html#a8735d2e07614a24397d740f30243bdff">cgrp_Init()</a> function must be called to setup the hierarchies. Cgroups are by default non-persistent so <a class="el" href="cgroups_8h.html#a8735d2e07614a24397d740f30243bdff">cgrp_Init()</a> must called every time the system starts.</p>
<h1><a class="anchor" id="c_cgrp_create"></a>
Creating cgroups</h1>
<p>To create a cgroup for a sub-system call <a class="el" href="cgroups_8h.html#a160b66801eaad9d32c2e8ae11befc304">cgrp_Create()</a>.</p>
<h1><a class="anchor" id="c_cgrp_settingAttributes"></a>
Setting cgroup Attributes</h1>
<p>Cgroups created for a specific sub-system can only set attributes specific to that sub-system. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// cgroup created for the cpu sub-system.</span></div><div class="line"><a class="code" href="cgroups_8c.html#a160b66801eaad9d32c2e8ae11befc304">cgrp_Create</a>(<a class="code" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77ca6cfa769c26998032f2a4329d89dcc969">CGRP_SUBSYS_CPU</a>, <span class="stringliteral">&quot;MyApp&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// cgroup created for the memory sub-system with the same name.  This is a separate cgroup</span></div><div class="line"><span class="comment">// but it can have the same name because it is in a different hierarchy.</span></div><div class="line"><a class="code" href="cgroups_8c.html#a160b66801eaad9d32c2e8ae11befc304">cgrp_Create</a>(<a class="code" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77cae31e665a64f789a3d7b2c095f295cabb">CGRP_SUBSYS_MEM</a>, <span class="stringliteral">&quot;MyApp&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Set the cpu share for the cgroup in the cpu sub-system to half of the default value.</span></div><div class="line"><a class="code" href="cgroups_8c.html#ad83dc21bd1c3901bbce4315ab37ee7e6">cgrp_cpu_SetShare</a>(<span class="stringliteral">&quot;MyApp&quot;</span>, 512);</div><div class="line"></div><div class="line"><span class="comment">// Set the memory limit for the cgroup in the memory sub-system.</span></div><div class="line"><a class="code" href="cgroups_8c.html#a3c04562acf22ce2cdef0738b509c1dbd">cgrp_mem_SetLimit</a>(<span class="stringliteral">&quot;MyApp&quot;</span>, 100);</div></div><!-- fragment --><h1><a class="anchor" id="c_cgrp_addingProcesses"></a>
Adding Processes to a cgroup</h1>
<p>Processes can be added to a cgroup, by PID, using <a class="el" href="cgroups_8h.html#ab16293818696bec9ee17c741e70153f0">cgrp_AddProc()</a>. If a process already belonging to a cgroup is added to another cgroup in the same hierarchy, the process is moved but not copied to the second cgroup, because processes can only be in one cgroup per hierarchy.</p>
<p>Processes that are forked by other processes always inherit the cgroup of their parent.</p>
<p>When a process dies it is automatically removed from all cgroups it belongs to.</p>
<h1><a class="anchor" id="c_cgrp_delete"></a>
Deleting cgroups</h1>
<p>To delete a cgroup call <a class="el" href="cgroups_8h.html#af811323b51196a31f2417b54e02e79d3">cgrp_Delete()</a>. Cgroups can only be deleted if they do not contain any processes.</p>
<h1><a class="anchor" id="c_cgrp_threadSafety"></a>
Thread Safety</h1>
<p>The functions in this API are not thread safe. Other synchronization methods must be used to control concurrent access to the cgroups.</p>
<p>Copyright (C) Sierra Wireless Inc. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a4195cb6b70449bb93493a6226f97d7ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cgroups_8h.html#a4195cb6b70449bb93493a6226f97d7ce">cgrp_FreezeState_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cgroup freeze state. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a4195cb6b70449bb93493a6226f97d7cea94f91d6150c57f9640d21c3894296d37"></a>CGRP_FROZEN&#160;</td><td class="fielddoc">
<p>All tasks in the cgroup are frozen. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a4195cb6b70449bb93493a6226f97d7cea6f6c61acc46ef95eb9e378a6070693c8"></a>CGRP_THAWED&#160;</td><td class="fielddoc">
<p>All tasks in the cgroup are not frozen. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ad2eee571b4d42dc6b59514081d9de77c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cgroup sub-systems. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ad2eee571b4d42dc6b59514081d9de77ca6cfa769c26998032f2a4329d89dcc969"></a>CGRP_SUBSYS_CPU&#160;</td><td class="fielddoc">
<p>CPU sub-system. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad2eee571b4d42dc6b59514081d9de77cae31e665a64f789a3d7b2c095f295cabb"></a>CGRP_SUBSYS_MEM&#160;</td><td class="fielddoc">
<p>Memory sub-system. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad2eee571b4d42dc6b59514081d9de77ca0c790090ba7ac7ecd5ea550bc19ce292"></a>CGRP_SUBSYS_FREEZE&#160;</td><td class="fielddoc">
<p>Freezer sub-system. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad2eee571b4d42dc6b59514081d9de77cad0de2d0cb1e87e79de36cbdbbc3503d3"></a>CGRP_NUM_SUBSYSTEMS&#160;</td><td class="fielddoc">
<p>Number of sub-systems. Must be the last item in this enum. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab16293818696bec9ee17c741e70153f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> cgrp_AddProc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a>&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t&#160;</td>
          <td class="paramname"><em>pidToAdd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a process to a cgroup.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_OUT_OF_RANGE if the process doesn't exist. LE_FAULT if there was some other error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Sub-system of the cgroup. </td></tr>
    <tr><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup to add the process to. </td></tr>
    <tr><td class="paramname">pidToAdd</td><td>PID of the process to add. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad83dc21bd1c3901bbce4315ab37ee7e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> cgrp_cpu_SetShare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>share</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the cpu share of a cgroup.</p>
<p>Cpu share is used to calculate the cpu percentage for a process relative to all other processes in the system. Newly created cgroups and processes not belonging to a cgroup are given a default value of 1024. The actual percentage of the cpu given to a process is calculated as:</p>
<p>(share value of process) / (sum of shares from all processes contending for the cpu)</p>
<p>All processes within a cgroup share the available cpu share for that cgroup.</p>
<p>For example:</p>
<p>cgroupA is configured with the default share value, 1024. cgroupB is configured with 512 as its share value. cgroupC is configured with 2048 as its share value.</p>
<p>cgroupA has one process running. cgroupB has two processes running. cgroupC has one process running.</p>
<p>Assuming that all processes in cgroupA, cgroupB and cgroupC are running and not blocked waiting for some I/O or timer event and that another system process is also running.</p>
<p>Sum of all shares (including the one system process) is 1024 + 512 + 2048 + 1024 = 4608</p>
<p>The process in cgroupA will get 1024/4608 = 22% of the cpu. The two processes in cgroupB will share 512/4608 = 11% of the cpu, each process getting 5.5%. The process in cgroupC will get 2048/4608 = 44% of the cpu. The system process will get 1024/4608 = 22% of the cpu.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup to set the share for. </td></tr>
    <tr><td class="paramname">share</td><td>Share value to set. See the function header for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a160b66801eaad9d32c2e8ae11befc304"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> cgrp_Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a>&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a cgroup with the specified name in the specified sub-system. If the cgroup already exists this function has no effect.</p>
<p>Sub-groups can be created by providing a path as the name. For example, cgrp_Create(CGRP_SUBSYS_CPU, "Students/Undergrads"); will create a cgroup called "Undergrads" that is a sub-group of "Students". Note that all parent groups must first exist before a sub-group can be created.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_DUPLICATE if the cgroup already exists. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Sub-system the cgroup belongs to. </td></tr>
    <tr><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup to create. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af811323b51196a31f2417b54e02e79d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> cgrp_Delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a>&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes a cgroup.</p>
<dl class="section note"><dt>Note</dt><dd>A cgroup can only be removed when there are no processes in the group. Ensure there are no processes in a cgroup (by killing the processes) before attempting to delete it.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the cgroup was successfully deleted. LE_BUSY if the cgroup could not be deleted because there are still processes in the cgroup. LE_FAULT if there was some other error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Sub-system of the cgroup. </td></tr>
    <tr><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2607ffaf6eb2e2588d6b91d631c6f66d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> cgrp_frz_Freeze </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Freezes all the tasks in a cgroup. This is an asynchronous function call that returns immediately at which point the freeze state of the cgroup may not be updated yet. Check the current state of the cgroup using <a class="el" href="cgroups_8h.html#ad53ddc667632d27dc19d1efc0b617d03">cgrp_frz_GetState()</a>. Once a cgroup is frozen all tasks in the cgroup are prevented from being scheduled by the kernel.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad53ddc667632d27dc19d1efc0b617d03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cgroups_8h.html#a4195cb6b70449bb93493a6226f97d7ce">cgrp_FreezeState_t</a> cgrp_frz_GetState </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the freeze state of the cgroup.</p>
<dl class="section return"><dt>Returns</dt><dd>Freeze state of the cgroup if successful. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c491bdd4e05c125397fe66b655eb12d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> cgrp_frz_Thaw </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thaws all the tasks in a cgroup. This is an asynchronous function call that returns immediately at which point the freeze state of the cgroup may not be updated yet. Check the current state of the cgroup using <a class="el" href="cgroups_8h.html#ad53ddc667632d27dc19d1efc0b617d03">cgrp_frz_GetState()</a>. Once a cgroup is thawed all tasks in the cgroup are permitted to be scheduled by the kernel.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae9dc8c45c6be255a140bb1f5838eccff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t cgrp_GetMaxMemUsed </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the imum amount of memory used in bytes by a cgroup. </p><dl class="section return"><dt>Returns</dt><dd>Maximum number of bytes used at any time up to now by this cgroup. LE_FAULT if there was an error.</dd></dl>
<p>Gets the maximum amount of memory used in bytes by a cgroup. </p><dl class="section return"><dt>Returns</dt><dd>Maximum number of bytes used at any time up to now by this cgroup. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a183413112024ffa9813f1f87d268f6a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t cgrp_GetMemUsed </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the amount of memory used in bytes by a cgroup</p>
<dl class="section return"><dt>Returns</dt><dd>Number of bytes in use by the cgroup. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2eb43d67a99b474e4c6a484b444f81b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t cgrp_GetProcessesList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a>&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t *&#160;</td>
          <td class="paramname"><em>pidListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxPids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a list of threads that are in a cgroup. The number of threads in the cgroup may be larger than maxTids, in which case tidListPtr will be filled with the first maxTids TIDs.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads that are in the cgroup if successful. LE_FAULT if there was some other error.</dd></dl>
<p>Gets a list of processes that are in a cgroup. The number of processes in the cgroup may be larger than maxPids, in which case pidListPtr will be filled with the first maxPids PIDs.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads that are in the cgroup if successful. LE_FAULT if there was some other error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subsystem</td><td>Sub-system of the cgroup. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pidListPtr</td><td>Buffer that will contain the list of PIDs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxPids</td><td>The maximum number of pids pidListPtr can hold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b0c1fa94dbb1626bb47f85f822ef58d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t cgrp_GetThreadList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a>&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pid_t *&#160;</td>
          <td class="paramname"><em>tidListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxTids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a list of threads that are in a cgroup. The number of threads in the cgroup may be larger than maxTids, in which case tidListPtr will be filled with the first maxTids TIDs.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads that are in the cgroup if successful. LE_FAULT if there was some other error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subsystem</td><td>Sub-system of the cgroup. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tidListPtr</td><td>Buffer that will contain the list of TIDs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxTids</td><td>The maximum number of tids tidListPtr can hold. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8735d2e07614a24397d740f30243bdff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> cgrp_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes cgroups for the system. Sets up a hierarchy for each supported subsystem.</p>
<dl class="section note"><dt>Note</dt><dd>Should be called once for the entire system, subsequent calls to this function will have no effect. Must be called before any of the other functions in this API is called.</dd>
<dd>
Failures will cause the calling process to exit. </dd></dl>

</div>
</div>
<a class="anchor" id="af5b46d738fa7ccc3b917b5b29368892d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cgrp_IsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a>&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the specified cgroup is empty of all processes.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the specified cgroup has no processes in it. false if there are processes in the specified cgroup. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subsystem</td><td>Sub-system of the cgroup. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c04562acf22ce2cdef0738b509c1dbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> cgrp_mem_SetLimit </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the memory limit for a cgroup.</p>
<dl class="section note"><dt>Note</dt><dd>All processes in a cgroup share the available memory for that cgroup.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup to set the limit for. </td></tr>
    <tr><td class="paramname">limit</td><td>Memory limit in kilobytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49aeee12bf5f7b8adeff02764103d9df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t cgrp_SendSig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a>&#160;</td>
          <td class="paramname"><em>subsystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cgroupNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends the specified signal to all the processes in the specified cgroup.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of PIDs that are in the cgroup. LE_FAULT if there an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subsystem</td><td>Sub-system of the cgroup. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cgroupNamePtr</td><td>Name of the cgroup. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sig</td><td>The signal to send. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a133106fb988771994e749b8d27bf7f12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cgrp_SubSysName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="cgroups_8h.html#ad2eee571b4d42dc6b59514081d9de77c">cgrp_SubSys_t</a>&#160;</td>
          <td class="paramname"><em>subsystem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the name of sub-system.</p>
<dl class="section note"><dt>Note</dt><dd>Do not attempt to modify the returned name in place. If you need to make modifications copy the name into your own buffer.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the sub-system. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">subsystem</td><td>Sub-system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
