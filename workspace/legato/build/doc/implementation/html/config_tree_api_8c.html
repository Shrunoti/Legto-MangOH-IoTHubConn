<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: framework/daemons/linux/configTree/configTreeApi.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('config_tree_api_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">configTreeApi.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="legato_8h_source.html">legato.h</a>&quot;</code><br />
<code>#include &quot;interfaces.h&quot;</code><br />
<code>#include &quot;<a class="el" href="dynamic_string_8h_source.html">dynamicString.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tree_db_8h_source.html">treeDb.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tree_user_8h_source.html">treeUser.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tree_path_8h_source.html">treePath.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="node_iterator_8h_source.html">nodeIterator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="request_queue_8h_source.html">requestQueue.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2677988a222cd10ef824c50c02a0bb41"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a2677988a222cd10ef824c50c02a0bb41">CreateTransaction</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="node_iterator_8h.html#aade2d335919a07a9cdb0a892d363528f">ni_IteratorType_t</a> request, const char *pathPtr)</td></tr>
<tr class="separator:a2677988a222cd10ef824c50c02a0bb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef3df2bce8276a11d5272d8552e453e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="node_iterator_8h.html#a4e97d8e792de584da776be7c732785ba">ni_IteratorRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#acef3df2bce8276a11d5272d8552e453e">GetIteratorFromRef</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef)</td></tr>
<tr class="separator:acef3df2bce8276a11d5272d8552e453e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5839ff6436fac299a3a48182cc0cb07"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="node_iterator_8h.html#a4e97d8e792de584da776be7c732785ba">ni_IteratorRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#ae5839ff6436fac299a3a48182cc0cb07">GetWriteIteratorFromRef</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef)</td></tr>
<tr class="separator:ae5839ff6436fac299a3a48182cc0cb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72fb1bb5922c1625fbf6da7942abc3a2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a72fb1bb5922c1625fbf6da7942abc3a2">CheckPathForSpecifier</a> (const char *pathPtr)</td></tr>
<tr class="separator:a72fb1bb5922c1625fbf6da7942abc3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fea1208abf6b0dbd9bbb4c79d3a636f"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a5fea1208abf6b0dbd9bbb4c79d3a636f">MaxStr</a> (size_t requestedMax)</td></tr>
<tr class="separator:a5fea1208abf6b0dbd9bbb4c79d3a636f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98bf411755bc1657058b1a13b1cc52cf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a98bf411755bc1657058b1a13b1cc52cf">QuickGetTree</a> (<a class="el" href="tree_user_8h.html#ae16174a0d43f8a46e47447be76fe951a">tu_UserRef_t</a> userRef, <a class="el" href="tree_user_8h.html#a2dff366cb61aff633d83fc1598574fb7">tu_TreePermission_t</a> permission, const char *pathPtr)</td></tr>
<tr class="separator:a98bf411755bc1657058b1a13b1cc52cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ccb248b6b2005ecfd79bb81ebc3819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#af5ccb248b6b2005ecfd79bb81ebc3819">le_cfg_CreateReadTxn</a> (le_cfg_ServerCmdRef_t commandRef, const char *basePathPtr)</td></tr>
<tr class="separator:af5ccb248b6b2005ecfd79bb81ebc3819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad75f5feeb10a1f36d901286723214cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#aad75f5feeb10a1f36d901286723214cc">le_cfg_CreateWriteTxn</a> (le_cfg_ServerCmdRef_t commandRef, const char *basePathPtr)</td></tr>
<tr class="separator:aad75f5feeb10a1f36d901286723214cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c19ebf394a826fcb5ee269c33cfbc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a08c19ebf394a826fcb5ee269c33cfbc6">le_cfg_CommitTxn</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef)</td></tr>
<tr class="separator:a08c19ebf394a826fcb5ee269c33cfbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab235edfc27a4995b087dcbf2aff411d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#ab235edfc27a4995b087dcbf2aff411d9">le_cfg_CancelTxn</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef)</td></tr>
<tr class="separator:ab235edfc27a4995b087dcbf2aff411d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dff208e030a6a772a77b225d9e9aec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a99dff208e030a6a772a77b225d9e9aec">le_cfg_GoToNode</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *newPathPtr)</td></tr>
<tr class="separator:a99dff208e030a6a772a77b225d9e9aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e09d8e564668cec507a108c4c204cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a81e09d8e564668cec507a108c4c204cf">le_cfg_GoToParent</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef)</td></tr>
<tr class="separator:a81e09d8e564668cec507a108c4c204cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0c674f90b19e5e0c44440ac74fc0ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a7a0c674f90b19e5e0c44440ac74fc0ad">le_cfg_GoToFirstChild</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef)</td></tr>
<tr class="separator:a7a0c674f90b19e5e0c44440ac74fc0ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d290b60859b66f394765bfed7da7357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a6d290b60859b66f394765bfed7da7357">le_cfg_GoToNextSibling</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef)</td></tr>
<tr class="separator:a6d290b60859b66f394765bfed7da7357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f233cd019914b6aabd9bf8a48d58f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a47f233cd019914b6aabd9bf8a48d58f2">le_cfg_GetPath</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr, size_t maxNewPath)</td></tr>
<tr class="separator:a47f233cd019914b6aabd9bf8a48d58f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4986a173684f784cba7b3eaa028660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#aca4986a173684f784cba7b3eaa028660">le_cfg_GetNodeType</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr)</td></tr>
<tr class="separator:aca4986a173684f784cba7b3eaa028660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eec370dab5539752909f9e896c0df8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a8eec370dab5539752909f9e896c0df8d">le_cfg_GetNodeName</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr, size_t maxName)</td></tr>
<tr class="separator:a8eec370dab5539752909f9e896c0df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace7ae62a7b400d3ddae0f82f6ba1c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#aace7ae62a7b400d3ddae0f82f6ba1c3d">le_cfg_AddChangeHandler</a> (const char *newPathPtr, <a class="el" href="le__cfg__interface_8h.html#ac9b4508a0faa6a5d91a4bace0b8976c0">le_cfg_ChangeHandlerFunc_t</a> handlerPtr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *contextPtr)</td></tr>
<tr class="separator:aace7ae62a7b400d3ddae0f82f6ba1c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae839eaf925f0498c728ab44f1bdcec66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#ae839eaf925f0498c728ab44f1bdcec66">le_cfg_RemoveChangeHandler</a> (<a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a> handlerRef)</td></tr>
<tr class="separator:ae839eaf925f0498c728ab44f1bdcec66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984aa5f0d14a8baecb8faa7bc7f039f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a984aa5f0d14a8baecb8faa7bc7f039f3">le_cfg_DeleteNode</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr)</td></tr>
<tr class="separator:a984aa5f0d14a8baecb8faa7bc7f039f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731938907725ce30676c7a131de40d4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a731938907725ce30676c7a131de40d4c">le_cfg_IsEmpty</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr)</td></tr>
<tr class="separator:a731938907725ce30676c7a131de40d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01d1ca98f1885aec8b187e66ddb1ca9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#ab01d1ca98f1885aec8b187e66ddb1ca9">le_cfg_SetEmpty</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr)</td></tr>
<tr class="separator:ab01d1ca98f1885aec8b187e66ddb1ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b17ccbe1fa610f4a228aeb17e9a2ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#aa9b17ccbe1fa610f4a228aeb17e9a2ce">le_cfg_NodeExists</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr)</td></tr>
<tr class="separator:aa9b17ccbe1fa610f4a228aeb17e9a2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed6dd21f2926fea9da28011e5d465bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a5ed6dd21f2926fea9da28011e5d465bd">le_cfg_GetString</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr, size_t maxString, const char *defaultValue)</td></tr>
<tr class="separator:a5ed6dd21f2926fea9da28011e5d465bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1b2d9844300a55e907f8d1dff47a41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a2c1b2d9844300a55e907f8d1dff47a41">le_cfg_SetString</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr, const char *value)</td></tr>
<tr class="separator:a2c1b2d9844300a55e907f8d1dff47a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93b8b498d6b706c548726b88a0c3a10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#ad93b8b498d6b706c548726b88a0c3a10">le_cfg_GetInt</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr, int32_t defaultValue)</td></tr>
<tr class="separator:ad93b8b498d6b706c548726b88a0c3a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b84aa182f6979103585768d2a4115f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a78b84aa182f6979103585768d2a4115f">le_cfg_SetInt</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr, int32_t value)</td></tr>
<tr class="separator:a78b84aa182f6979103585768d2a4115f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c74a1af7f717bc578e568215d058ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a02c74a1af7f717bc578e568215d058ed">le_cfg_GetFloat</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr, double defaultValue)</td></tr>
<tr class="separator:a02c74a1af7f717bc578e568215d058ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787baae44676fff89296cf3076823475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a787baae44676fff89296cf3076823475">le_cfg_SetFloat</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr, double value)</td></tr>
<tr class="separator:a787baae44676fff89296cf3076823475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1651a36509deec329d150ebf446ecfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#ab1651a36509deec329d150ebf446ecfa">le_cfg_GetBool</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr, bool defaultValue)</td></tr>
<tr class="separator:ab1651a36509deec329d150ebf446ecfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace5ea5ea1981d09fa26e326bc120fc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#aace5ea5ea1981d09fa26e326bc120fc5">le_cfg_SetBool</a> (le_cfg_ServerCmdRef_t commandRef, <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> externalRef, const char *pathPtr, bool value)</td></tr>
<tr class="separator:aace5ea5ea1981d09fa26e326bc120fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c47fb17ee1dd53f0f7224d904af448"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a75c47fb17ee1dd53f0f7224d904af448">le_cfg_QuickDeleteNode</a> (le_cfg_ServerCmdRef_t commandRef, const char *pathPtr)</td></tr>
<tr class="separator:a75c47fb17ee1dd53f0f7224d904af448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7219b1aec2afc42bd996c3d66920b52d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a7219b1aec2afc42bd996c3d66920b52d">le_cfg_QuickSetEmpty</a> (le_cfg_ServerCmdRef_t commandRef, const char *pathPtr)</td></tr>
<tr class="separator:a7219b1aec2afc42bd996c3d66920b52d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f1c244ce988aa9dea787da335e2f4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#ac9f1c244ce988aa9dea787da335e2f4f">le_cfg_QuickGetString</a> (le_cfg_ServerCmdRef_t commandRef, const char *pathPtr, size_t maxString, const char *defaultValuePtr)</td></tr>
<tr class="separator:ac9f1c244ce988aa9dea787da335e2f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b0c47f59897c86353e1412c4b6a5234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a5b0c47f59897c86353e1412c4b6a5234">le_cfg_QuickSetString</a> (le_cfg_ServerCmdRef_t commandRef, const char *pathPtr, const char *valuePtr)</td></tr>
<tr class="separator:a5b0c47f59897c86353e1412c4b6a5234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583a356502173847097b27e081986054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a583a356502173847097b27e081986054">le_cfg_QuickGetInt</a> (le_cfg_ServerCmdRef_t commandRef, const char *pathPtr, int32_t defaultValue)</td></tr>
<tr class="separator:a583a356502173847097b27e081986054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac899032e8c36191f3685d296418c7475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#ac899032e8c36191f3685d296418c7475">le_cfg_QuickSetInt</a> (le_cfg_ServerCmdRef_t commandRef, const char *pathPtr, int32_t value)</td></tr>
<tr class="separator:ac899032e8c36191f3685d296418c7475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9069608146a0a32b5194881ce94c2b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a9069608146a0a32b5194881ce94c2b42">le_cfg_QuickGetFloat</a> (le_cfg_ServerCmdRef_t commandRef, const char *pathPtr, double defaultValue)</td></tr>
<tr class="separator:a9069608146a0a32b5194881ce94c2b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118036880f99cbfadc0ea3145a1fd35a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a118036880f99cbfadc0ea3145a1fd35a">le_cfg_QuickSetFloat</a> (le_cfg_ServerCmdRef_t commandRef, const char *pathPtr, double value)</td></tr>
<tr class="separator:a118036880f99cbfadc0ea3145a1fd35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5079f87c35a7e0967d687b78bfdfc5a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a5079f87c35a7e0967d687b78bfdfc5a0">le_cfg_QuickGetBool</a> (le_cfg_ServerCmdRef_t commandRef, const char *pathPtr, bool defaultValue)</td></tr>
<tr class="separator:a5079f87c35a7e0967d687b78bfdfc5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5227d083499272dac8f13051e76a8f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="config_tree_api_8c.html#a5227d083499272dac8f13051e76a8f5e">le_cfg_QuickSetBool</a> (le_cfg_ServerCmdRef_t commandRef, const char *pathPtr, bool value)</td></tr>
<tr class="separator:a5227d083499272dac8f13051e76a8f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Highlevel impoementation of the configuration Tree API.</p>
<p>Copyright (C) Sierra Wireless Inc. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a72fb1bb5922c1625fbf6da7942abc3a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool CheckPathForSpecifier </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the given path and make sure that it doesn't try to change trees. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Path string to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2677988a222cd10ef824c50c02a0bb41"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> CreateTransaction </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_iterator_8h.html#aade2d335919a07a9cdb0a892d363528f">ni_IteratorType_t</a>&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Handle both the create read and write transacion requests. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Message context for the request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">request</td><td>The requested iterator type to create. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Initial path for the transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acef3df2bce8276a11d5272d8552e453e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="node_iterator_8h.html#a4e97d8e792de584da776be7c732785ba">ni_IteratorRef_t</a> GetIteratorFromRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an iterator pointer from an iterator reference.</p>
<dl class="section return"><dt>Returns</dt><dd>An internal reference to the iterator. Or NULL the safe reference could not be resolved. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>The iterator reference to extract a pointer from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5839ff6436fac299a3a48182cc0cb07"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="node_iterator_8h.html#a4e97d8e792de584da776be7c732785ba">ni_IteratorRef_t</a> GetWriteIteratorFromRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get an iterator pointer from an iterator reference.</p>
<dl class="section return"><dt>Returns</dt><dd>An internal reference to the iterator. Or NULL the safe reference could not be resolved. NULL is also returned if the iterator in question is not writeable. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator reference to extract a pointer from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aace7ae62a7b400d3ddae0f82f6ba1c3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a> le_cfg_AddChangeHandler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newPathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#ac9b4508a0faa6a5d91a4bace0b8976c0">le_cfg_ChangeHandlerFunc_t</a>&#160;</td>
          <td class="paramname"><em>handlerPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>contextPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a call back on a given node object. Once registered, this function is called if the node or if any of it's children are read from, written to, created or deleted.</p>
<dl class="section return"><dt>Returns</dt><dd>A handle to the event registration. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newPathPtr</td><td>Path to the object to watch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerPtr</td><td>Function to call back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td>Context to give the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab235edfc27a4995b087dcbf2aff411d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_CancelTxn </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close and free the given iterator object. If the iterator is a write iterator, the transaction will be canceled. If the iterator is a read iterator, the transaction will be closed.</p>
<dl class="section note"><dt>Note</dt><dd>: This operation will also delete the iterator object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator object to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a08c19ebf394a826fcb5ee269c33cfbc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_CommitTxn </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the write iterator and commit the write transaction. This updates the config tree with all of the writes that occured using the iterator.</p>
<dl class="section note"><dt>Note</dt><dd>: This operation will also delete the iterator object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator object to commit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5ccb248b6b2005ecfd79bb81ebc3819"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_CreateReadTxn </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>basePathPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a read transaction and open a new iterator for traversing the configuration tree.</p>
<dl class="section note"><dt>Note</dt><dd>: This action creates a read lock on the given tree. Which will start a read-timeout. Once the read timeout expires, then all active read iterators on that tree will be expired and the clients killed.</dd>
<dd>
: A tree transaction is global to that tree; a long held read transaction will block other users write transactions from being comitted.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This will return a newly created iterator reference. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basePathPtr</td><td>Path to the location to create the new iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad75f5feeb10a1f36d901286723214cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_CreateWriteTxn </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>basePathPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a write transaction and open a new iterator for both reading and writing.</p>
<dl class="section note"><dt>Note</dt><dd>: This action creates a write transaction. If the application holds the iterator for longer than the configured write transaction timeout, the iterator will cancel the transaction. All further reads will fail to return data and all writes will be thrown away.</dd>
<dd>
A tree transaction is global to that tree, so a long held write transaction will block other user's write transactions from being started. However other trees in the system will be unaffected.</dd></dl>
<p><b>Responds</b> <b>With:</b> </p>
<p>This will respond with a newly created iterator reference. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">basePathPtr</td><td>Path to the location to create the new iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a984aa5f0d14a8baecb8faa7bc7f039f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_DeleteNode </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete the node specified by the path. If the node doesn't exist, nothing happens. All child nodes are also deleted.</p>
<p>If the path is empty, the iterator's current node is deleted.</p>
<p>Only valid during a write transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Absolute or relative path to the node to delete. If absolute path is given, it's rooted off of the user's root node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1651a36509deec329d150ebf446ecfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_GetBool </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a value from the tree as a boolean. If the node is empty or doesn't exist, the default value is returned. The default value is also returned if the node is of a different type than expected.</p>
<p>Valid for both read and write transactions.</p>
<p>If the path is empty, the iterator's current node will be read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Full or relative path to the value to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02c74a1af7f717bc578e568215d058ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_GetFloat </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a 64-bit floating point value from the configuration tree.</p>
<p>If the value is an integer, the value will be promoted to a float. Otherwise, if the underlying value is not a float or integer, the default value will be returned.</p>
<p>If the path is empty, the iterator's current node will be read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Full or relative path to the value to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad93b8b498d6b706c548726b88a0c3a10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_GetInt </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a signed integer value from the configuration tree.</p>
<p>If the underlying value is not an integer, the default value will be returned instead. The default value is also returned if the node does not exist or if it's empty.</p>
<p>If the value is a floating point value, it will be rounded and returned as an integer.</p>
<p>Valid for both read and write transactions.</p>
<p>If the path is empty, the iterator's current node will be read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Full or relative path to the value to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8eec370dab5539752909f9e896c0df8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_GetNodeName </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of the node that the iterator is currently pointing at.</p>
<p><b>Responds</b> <b>With:</b> </p>
<p>This function will respond with one of the following values: </p><pre class="fragment">    - LE_OK       Write was completed successfuly.
    - LE_OVERFLOW Supplied string buffer was not large enough to hold the value.</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator object to use to read from the tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Absolute or relative path to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxName</td><td>Maximum size of the result string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aca4986a173684f784cba7b3eaa028660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_GetNodeType </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the type of node that the iterator is currently pointing at.</p>
<p><b>Responds</b> <b>With:</b> </p>
<p>le_cfg_nodeType_t value indicating the stored value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator object to use to read from the tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Absolute or relative path to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a47f233cd019914b6aabd9bf8a48d58f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_GetPath </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxNewPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get path to the node that the iterator is currently pointed.</p>
<p>Assuming the following tree:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;baseNode/</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  childA/</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    valueA</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    valueB</div></div><!-- fragment --><p>If the iterator was currently pointing at valueA, then GetPath would return the following path:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/baseNode/childA/valueA</div></div><!-- fragment --><p>Optionally, a path to another node can be supplied to this function. If the iterator is again on valueA and the relative path "..." is supplied, this function will return the following path:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/baseNode/childA/</div></div><!-- fragment --><p><b>Responds</b> <b>With:</b> </p>
<p>This function will respond with one of the following values: </p><pre class="fragment">    - LE_OK            - The write was completed successfuly.
    - LE_OVERFLOW      - The supplied string buffer was not large enough to hold the value.</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to move. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Absolute or relative path to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxNewPath</td><td>Maximum size of the result string. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ed6dd21f2926fea9da28011e5d465bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_GetString </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a string value from the configuration tree. If the value isn't a string, or if the node is empty or doesn't exist, the default value will be returned.</p>
<p>Valid for both read and write transactions.</p>
<p>If the path is empty, the iterator's current node will be read.</p>
<p><b>Responds</b> <b>With:</b> </p>
<p>This function will respond with one of the following values: </p><pre class="fragment">    - LE_OK       - Read was completed successfully.
    - LE_OVERFLOW - Supplied string buffer was not large enough to hold the value.</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Absolute or relative path to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxString</td><td>Maximum size of the result string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a0c674f90b19e5e0c44440ac74fc0ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_GoToFirstChild </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move the iterator to the the first child of the node that the iterator is currently pointed.</p>
<p>For read iterators without children, this function will fail. If the iterator is a write iterator, then a new node is automatically created. If this node or an newly created children of this node are not written to, then this node will not persist even if the iterator is comitted.</p>
<p><b>Responds</b> <b>With:</b> </p>
<p>This function will respond with one of the following values: </p><pre class="fragment">    - LE_OK        - Move was completed successfuly.
    - LE_NOT_FOUND - The given node has no children.</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator object to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6d290b60859b66f394765bfed7da7357"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_GoToNextSibling </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Jump the iterator to the next child node of the current node. Assuming the following tree:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;baseNode/</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;  childA/</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    valueA</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    valueB</div></div><!-- fragment --><p>If the iterator is moved to the path, "/baseNode/childA/valueA". After the first GoToNextSibling the iterator will be pointing at valueB. A second call to GoToNextSibling will cause the function to return LE_NOT_FOUND.</p>
<p><b>Responds</b> <b>With:</b> </p>
<p>This function will respond with one of the following values: </p><pre class="fragment">    - LE_OK            - Commit was completed successfuly.
    - LE_NOT_FOUND     - Iterator has reached the end of the current list of siblings.
                         Also returned if the the current node has no siblings.</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to iterate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99dff208e030a6a772a77b225d9e9aec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_GoToNode </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newPathPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the node that the iterator is pointing to. The path passed can be an absolute or a relative path from the iterators current location.</p>
<p>The target node does not need to exist. When a write iterator is used to go to a non-existant node, the node is automaticly created when a value is written to it or any of it's children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to move. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPathPtr</td><td>Absolute or relative path from the current location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81e09d8e564668cec507a108c4c204cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_GoToParent </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move the iterator to the parent of the node for the iterator.</p>
<p><b>Responds</b> <b>With:</b> </p>
<p>This function will respond with one of the following values: </p><pre class="fragment">    - LE_OK        - Commit was completed successfuly.
    - LE_NOT_FOUND - Current node is the root node: has no parent.</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a731938907725ce30676c7a131de40d4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_IsEmpty </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the given node is empty. A node is considered empty if it has no value. A node is also considered empty if it doesn't yet exist.</p>
<p>If the path is empty, the iterator's current node is queried for emptiness.</p>
<p>Valid for both read and write transactions.</p>
<p><b>Responds</b> <b>With:</b> </p>
<p>A true if the node is considered empty, false if not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Absolute or relative path to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9b17ccbe1fa610f4a228aeb17e9a2ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_NodeExists </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to see if a given node in the configuration tree exists.</p>
<p><b>Responds</b> <b>With:</b> </p>
<p>True if the specified node exists in the tree. False if not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Absolute or relative path to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a75c47fb17ee1dd53f0f7224d904af448"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickDeleteNode </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete the node specified by the path. If the node doesn't exist, nothing happens. All child nodes are also deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Path to the node to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5079f87c35a7e0967d687b78bfdfc5a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickGetBool </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a value from the tree as a boolean. If the node is empty or doesn't exist, the default value is returned. This is also true if the node is of a different type than expected.</p>
<p>If the value is empty or the node doesn't exist, the default value is returned instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9069608146a0a32b5194881ce94c2b42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickGetFloat </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a 64-bit floating point value from the configuration tree. If the value is an integer, it's promoted to a float. Otherwise, if the underlying value is not a float, or an integer the default value will be returned.</p>
<p>If the value is empty or the node doesn't exist, the default value is returned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a583a356502173847097b27e081986054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickGetInt </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a signed integer value from the configuration tree. If the value is a float, it's truncated. Otherwise If the underlying value is not an integer or a float, the default value will be returned instead.</p>
<p>If the value is empty or the node doesn't exist, the default value is returned instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9f1c244ce988aa9dea787da335e2f4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickGetString </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultValuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a string value from the configuration tree. If the value isn't a string, or if the node is empty or doesn't exist, the default value will be returned.</p>
<p><b>Responds</b> <b>With:</b> </p>
<p>This function will respond with one of the following values: </p><pre class="fragment">    - LE_OK            - Commit was completed successfully.
    - LE_OVERFLOW      - Supplied string buffer was not large enough to hold the value.</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Path to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxString</td><td>Maximum string to return. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValuePtr</td><td>Default value to use if the original can't be. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5227d083499272dac8f13051e76a8f5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickSetBool </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a boolean value to the configuration tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7219b1aec2afc42bd996c3d66920b52d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickSetEmpty </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a given node empty. If the node doesn't currently exist, it's created as a new empty node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Absolute or relative path to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a118036880f99cbfadc0ea3145a1fd35a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickSetFloat </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a 64-bit floating point value to the configuration tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac899032e8c36191f3685d296418c7475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickSetInt </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a signed integer value to the configuration tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b0c47f59897c86353e1412c4b6a5234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickSetString </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>valuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a string value to the configuration tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valuePtr</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae839eaf925f0498c728ab44f1bdcec66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_RemoveChangeHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a>&#160;</td>
          <td class="paramname"><em>handlerRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function removes a handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerRef</td><td>Previously registered handler to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aace5ea5ea1981d09fa26e326bc120fc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_SetBool </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a boolean value to the configuration tree. Only valid during a write transaction.</p>
<p>If the path is empty, the iterator's current node will be set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Full or relative path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab01d1ca98f1885aec8b187e66ddb1ca9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_SetEmpty </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear out the nodes's value. If it doesn't exist it will be created, but have no value.</p>
<p>If the path is empty, the iterator's current node will be cleared. If the node is a stem, all children will be removed from the tree.</p>
<p>Only valid during a write transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Absolute or relative path to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a787baae44676fff89296cf3076823475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_SetFloat </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a 64-bit floating point value to the configuration tree. Only valid during a write transaction.</p>
<p>If the path is empty, the iterator's current node will be set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Full or relative path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78b84aa182f6979103585768d2a4115f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_SetInt </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a signed integer value to the configuration tree. Only valid during a write transaction.</p>
<p>If the path is empty, the iterator's current node will be set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Full or relative path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c1b2d9844300a55e907f8d1dff47a41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_SetString </td>
          <td>(</td>
          <td class="paramtype">le_cfg_ServerCmdRef_t&#160;</td>
          <td class="paramname"><em>commandRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>externalRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a string value to the configuration tree. Only valid during a write transaction.</p>
<p>If the path is empty, the iterator's current node will be set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">commandRef</td><td>Reference used to generate a reply for this request. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">externalRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Full or relative path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fea1208abf6b0dbd9bbb4c79d3a636f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t MaxStr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>requestedMax</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the size of a requested string buffer. If it's larger than what we can handle internally, truncate it to what we can handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">requestedMax</td><td>Requested maximum string size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98bf411755bc1657058b1a13b1cc52cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> QuickGetTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_user_8h.html#ae16174a0d43f8a46e47447be76fe951a">tu_UserRef_t</a>&#160;</td>
          <td class="paramname"><em>userRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tree_user_8h.html#a2dff366cb61aff633d83fc1598574fb7">tu_TreePermission_t</a>&#160;</td>
          <td class="paramname"><em>permission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by the "Quick" functions to get a reference to the tree the user wants. If the tree retreival fails for any reason, (as in, permission error,) terminate the client.</p>
<dl class="section note"><dt>Note</dt><dd>If the permission check fails, then terminate client will be called.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the requested tree. Otherwise, NULL, if permission check fails. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">userRef</td><td>Get a tree for this user. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permission</td><td>Try to get a tree with this permission. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Path to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
