<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: framework/liblegato/linux/unixSocket.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('unix_socket_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">unixSocket.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="legato_8h_source.html">legato.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="unix_socket_8h_source.html">unixSocket.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="file_descriptor_8h_source.html">fileDescriptor.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1c84dc80e36a5a9feca77d09bcec9b8f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unix_socket_8c.html#a1c84dc80e36a5a9feca77d09bcec9b8f">CMSG_BUFF_SIZE</a>&#160;&#160;&#160;(CMSG_SPACE(sizeof(int)) + CMSG_SPACE(sizeof(struct ucred)))</td></tr>
<tr class="separator:a1c84dc80e36a5a9feca77d09bcec9b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a803ddd194b6cf7cb48af5e346a944c0e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unix_socket_8c.html#a803ddd194b6cf7cb48af5e346a944c0e">ExtractFileDescriptor</a> (struct cmsghdr *cmsgHeaderPtr)</td></tr>
<tr class="separator:a803ddd194b6cf7cb48af5e346a944c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a219c28161a045277fd3309595eb4d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unix_socket_8c.html#a83a219c28161a045277fd3309595eb4d">ExtractAncillaryData</a> (struct msghdr *msgHeaderPtr, int *fdPtr, struct ucred *credPtr)</td></tr>
<tr class="separator:a83a219c28161a045277fd3309595eb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9716076a305c1e918584568da28907"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unix_socket_8c.html#a1a9716076a305c1e918584568da28907">unixSocket_CreateSeqPacketNamed</a> (const char *pathStr)</td></tr>
<tr class="separator:a1a9716076a305c1e918584568da28907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4b00a74449a57fdfa4fd1a642fb37a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unix_socket_8c.html#abb4b00a74449a57fdfa4fd1a642fb37a">unixSocket_CreateSeqPacketUnnamed</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:abb4b00a74449a57fdfa4fd1a642fb37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb8d8b2e6802827529abf2ad90f6ff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unix_socket_8c.html#a9eb8d8b2e6802827529abf2ad90f6ff6">unixSocket_CreateSeqPacketPair</a> (int *socketFd1Ptr, int *socketFd2Ptr)</td></tr>
<tr class="separator:a9eb8d8b2e6802827529abf2ad90f6ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30486f2e4f0a4dbcaf3f27d1ac6ce73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unix_socket_8c.html#af30486f2e4f0a4dbcaf3f27d1ac6ce73">unixSocket_Connect</a> (int <a class="el" href="app_stop_client_8c.html#a44f21d5190b5a6df8089f54799628d7e">fd</a>, const char *pathStr)</td></tr>
<tr class="separator:af30486f2e4f0a4dbcaf3f27d1ac6ce73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81ee1e16e1ee2edbb8610fbb4e34ebe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unix_socket_8c.html#af81ee1e16e1ee2edbb8610fbb4e34ebe">unixSocket_SendMsg</a> (int localSocketFd, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *dataPtr, size_t dataSize, int fdToSend, bool sendCredentials)</td></tr>
<tr class="separator:af81ee1e16e1ee2edbb8610fbb4e34ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3f6de930eaff61cb764a39d42c4e22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unix_socket_8c.html#a4b3f6de930eaff61cb764a39d42c4e22">unixSocket_SendDataMsg</a> (int localSocketFd, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *dataPtr, size_t dataSize)</td></tr>
<tr class="separator:a4b3f6de930eaff61cb764a39d42c4e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64d779b38aa59e2a433a38f613fe191"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unix_socket_8c.html#ab64d779b38aa59e2a433a38f613fe191">unixSocket_ReceiveMsg</a> (int localSocketFd, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *dataBuffPtr, size_t *dataSizePtr, int *fdPtr, struct ucred *credPtr)</td></tr>
<tr class="separator:ab64d779b38aa59e2a433a38f613fe191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed8bcf2438f3c7db8b02e3b6596a4a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unix_socket_8c.html#a4ed8bcf2438f3c7db8b02e3b6596a4a2">unixSocket_ReceiveDataMsg</a> (int localSocketFd, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *dataBuffPtr, size_t *dataSizePtr)</td></tr>
<tr class="separator:a4ed8bcf2438f3c7db8b02e3b6596a4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e10b2c3bea86bd658798bc947621c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unix_socket_8c.html#a68e10b2c3bea86bd658798bc947621c8">unixSocket_GetErrorState</a> (int localSocketFd)</td></tr>
<tr class="separator:a68e10b2c3bea86bd658798bc947621c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Legato <a class="el" href="c_unixSockets.html">Unix Domain Sockets API</a> implementation file.</p>
<p>Copyright (C) Sierra Wireless Inc. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a1c84dc80e36a5a9feca77d09bcec9b8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CMSG_BUFF_SIZE&#160;&#160;&#160;(CMSG_SPACE(sizeof(int)) + CMSG_SPACE(sizeof(struct ucred)))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of the ancillary (control) message buffer needed to send or receive one file descriptor and one set of process credentials through a Unix domain socket. </p><dl class="section note"><dt>Note</dt><dd>We use CMSG_SPACE to ensure this is big enough to hold the cmsghdr structures. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a83a219c28161a045277fd3309595eb4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> ExtractAncillaryData </td>
          <td>(</td>
          <td class="paramtype">struct msghdr *&#160;</td>
          <td class="paramname"><em>msgHeaderPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>fdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ucred *&#160;</td>
          <td class="paramname"><em>credPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract ancillary data from a received message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msgHeaderPtr</td><td>Pointer to the struct msghdr that was filled in by a call to recvmsg(). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fdPtr</td><td>Pointer to where the received file descriptor will be put. (-1 will be stored here if no fd was received.) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">credPtr</td><td>Pointer to where received credentials will be stored. (NOTE: PID is set to zero if no credentials received.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a803ddd194b6cf7cb48af5e346a944c0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ExtractFileDescriptor </td>
          <td>(</td>
          <td class="paramtype">struct cmsghdr *&#160;</td>
          <td class="paramname"><em>cmsgHeaderPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract a file descriptor from an SCM_RIGHTS ancillary data message.</p>
<dl class="section return"><dt>Returns</dt><dd>The file descriptor. </dd></dl>

</div>
</div>
<a class="anchor" id="af30486f2e4f0a4dbcaf3f27d1ac6ce73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> unixSocket_Connect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect a local socket to another named socket.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if successful.</li>
<li>LE_WOULD_BLOCK if socket is non-blocking and could not be immediately connected.</li>
<li>LE_NOT_FOUND if the path provided does not refer to a listening socket.</li>
<li>LE_NOT_PERMITTED if the calling process does not have permission to connect to that socket.</li>
<li>LE_FAULT if failed for some other reason (check your logs).</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>In non-blocking mode, if LE_WOULD_BLOCK is returned, monitor the socket fd for writeability, and when it becomes writeable, call <a class="el" href="unix_socket_8c.html#a68e10b2c3bea86bd658798bc947621c8">unixSocket_GetErrorState()</a> to find out if the connection succeeded or failed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>Local socket file descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathStr</td><td>File system path of the named socket to connect to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a9716076a305c1e918584568da28907"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unixSocket_CreateSeqPacketNamed </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathStr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a named sequenced-packet Unix domain socket. This binds the socket to a file system path. A "socket" type pseudo file will appear at that location in the file system.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The file descriptor (a number &gt; 0) of the socket, if successful.</li>
<li>LE_NOT_PERMITTED if the calling process does not have permission to create a socket at that location in the file system.</li>
<li>LE_DUPLICATE if something already exists at that location in the file system.</li>
<li>LE_FAULT if failed for some other reason (check your logs). </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathStr</td><td>File system path to bind to the socket. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9eb8d8b2e6802827529abf2ad90f6ff6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> unixSocket_CreateSeqPacketPair </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>socketFd1Ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>socketFd2Ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a pair of unnamed Unix domain sequenced-packet sockets that are connected to each other.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if successful.</li>
<li>LE_NOT_PERMITTED if the calling process does not have permission to create a pair of sockets. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">socketFd1Ptr</td><td>Ptr to where the fd for one of the sockets will be stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">socketFd2Ptr</td><td>Ptr to where the other socket's fd will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb4b00a74449a57fdfa4fd1a642fb37a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unixSocket_CreateSeqPacketUnnamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an unnamed sequenced-packet Unix domain socket.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>The file descriptor (a number &gt; 0) of the socket, if successful.</li>
<li>LE_NOT_PERMITTED if the calling process does not have permission to create the socket.</li>
<li>LE_FAULT if failed for some other reason (check your logs). </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="a68e10b2c3bea86bd658798bc947621c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int unixSocket_GetErrorState </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localSocketFd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fetches the socket error state code (SO_ERROR).</p>
<dl class="section return"><dt>Returns</dt><dd>The SO_ERROR value, or EBADE if failed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">localSocketFd</td><td>fd of local socket that will be used to receive the message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ed8bcf2438f3c7db8b02e3b6596a4a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> unixSocket_ReceiveDataMsg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localSocketFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>dataBuffPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dataSizePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receives a message containing only data payload through a connected Unix domain datagram or sequenced-packet socket.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Any ancillary data (file descriptors or credentials) associated with the message will be discarded.</li>
<li>It is recommended that read() be used for stream sockets.</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if successful</li>
<li>LE_NO_MEMORY if more data was sent than could fit in the buffer provided.</li>
<li>LE_WOULD_BLOCK if the socket is set non-blocking and there is nothing to be received.</li>
<li>LE_CLOSED if the connection closed.</li>
<li>LE_FAULT if failed for some other reason (check your logs).</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If LE_NO_MEMORY is returned, the remainder of the message that couldn't fit into the receive buffer will have been lost. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">localSocketFd</td><td>fd of local socket that will be used to receive the message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dataBuffPtr</td><td>Pointer to where any received data payload will be put. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dataSizePtr</td><td>Ptr to the number of bytes that can fit in the array pointed to by dataBuffPtr. This will be updated to the number of bytes of data received. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab64d779b38aa59e2a433a38f613fe191"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> unixSocket_ReceiveMsg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localSocketFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>dataBuffPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>dataSizePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>fdPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ucred *&#160;</td>
          <td class="paramname"><em>credPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Receives through a connected Unix domain socket a message containing any combination of</p><ul>
<li>a data payload</li>
<li>a file descriptor</li>
<li>authenticated credentials</li>
</ul>
<p>NULL pointers can be passed in for any of the above that are not needed. For example, if data and credentials are expected, but not a file descriptor, then fdPtr could be set to NULL.</p>
<dl class="section note"><dt>Note</dt><dd>Authentication of credentials must be enabled using <a class="el" href="unix_socket_8h.html#a814c92589fc434132bc1cfbfc5b37e5b">unixSocket_EnableAuthentication()</a> before credentials can be received.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if successful</li>
<li>LE_NO_MEMORY if more data was received than could fit in the buffer provided.</li>
<li>LE_WOULD_BLOCK if the socket is set non-blocking and there is nothing to be received.</li>
<li>LE_CLOSED if the connection closed.</li>
<li>LE_FAULT if failed for some other reason (check your logs).</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If LE_WOULD_BLOCK is returned when using a stream socket, some data may have been read. Check the returned data size to find out how much. Furthermore, if LE_NO_MEMORY is returned for a datagram (or sequenced-packet?) socket, the remainder of the message that couldn't fit into the receive buffer will have been lost. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">localSocketFd</td><td>fd of local socket that will be used to receive the message. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dataBuffPtr</td><td>Pointer to where any received data payload will be put. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dataSizePtr</td><td>Ptr to the number of bytes that can fit in the array pointed to by dataBuffPtr. This will be updated to the number of bytes of data received. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">fdPtr</td><td>Pointer to where the received file descriptor will be put. (-1 will be stored here if no fd was received.) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">credPtr</td><td>Pointer to where received credentials will be stored. (NOTE: PID is set to zero if no credentials received.) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b3f6de930eaff61cb764a39d42c4e22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> unixSocket_SendDataMsg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localSocketFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>dataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends a message containing only data through a connected Unix domain datagram or sequenced-packet socket.</p>
<dl class="section note"><dt>Note</dt><dd>It is recommended that write() be used for stream sockets instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if successful</li>
<li>LE_COMM_ERROR if the localSocketFd is not connected.</li>
<li>LE_FAULT if failed for some other reason (check your logs).</li>
<li>LE_NO_MEMORY if the send socket is set to non-blocking and it doesn't have enough buffer space to send right now. Wait for the "writeable" event on the file descriptor. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">localSocketFd</td><td>fd of the local socket that will be used to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataPtr</td><td>Pointer to the data payload to be sent (NULL if none). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>Number of bytes of data payload to be sent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af81ee1e16e1ee2edbb8610fbb4e34ebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> unixSocket_SendMsg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localSocketFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>dataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fdToSend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sendCredentials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sends through a connected Unix domain socket a message containing any combination of:</p><ul>
<li>a data payload</li>
<li>a file descriptor</li>
<li>authenticated credentials</li>
</ul>
<p>All of the above are optional, with the following exceptions:</p><ul>
<li>it doesn't make sense to omit everything</li>
<li>when using stream sockets, at least one byte of data payload must be sent.</li>
</ul>
<p>For example, if data and credentials are to be sent, but not file descriptors, then fdToSend could be set to -1.</p>
<dl class="section note"><dt>Note</dt><dd>When file descriptors are sent, they are duplicated in the receiving process's address space, as if they were created using dup(). This means that they are left open in the sending process and must be closed by the sender if the sender doesn't need to continue using them.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if successful</li>
<li>LE_COMM_ERROR if the localSocketFd is not connected.</li>
<li>LE_FAULT if failed for some other reason (check your logs).</li>
<li>LE_NO_MEMORY if the send socket is set to non-blocking and it doesn't have enough buffer space to send right now. Wait for the "writeable" event on the file descriptor.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>DO NOT SEND DIRECTORY FILE DESCRIPTORS. That can be exploited to break out of chroot() jails. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">localSocketFd</td><td>fd of the local socket that will be used to send. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataPtr</td><td>Pointer to the data payload to be sent (NULL if none). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>Number of bytes of data payload to be sent. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fdToSend</td><td>The file descriptor to be sent (-1 if no FD to send). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sendCredentials</td><td>true = Send credentials. false = Don't send credentials. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
