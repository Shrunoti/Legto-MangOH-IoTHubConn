<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: framework/liblegato/linux/thread.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('thread_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">thread.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="legato_8h_source.html">legato.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="thread_8h_source.html">thread.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_destructor__t.html">Destructor_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4fc325e70c9ce60d7cb7dda3b7ecc3d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a4fc325e70c9ce60d7cb7dda3b7ecc3d8">THREAD_POOL_SIZE</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a4fc325e70c9ce60d7cb7dda3b7ecc3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3207fbc0e620cf42be4430f633d6c3d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#aa3207fbc0e620cf42be4430f633d6c3d">LOW_PRIORITY_NICE_LEVEL</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:aa3207fbc0e620cf42be4430f633d6c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2ccb139807e16cba2b84675629a245"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a9d2ccb139807e16cba2b84675629a245">MEDIUM_PRIORITY_NICE_LEVEL</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a9d2ccb139807e16cba2b84675629a245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67686c612e0bb8187fca32db47d24079"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a67686c612e0bb8187fca32db47d24079">HIGH_PRIORITY_NICE_LEVEL</a>&#160;&#160;&#160;-10</td></tr>
<tr class="separator:a67686c612e0bb8187fca32db47d24079"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a63692d3983734584a66f2ca4db563ad6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a63692d3983734584a66f2ca4db563ad6">Lock</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a63692d3983734584a66f2ca4db563ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba239500052c40aac456def0f18e855"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#abba239500052c40aac456def0f18e855">Unlock</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:abba239500052c40aac456def0f18e855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47dedacce94f8bcfd32b3396a8fbe616"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__thread_8h.html#a738918131ea45ff37440858db2cec7db">le_thread_DestructorRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a47dedacce94f8bcfd32b3396a8fbe616">AddDestructor</a> (<a class="el" href="structthread___obj__t.html">thread_Obj_t</a> *threadPtr, <a class="el" href="le__thread_8h.html#ac0c2e7ab0a7da9fc00c2c546bfc6b0fd">le_thread_Destructor_t</a> destructor, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *context)</td></tr>
<tr class="separator:a47dedacce94f8bcfd32b3396a8fbe616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22055e5f619913e1a24de9a51310c879"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a22055e5f619913e1a24de9a51310c879">DeleteThread</a> (<a class="el" href="structthread___obj__t.html">thread_Obj_t</a> *threadPtr)</td></tr>
<tr class="separator:a22055e5f619913e1a24de9a51310c879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ed905eebe9325962d828d2191bd492"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a49ed905eebe9325962d828d2191bd492">CleanupThread</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *objPtr)</td></tr>
<tr class="separator:a49ed905eebe9325962d828d2191bd492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e15bd422c40c517d38a0829f332cc2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a2e15bd422c40c517d38a0829f332cc2f">thread_InitThread</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a2e15bd422c40c517d38a0829f332cc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7744e2f598378d80ec4e3c9e03cf6f40"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a7744e2f598378d80ec4e3c9e03cf6f40">PThreadStartRoutine</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *threadObjPtr)</td></tr>
<tr class="separator:a7744e2f598378d80ec4e3c9e03cf6f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca3d781b47600ad000fbba987305fbc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structthread___obj__t.html">thread_Obj_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a4ca3d781b47600ad000fbba987305fbc">CreateThread</a> (const char *name, <a class="el" href="le__thread_8h.html#a9210663fea7283e32a6e988ebcf75126">le_thread_MainFunc_t</a> mainFunc, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *context)</td></tr>
<tr class="separator:a4ca3d781b47600ad000fbba987305fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d6abe4c85b595313d879688734f51b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structthread___obj__t.html">thread_Obj_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a19d6abe4c85b595313d879688734f51b">GetCurrentThreadPtr</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a19d6abe4c85b595313d879688734f51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41186a8b8009881f8547a32daf45b7d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#af41186a8b8009881f8547a32daf45b7d">SetSchedPolicyAttr</a> (<a class="el" href="structthread___obj__t.html">thread_Obj_t</a> *threadPtr, int policy, const char *policyName)</td></tr>
<tr class="separator:af41186a8b8009881f8547a32daf45b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96976abee04a41abaf021d9a1b9f686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structle__dls___list__t.html">le_dls_List_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#ae96976abee04a41abaf021d9a1b9f686">thread_GetThreadObjList</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:ae96976abee04a41abaf021d9a1b9f686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb29023416cca9fb64b81e26e7d6f159"><td class="memItemLeft" align="right" valign="top">size_t **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#afb29023416cca9fb64b81e26e7d6f159">thread_GetThreadObjListChgCntRef</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:afb29023416cca9fb64b81e26e7d6f159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa53e0fad0df720d7e085e8c1edbd93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#acfa53e0fad0df720d7e085e8c1edbd93">thread_Init</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:acfa53e0fad0df720d7e085e8c1edbd93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb861f6f893d73375d4817a1a8a5fcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmutex___thread_rec__t.html">mutex_ThreadRec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#adeb861f6f893d73375d4817a1a8a5fcc">thread_GetMutexRecPtr</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:adeb861f6f893d73375d4817a1a8a5fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c762c01422a1032a7dc704f35ddde01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsem___thread_rec__t.html">sem_ThreadRec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a6c762c01422a1032a7dc704f35ddde01">thread_GetSemaphoreRecPtr</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a6c762c01422a1032a7dc704f35ddde01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5938f5ecc8545e73e10e8d1f17f73c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a5938f5ecc8545e73e10e8d1f17f73c87">thread_GetEventRecPtr</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a5938f5ecc8545e73e10e8d1f17f73c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0a0f5e6a7acdfa7867da13a704881b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a4e0a0f5e6a7acdfa7867da13a704881b">thread_GetOtherEventRecPtr</a> (<a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> threadRef)</td></tr>
<tr class="separator:a4e0a0f5e6a7acdfa7867da13a704881b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe34ef327823c7d6b8b82c6ae586953e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtimer___thread_rec__t.html">timer_ThreadRec_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#abe34ef327823c7d6b8b82c6ae586953e">thread_GetTimerRecPtr</a> (<a class="el" href="timer_8h.html#a16e283905d31ea12799612f365c72072">timer_Type_t</a> timerType)</td></tr>
<tr class="separator:abe34ef327823c7d6b8b82c6ae586953e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e02a46f92e9e3e11ed28a2b265872f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a87e02a46f92e9e3e11ed28a2b265872f">le_thread_Create</a> (const char *name, <a class="el" href="le__thread_8h.html#a9210663fea7283e32a6e988ebcf75126">le_thread_MainFunc_t</a> mainFunc, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *context)</td></tr>
<tr class="separator:a87e02a46f92e9e3e11ed28a2b265872f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95257a2f60cacdadc787647453b77356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a95257a2f60cacdadc787647453b77356">le_thread_SetPriority</a> (<a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> thread, <a class="el" href="le__thread_8h.html#a653b0f17cd4d4567c86a25e23d004f07">le_thread_Priority_t</a> priority)</td></tr>
<tr class="separator:a95257a2f60cacdadc787647453b77356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d0476fe2ddd834c39b194164a665b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a91d0476fe2ddd834c39b194164a665b7">le_thread_SetStackSize</a> (<a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> thread, size_t size)</td></tr>
<tr class="separator:a91d0476fe2ddd834c39b194164a665b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8959f09f66f365916a6a4fbdaf36cf65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a8959f09f66f365916a6a4fbdaf36cf65">le_thread_SetJoinable</a> (<a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> thread)</td></tr>
<tr class="separator:a8959f09f66f365916a6a4fbdaf36cf65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38df3877ee5ab9fac17b2fc0be46c27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a38df3877ee5ab9fac17b2fc0be46c27e">le_thread_Start</a> (<a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> thread)</td></tr>
<tr class="separator:a38df3877ee5ab9fac17b2fc0be46c27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf7f24fec4859ca12a52b16ce43fd9b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#adf7f24fec4859ca12a52b16ce43fd9b8">le_thread_Join</a> (<a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> thread, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **resultValuePtr)</td></tr>
<tr class="separator:adf7f24fec4859ca12a52b16ce43fd9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8e349107ae6628ed8807588f044faa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a6b8e349107ae6628ed8807588f044faa">le_thread_Exit</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *resultValue)</td></tr>
<tr class="separator:a6b8e349107ae6628ed8807588f044faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1c1b98f354a96e6e31e55a71b58f6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a0f1c1b98f354a96e6e31e55a71b58f6a">le_thread_Cancel</a> (<a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> threadToCancel)</td></tr>
<tr class="separator:a0f1c1b98f354a96e6e31e55a71b58f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a9d67db26f816fd1e1032d74a24fcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a90a9d67db26f816fd1e1032d74a24fcd">le_thread_GetCurrent</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a90a9d67db26f816fd1e1032d74a24fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4834a35f1afc1f353fc3c808a5ab6a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#ab4834a35f1afc1f353fc3c808a5ab6a2">le_thread_GetName</a> (<a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> threadRef, char *buffPtr, size_t buffSize)</td></tr>
<tr class="separator:ab4834a35f1afc1f353fc3c808a5ab6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c366f881ee31d38de011adb44af12b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a41c366f881ee31d38de011adb44af12b">le_thread_GetMyName</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a41c366f881ee31d38de011adb44af12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb6d7b1729249d185fbf922fa96d27a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__thread_8h.html#a738918131ea45ff37440858db2cec7db">le_thread_DestructorRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a6cb6d7b1729249d185fbf922fa96d27a">le_thread_AddDestructor</a> (<a class="el" href="le__thread_8h.html#ac0c2e7ab0a7da9fc00c2c546bfc6b0fd">le_thread_Destructor_t</a> destructor, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *context)</td></tr>
<tr class="separator:a6cb6d7b1729249d185fbf922fa96d27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671dbe2927a3b2a13c5150476398f34f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a671dbe2927a3b2a13c5150476398f34f">le_thread_AddChildDestructor</a> (<a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> thread, <a class="el" href="le__thread_8h.html#ac0c2e7ab0a7da9fc00c2c546bfc6b0fd">le_thread_Destructor_t</a> destructor, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *context)</td></tr>
<tr class="separator:a671dbe2927a3b2a13c5150476398f34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bb895578b783b45c83acfe862f7358"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#af9bb895578b783b45c83acfe862f7358">le_thread_RemoveDestructor</a> (<a class="el" href="le__thread_8h.html#a738918131ea45ff37440858db2cec7db">le_thread_DestructorRef_t</a> destructor)</td></tr>
<tr class="separator:af9bb895578b783b45c83acfe862f7358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e35d530ce76e97a627dc60100fc1475"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a3e35d530ce76e97a627dc60100fc1475">le_thread_InitLegatoThreadData</a> (const char *name)</td></tr>
<tr class="separator:a3e35d530ce76e97a627dc60100fc1475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef59d0ded85da6ddd169a661824670d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#aef59d0ded85da6ddd169a661824670d0">le_thread_CleanupLegatoThreadData</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:aef59d0ded85da6ddd169a661824670d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a25f51c457b920ff85ac7a1a244b4c198"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__safe_ref_8h.html#aaf8fb3412fb840cb50366856affaf69b">le_ref_MapRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a25f51c457b920ff85ac7a1a244b4c198">ThreadRefMap</a></td></tr>
<tr class="separator:a25f51c457b920ff85ac7a1a244b4c198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb67e3a5cc78ca4f3245725fa2b4c3dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structle__dls___list__t.html">le_dls_List_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#aeb67e3a5cc78ca4f3245725fa2b4c3dc">ThreadObjList</a> = <a class="el" href="le__doubly_linked_list_8h.html#a68f28b61cdfd004591f24730b4d5a740">LE_DLS_LIST_INIT</a></td></tr>
<tr class="separator:aeb67e3a5cc78ca4f3245725fa2b4c3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c5fc5ced212e197bf0641ba03e9a2c"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a91c5fc5ced212e197bf0641ba03e9a2c">ThreadObjListChangeCount</a> = 0</td></tr>
<tr class="separator:a91c5fc5ced212e197bf0641ba03e9a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86b01d232fe6a1b154624fa4f504b0e"><td class="memItemLeft" align="right" valign="top">static size_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#ad86b01d232fe6a1b154624fa4f504b0e">ThreadObjListChangeCountRef</a> = &amp;<a class="el" href="thread_8c.html#a91c5fc5ced212e197bf0641ba03e9a2c">ThreadObjListChangeCount</a></td></tr>
<tr class="separator:ad86b01d232fe6a1b154624fa4f504b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c61536eb7e46e10821be84e2d70e20b"><td class="memItemLeft" align="right" valign="top">static pthread_key_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a9c61536eb7e46e10821be84e2d70e20b">ThreadLocalDataKey</a></td></tr>
<tr class="separator:a9c61536eb7e46e10821be84e2d70e20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee323153283029c6cab00e02ab61d99"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#afee323153283029c6cab00e02ab61d99">ThreadPool</a></td></tr>
<tr class="separator:afee323153283029c6cab00e02ab61d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672d36430970e7fc2b9274228a763c24"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#a672d36430970e7fc2b9274228a763c24">DestructorPool</a></td></tr>
<tr class="separator:a672d36430970e7fc2b9274228a763c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc03085ccf7c38e092cdf06bf6b98ea6"><td class="memItemLeft" align="right" valign="top">static pthread_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="thread_8c.html#abc03085ccf7c38e092cdf06bf6b98ea6">Mutex</a> = PTHREAD_MUTEX_INITIALIZER</td></tr>
<tr class="separator:abc03085ccf7c38e092cdf06bf6b98ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This thread implementation is based on PThreads but is structured slightly differently. Threads are first created, then thread attributes are set, and finally the thread is started in a seperate function call.</p>
<p>When a thread is created a <a class="el" href="structthread___obj__t.html">thread_Obj_t</a> object is created for that thread and used to maintain such things as the thread's name, attributes, destructor list, local data list, etc. The thread object is the implementation of the opaque thread reference le_thread_Ref_t given to the user.</p>
<p>When a thread is started the static function PThreadStartRoutine is always executed. The PThreadStartRoutine is responsible for pushing and popping the static function <a class="el" href="thread_8c.html#a49ed905eebe9325962d828d2191bd492">CleanupThread()</a> onto and off of the pthread's clean up stack and calling the user's main thread function. This ensures that the <a class="el" href="thread_8c.html#a49ed905eebe9325962d828d2191bd492">CleanupThread()</a> is always called when a thread exits. The CleanupThread then calls the list of destructors registered for this thread and cleans up the thread object itself.</p>
<p>Alternatively, if a thread is started using pthreads directly, or some other pthreads wrapper (such as a Boost thread object), that thread can call <a class="el" href="thread_8c.html#a3e35d530ce76e97a627dc60100fc1475">le_thread_InitLegatoThreadData()</a> to create a <a class="el" href="structthread___obj__t.html">thread_Obj_t</a> for that thread and store a pointer to it as thread-specific data using the appropriate key. This allows Legato APIs, such as the event loop, timers, and IPC to work in that thread. Furthermore, if <a class="el" href="thread_8c.html#a3e35d530ce76e97a627dc60100fc1475">le_thread_InitLegatoThreadData()</a> is called for a thread and that thread is to die a long time before the process dies, to prevent memory leaks <a class="el" href="thread_8c.html#aef59d0ded85da6ddd169a661824670d0">le_thread_CleanupLegatoThreadData()</a> can be called by that thread (which calls <a class="el" href="thread_8c.html#a49ed905eebe9325962d828d2191bd492">CleanupThread()</a> manually).</p>
<p>NOTE: If the thread only dies when the process dies, then the OS will clean up the thread-specific data, so <a class="el" href="thread_8c.html#aef59d0ded85da6ddd169a661824670d0">le_thread_CleanupLegatoThreadData()</a> doesn't need to be called in that case.</p>
<p>Copyright (C) Sierra Wireless Inc. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a67686c612e0bb8187fca32db47d24079"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HIGH_PRIORITY_NICE_LEVEL&#160;&#160;&#160;-10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa3207fbc0e620cf42be4430f633d6c3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOW_PRIORITY_NICE_LEVEL&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nice level definitions for the different Legato priority levels. </p>

</div>
</div>
<a class="anchor" id="a9d2ccb139807e16cba2b84675629a245"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEDIUM_PRIORITY_NICE_LEVEL&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4fc325e70c9ce60d7cb7dda3b7ecc3d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define THREAD_POOL_SIZE&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expected number of threads in the process. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000054">Todo:</a></b></dt><dd>Make this configurable. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a47dedacce94f8bcfd32b3396a8fbe616"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__thread_8h.html#a738918131ea45ff37440858db2cec7db">le_thread_DestructorRef_t</a> AddDestructor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structthread___obj__t.html">thread_Obj_t</a> *&#160;</td>
          <td class="paramname"><em>threadPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#ac0c2e7ab0a7da9fc00c2c546bfc6b0fd">le_thread_Destructor_t</a>&#160;</td>
          <td class="paramname"><em>destructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds destructor object to a given thread's Destructor List.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the destructor that can be passed to <a class="el" href="thread_8c.html#af9bb895578b783b45c83acfe862f7358">le_thread_RemoveDestructor()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadPtr</td><td>Ptr to the Thread Object to add the destructor to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor</td><td>The function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Parameter to pass to the destructor function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a49ed905eebe9325962d828d2191bd492"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> CleanupThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>objPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clean-up function that gets run by a thread just before it dies. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objPtr</td><td>Pointer to the Thread object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ca3d781b47600ad000fbba987305fbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structthread___obj__t.html">thread_Obj_t</a>* CreateThread </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a9210663fea7283e32a6e988ebcf75126">le_thread_MainFunc_t</a>&#160;</td>
          <td class="paramname"><em>mainFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new Thread object and initializes it.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the thread (doesn't return if failed).</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will also be called for the process's main thread by the processes main thread. Keep that in mind when modifying this function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mainFunc</td><td>The thread's main function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Value to pass to mainFunc when it is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a22055e5f619913e1a24de9a51310c879"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> DeleteThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structthread___obj__t.html">thread_Obj_t</a> *&#160;</td>
          <td class="paramname"><em>threadPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete a thread object. </p>

</div>
</div>
<a class="anchor" id="a19d6abe4c85b595313d879688734f51b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structthread___obj__t.html">thread_Obj_t</a>* GetCurrentThreadPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets a pointer to the calling thread's Thread Object.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the thread's object. </dd></dl>

</div>
</div>
<a class="anchor" id="a671dbe2927a3b2a13c5150476398f34f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_thread_AddChildDestructor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#ac0c2e7ab0a7da9fc00c2c546bfc6b0fd">le_thread_Destructor_t</a>&#160;</td>
          <td class="paramname"><em>destructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a destructor function for a child thread. The destructor will be called by the child thread just before it terminates.</p>
<p>This can only be done before the child thread is started. After that, only the child thread can add its own destructors.</p>
<p>The reason for allowing another thread to register a destructor function for a thread is to avoid a race condition that can cause resource leakage when a parent thread passes dynamically allocated resources to threads that they create. This is only a problem if the child thread is expected to release the resources when they are finished with them, and the child thread may get cancelled at any time.</p>
<p>For example, a thread <em>T1</em> could allocate an object from a memory pool, create a thread <em>T2</em>, and pass that object to <em>T2</em> for processing and release. <em>T2</em> could register a destructor function to release the resource whenever it terminates, whether through cancellation or normal exit. But, if it's possible that <em>T2</em> could get cancelled before it even has a chance to register a destructor function for itself, the memory pool object could never get released. So, we allow <em>T1</em> to register a destructor function for <em>T2</em> before starting <em>T2</em>.</p>
<p>See <a class="el" href="c_threading.html#threadDestructors">Thread Destructors</a> for more information on destructors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td>The thread to attach the destructor to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor</td><td>The function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Parameter to pass to the destructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6cb6d7b1729249d185fbf922fa96d27a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__thread_8h.html#a738918131ea45ff37440858db2cec7db">le_thread_DestructorRef_t</a> le_thread_AddDestructor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#ac0c2e7ab0a7da9fc00c2c546bfc6b0fd">le_thread_Destructor_t</a>&#160;</td>
          <td class="paramname"><em>destructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a destructor function for the calling thread. The destructor will be called by that thread just before it terminates.</p>
<p>A thread can register (or remove) its own destructor functions any time.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the destructor that can be passed to <a class="el" href="thread_8c.html#af9bb895578b783b45c83acfe862f7358">le_thread_RemoveDestructor()</a>.</dd></dl>
<p>See <a class="el" href="c_threading.html#threadDestructors">Thread Destructors</a> for more information on destructors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor</td><td>The function to be called. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Parameter to pass to the destructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0f1c1b98f354a96e6e31e55a71b58f6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_thread_Cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>&#160;</td>
          <td class="paramname"><em>threadToCancel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells another thread to terminate. This function returns immediately but the termination of the thread happens asynchronously and is not guaranteed to occur when this function returns.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if successful.</li>
<li>LE_NOT_FOUND if the thread doesn't exist. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadToCancel</td><td>Thread to cancel. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aef59d0ded85da6ddd169a661824670d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_thread_CleanupLegatoThreadData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean-up the thread-specific data that was initialized using <a class="el" href="thread_8c.html#a3e35d530ce76e97a627dc60100fc1475">le_thread_InitLegatoThreadData()</a>.</p>
<p>To prevent memory leaks, this must be called by the thread when it dies (unless the whole process is dying).</p>
<dl class="section note"><dt>Note</dt><dd>This is not needed if the thread was started using <a class="el" href="thread_8c.html#a38df3877ee5ab9fac17b2fc0be46c27e">le_thread_Start()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a87e02a46f92e9e3e11ed28a2b265872f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> le_thread_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a9210663fea7283e32a6e988ebcf75126">le_thread_MainFunc_t</a>&#160;</td>
          <td class="paramname"><em>mainFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new Legato thread of execution. After creating the thread, you have the opportunity to set attributes before it starts. It won't start until <a class="el" href="thread_8c.html#a38df3877ee5ab9fac17b2fc0be46c27e">le_thread_Start()</a> is called.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the thread (doesn't return if fails). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Name of the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mainFunc</td><td>The thread's main function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Value to pass to mainFunc when it is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b8e349107ae6628ed8807588f044faa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_thread_Exit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>resultValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Terminates the calling thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">resultValue</td><td>The result value. If this thread is joinable this result can be obtained by another thread calling <a class="el" href="thread_8c.html#adf7f24fec4859ca12a52b16ce43fd9b8">le_thread_Join()</a> on this thread. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90a9d67db26f816fd1e1032d74a24fcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a> le_thread_GetCurrent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the calling thread's thread reference.</p>
<dl class="section return"><dt>Returns</dt><dd>The calling thread's thread reference. </dd></dl>

</div>
</div>
<a class="anchor" id="a41c366f881ee31d38de011adb44af12b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* le_thread_GetMyName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the name of the calling thread. Returns "unknown" if it can't obtain the thread </p>

</div>
</div>
<a class="anchor" id="ab4834a35f1afc1f353fc3c808a5ab6a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_thread_GetName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>&#160;</td>
          <td class="paramname"><em>threadRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the name of a given thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">threadRef</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffPtr</td><td>Buffer to store the name of the thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffSize</td><td>The size of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e35d530ce76e97a627dc60100fc1475"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_thread_InitLegatoThreadData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the thread-specific data needed by the Legato framework for the calling thread.</p>
<p>This is used to turn a non-Legato thread (a thread that was created using a non-Legato API, such as pthread_create() ) into a Legato thread.</p>
<dl class="section note"><dt>Note</dt><dd>This is not needed if the thread was started using <a class="el" href="thread_8c.html#a38df3877ee5ab9fac17b2fc0be46c27e">le_thread_Start()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>A name for the thread (will be copied, so can be temporary). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf7f24fec4859ca12a52b16ce43fd9b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_thread_Join </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **&#160;</td>
          <td class="paramname"><em>resultValuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>"Joins" the calling thread with another thread. Blocks the calling thread until the other thread finishes.</p>
<p>After a thread has been joined with, its thread reference is no longer valid and must never be used again.</p>
<p>The other thread's result value (the value it returned from its main function or passed into <a class="el" href="thread_8c.html#a6b8e349107ae6628ed8807588f044faa">le_thread_Exit()</a>) can be obtained.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if successful.</li>
<li>LE_DEADLOCK if a thread tries to join with itself or two threads try to join each other.</li>
<li>LE_NOT_FOUND if the other thread doesn't exist.</li>
<li>LE_NOT_POSSIBLE if the other thread can't be joined with. </li>
</ul>
</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>the result code LE_NOT_POSSIBLE is scheduled to be removed before 15.04</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The other thread must be "joinable". See <a class="el" href="thread_8c.html#a8959f09f66f365916a6a4fbdaf36cf65">le_thread_SetJoinable()</a>;</dd>
<dd>
It is an error for two or more threads try to join with the same thread. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultValuePtr</td><td>Ptr to where the finished thread's result value will be stored. Can be NULL if the result is not needed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af9bb895578b783b45c83acfe862f7358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_thread_RemoveDestructor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a738918131ea45ff37440858db2cec7db">le_thread_DestructorRef_t</a>&#160;</td>
          <td class="paramname"><em>destructor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a destructor function from the calling thread's list of destructors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">destructor</td><td>Reference to the destructor to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8959f09f66f365916a6a4fbdaf36cf65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_thread_SetJoinable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a thread "joinable", meaning that when it finishes, it will remain in existence until another thread "joins" with it by calling <a class="el" href="thread_8c.html#adf7f24fec4859ca12a52b16ce43fd9b8">le_thread_Join()</a>. By default, threads are not joinable and will be destructed automatically when they finish. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95257a2f60cacdadc787647453b77356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_thread_SetPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a653b0f17cd4d4567c86a25e23d004f07">le_thread_Priority_t</a>&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the priority of a thread.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if successful.</li>
<li>LE_OUT_OF_RANGE if the priority level requested is out of range. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">priority</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91d0476fe2ddd834c39b194164a665b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_thread_SetStackSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>&#160;</td>
          <td class="paramname"><em>thread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the stack size of a thread.</p>
<dl class="section note"><dt>Note</dt><dd>It is generally not necessary to set the stack size. Some reasons why you might are:<ul>
<li>you need to increase it beyond the system's default stack size to prevent overflow for a thread that makes extremely heavy use of the stack;</li>
<li>you want to decrease it to save memory when:<ul>
<li>running in a system that does not support virtual memory</li>
<li>the thread has very tight real-time constraints that require that the stack memory be locked into physical memory to avoid page faults.</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if successful.</li>
<li>LE_OVERFLOW if the stack size requested is too small.</li>
<li>LE_OUT_OF_RANGE if the stack size requested is too large. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Stack size, in bytes. May be rounded up to the nearest virtual memory page size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38df3877ee5ab9fac17b2fc0be46c27e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_thread_Start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>&#160;</td>
          <td class="paramname"><em>thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts a new Legato thread of execution. After creating the thread, you have the opportunity to set attributes before it starts. It won't start until <a class="el" href="thread_8c.html#a38df3877ee5ab9fac17b2fc0be46c27e">le_thread_Start()</a> is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thread</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63692d3983734584a66f2ca4db563ad6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> Lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Locks the module's mutex. </p>

</div>
</div>
<a class="anchor" id="a7744e2f598378d80ec4e3c9e03cf6f40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* PThreadStartRoutine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>threadObjPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a pthread start routine function wrapper. We pass this function to the created pthread and we pass the thread object as a parameter to this function. This function then calls the user's main function. We do this because the user's main function has a different format then the start routine that pthread expects. </p>

</div>
</div>
<a class="anchor" id="af41186a8b8009881f8547a32daf45b7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> SetSchedPolicyAttr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structthread___obj__t.html">thread_Obj_t</a> *&#160;</td>
          <td class="paramname"><em>threadPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>policyName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the scheduling policy attribute for a thread that has not yet been started.</p>
<p>See 'man pthread_attr_setschedpolicy'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">policy</td><td>SCHED_OTHER, SCHED_RR or SCHED_FIFO. </td></tr>
    <tr><td class="paramname">policyName</td><td>Name to use in error/debug messages. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5938f5ecc8545e73e10e8d1f17f73c87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a>* thread_GetEventRecPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the calling thread's event record pointer. </p>

</div>
</div>
<a class="anchor" id="adeb861f6f893d73375d4817a1a8a5fcc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmutex___thread_rec__t.html">mutex_ThreadRec_t</a>* thread_GetMutexRecPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the calling thread's mutex record. </p>

</div>
</div>
<a class="anchor" id="a4e0a0f5e6a7acdfa7867da13a704881b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structevent___per_thread_rec__t.html">event_PerThreadRec_t</a>* thread_GetOtherEventRecPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__thread_8h.html#a32121104c6b4ca39008eb79a4d6862f2">le_thread_Ref_t</a>&#160;</td>
          <td class="paramname"><em>threadRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets another thread's event record. </p>

</div>
</div>
<a class="anchor" id="a6c762c01422a1032a7dc704f35ddde01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsem___thread_rec__t.html">sem_ThreadRec_t</a>* thread_GetSemaphoreRecPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the calling thread's semaphore record. </p>

</div>
</div>
<a class="anchor" id="ae96976abee04a41abaf021d9a1b9f686"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structle__dls___list__t.html">le_dls_List_t</a>* thread_GetThreadObjList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exposing the thread obj list; mainly for the Inspect tool. </p>

</div>
</div>
<a class="anchor" id="afb29023416cca9fb64b81e26e7d6f159"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t** thread_GetThreadObjListChgCntRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exposing the thread obj list change counter; mainly for the Inspect tool. </p>

</div>
</div>
<a class="anchor" id="abe34ef327823c7d6b8b82c6ae586953e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtimer___thread_rec__t.html">timer_ThreadRec_t</a>* thread_GetTimerRecPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="timer_8h.html#a16e283905d31ea12799612f365c72072">timer_Type_t</a>&#160;</td>
          <td class="paramname"><em>timerType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the specified calling thread's timer record. </p>

</div>
</div>
<a class="anchor" id="acfa53e0fad0df720d7e085e8c1edbd93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> thread_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the thread system. This function must be called before any other thread functions are called.</p>
<dl class="section note"><dt>Note</dt><dd>On failure, the process exits. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e15bd422c40c517d38a0829f332cc2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> thread_InitThread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform thread specific initialization for the current thread </p>

</div>
</div>
<a class="anchor" id="abba239500052c40aac456def0f18e855"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> Unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unlocks the module's mutex. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a672d36430970e7fc2b9274228a763c24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a> DestructorPool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A memory pool for the destructor objects. This pool is shared amongst all threads. </p>

</div>
</div>
<a class="anchor" id="abc03085ccf7c38e092cdf06bf6b98ea6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t Mutex = PTHREAD_MUTEX_INITIALIZER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mutex used to protect data structures within this module from multithreaded race conditions. </p>

</div>
</div>
<a class="anchor" id="a9c61536eb7e46e10821be84e2d70e20b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pthread_key_t ThreadLocalDataKey</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Key under which the pointer to the Thread Object (<a class="el" href="structthread___obj__t.html">thread_Obj_t</a>) will be kept in thread-local storage. This allows a thread to quickly get a pointer to its own Thread Object. </p>

</div>
</div>
<a class="anchor" id="aeb67e3a5cc78ca4f3245725fa2b4c3dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structle__dls___list__t.html">le_dls_List_t</a> ThreadObjList = <a class="el" href="le__doubly_linked_list_8h.html#a68f28b61cdfd004591f24730b4d5a740">LE_DLS_LIST_INIT</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Thread object list for the purpose of the Inspect tool ONLY. For accessing thread objects in this module, the safe reference map should be used. </p>

</div>
</div>
<a class="anchor" id="a91c5fc5ced212e197bf0641ba03e9a2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t ThreadObjListChangeCount = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A counter that increments every time a change is made to ThreadObjList. </p>

</div>
</div>
<a class="anchor" id="ad86b01d232fe6a1b154624fa4f504b0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t* ThreadObjListChangeCountRef = &amp;<a class="el" href="thread_8c.html#a91c5fc5ced212e197bf0641ba03e9a2c">ThreadObjListChangeCount</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afee323153283029c6cab00e02ab61d99"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a> ThreadPool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A memory pool of thread objects. </p>

</div>
</div>
<a class="anchor" id="a25f51c457b920ff85ac7a1a244b4c198"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__safe_ref_8h.html#aaf8fb3412fb840cb50366856affaf69b">le_ref_MapRef_t</a> ThreadRefMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Safe reference map for Thread References. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
