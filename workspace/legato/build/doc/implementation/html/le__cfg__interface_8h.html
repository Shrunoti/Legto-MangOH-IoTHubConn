<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: build/localhost/interfaces/le_cfg_interface.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('le__cfg__interface_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">le_cfg_interface.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="legato_8h_source.html">legato.h</a>&quot;</code><br />
</div>
<p><a href="le__cfg__interface_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a883b19e65e43b6f7ab2e1e31f0e88572"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a883b19e65e43b6f7ab2e1e31f0e88572">LE_CFG_STR_LEN</a>&#160;&#160;&#160;511</td></tr>
<tr class="separator:a883b19e65e43b6f7ab2e1e31f0e88572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea00ee500b7beccc4bf46ab637190a55"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aea00ee500b7beccc4bf46ab637190a55">LE_CFG_STR_LEN_BYTES</a>&#160;&#160;&#160;512</td></tr>
<tr class="separator:aea00ee500b7beccc4bf46ab637190a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3967baad29e54db0f06459c38696e064"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a3967baad29e54db0f06459c38696e064">LE_CFG_NAME_LEN</a>&#160;&#160;&#160;127</td></tr>
<tr class="separator:a3967baad29e54db0f06459c38696e064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ddb1ec9647e834325a62fbe82c6a85"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a28ddb1ec9647e834325a62fbe82c6a85">LE_CFG_NAME_LEN_BYTES</a>&#160;&#160;&#160;128</td></tr>
<tr class="separator:a28ddb1ec9647e834325a62fbe82c6a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aff2b4ba4a4eacc417e0e2b9fd32bdf12"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aff2b4ba4a4eacc417e0e2b9fd32bdf12">le_cfg_DisconnectHandler_t</a>) (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *)</td></tr>
<tr class="separator:aff2b4ba4a4eacc417e0e2b9fd32bdf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a646829934bb23a878e19ade2c3e01eba"><td class="memItemLeft" align="right" valign="top">typedef struct le_cfg_Iterator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a></td></tr>
<tr class="separator:a646829934bb23a878e19ade2c3e01eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02e652d8ea74b6e8ebb8125190e5244"><td class="memItemLeft" align="right" valign="top">typedef struct le_cfg_ChangeHandler *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a></td></tr>
<tr class="separator:ad02e652d8ea74b6e8ebb8125190e5244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9b4508a0faa6a5d91a4bace0b8976c0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ac9b4508a0faa6a5d91a4bace0b8976c0">le_cfg_ChangeHandlerFunc_t</a>) (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *contextPtr)</td></tr>
<tr class="separator:ac9b4508a0faa6a5d91a4bace0b8976c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a29c8480b3310d1235487d7ea96d8b57d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a29c8480b3310d1235487d7ea96d8b57d">le_cfg_nodeType_t</a> { <br />
&#160;&#160;<a class="el" href="le__cfg__interface_8h.html#a29c8480b3310d1235487d7ea96d8b57da545f7e9317020efc82e268c2c08b7e4b">LE_CFG_TYPE_EMPTY</a> = 0, 
<a class="el" href="le__cfg__interface_8h.html#a29c8480b3310d1235487d7ea96d8b57da7f65f22b4f8a8baca2f3ac4087a09730">LE_CFG_TYPE_STRING</a> = 1, 
<a class="el" href="le__cfg__interface_8h.html#a29c8480b3310d1235487d7ea96d8b57dafe64ea58a518cef6fbeefe9ee8fea944">LE_CFG_TYPE_BOOL</a> = 2, 
<a class="el" href="le__cfg__interface_8h.html#a29c8480b3310d1235487d7ea96d8b57dae15135ce3aea7925fba96a16eefd7d01">LE_CFG_TYPE_INT</a> = 3, 
<br />
&#160;&#160;<a class="el" href="le__cfg__interface_8h.html#a29c8480b3310d1235487d7ea96d8b57da51f9f84c78b8ce049f85f28da0d3596b">LE_CFG_TYPE_FLOAT</a> = 4, 
<a class="el" href="le__cfg__interface_8h.html#a29c8480b3310d1235487d7ea96d8b57dab720da857c99845f5fac9499b3bfed4e">LE_CFG_TYPE_STEM</a> = 5, 
<a class="el" href="le__cfg__interface_8h.html#a29c8480b3310d1235487d7ea96d8b57da2eaa4a8ac9d9b37b4cdd9b43c0168d17">LE_CFG_TYPE_DOESNT_EXIST</a> = 6
<br />
 }</td></tr>
<tr class="separator:a29c8480b3310d1235487d7ea96d8b57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afbcfae9ac989c5cb82d1cf72a32a7079"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#afbcfae9ac989c5cb82d1cf72a32a7079">le_cfg_ConnectService</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:afbcfae9ac989c5cb82d1cf72a32a7079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95903ceaf3bf1037f9ea5712d74d490"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ae95903ceaf3bf1037f9ea5712d74d490">le_cfg_TryConnectService</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:ae95903ceaf3bf1037f9ea5712d74d490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a110f59916a8073d39b1cfc1e8cf51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#af4a110f59916a8073d39b1cfc1e8cf51">le_cfg_SetServerDisconnectHandler</a> (<a class="el" href="le__cfg__interface_8h.html#aff2b4ba4a4eacc417e0e2b9fd32bdf12">le_cfg_DisconnectHandler_t</a> disconnectHandler, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *contextPtr)</td></tr>
<tr class="separator:af4a110f59916a8073d39b1cfc1e8cf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a772505f5bd6d7e68ace12aa36e51d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a9a772505f5bd6d7e68ace12aa36e51d9">le_cfg_DisconnectService</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a9a772505f5bd6d7e68ace12aa36e51d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70663c8b4bd50327bb3771acb694c18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ae70663c8b4bd50327bb3771acb694c18">le_cfg_CreateReadTxn</a> (const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> basePath)</td></tr>
<tr class="separator:ae70663c8b4bd50327bb3771acb694c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a263340159319b01bb64e32341a7786"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a5a263340159319b01bb64e32341a7786">le_cfg_CreateWriteTxn</a> (const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> basePath)</td></tr>
<tr class="separator:a5a263340159319b01bb64e32341a7786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9825af4d2e007d82f4385ee444a348ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a9825af4d2e007d82f4385ee444a348ef">le_cfg_CommitTxn</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef)</td></tr>
<tr class="separator:a9825af4d2e007d82f4385ee444a348ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f10497ed85d2e647b41ca460228483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#af5f10497ed85d2e647b41ca460228483">le_cfg_CancelTxn</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef)</td></tr>
<tr class="separator:af5f10497ed85d2e647b41ca460228483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85e0663dcd80f5ff262de7c6adbf607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#af85e0663dcd80f5ff262de7c6adbf607">le_cfg_GoToNode</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> newPath)</td></tr>
<tr class="separator:af85e0663dcd80f5ff262de7c6adbf607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d7debfc7c78b3a8b3908fcbc1a5966"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ad7d7debfc7c78b3a8b3908fcbc1a5966">le_cfg_GoToParent</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef)</td></tr>
<tr class="separator:ad7d7debfc7c78b3a8b3908fcbc1a5966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7ab8d52ca9bf5e0977341e18740079"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#abb7ab8d52ca9bf5e0977341e18740079">le_cfg_GoToFirstChild</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef)</td></tr>
<tr class="separator:abb7ab8d52ca9bf5e0977341e18740079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcdb4bf55c14d960b7d16bb05af4bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aafcdb4bf55c14d960b7d16bb05af4bbe">le_cfg_GoToNextSibling</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef)</td></tr>
<tr class="separator:aafcdb4bf55c14d960b7d16bb05af4bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37174a5934ea2ad5774231f0c8e7c316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a37174a5934ea2ad5774231f0c8e7c316">le_cfg_GetPath</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, char *pathBuffer, size_t pathBufferSize)</td></tr>
<tr class="separator:a37174a5934ea2ad5774231f0c8e7c316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103715312749704c5ab41755bc904fa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__cfg__interface_8h.html#a29c8480b3310d1235487d7ea96d8b57d">le_cfg_nodeType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a103715312749704c5ab41755bc904fa9">le_cfg_GetNodeType</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path)</td></tr>
<tr class="separator:a103715312749704c5ab41755bc904fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1604038fde1f5d378920ec7e3c7254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a4f1604038fde1f5d378920ec7e3c7254">le_cfg_GetNodeName</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, char *name, size_t nameSize)</td></tr>
<tr class="separator:a4f1604038fde1f5d378920ec7e3c7254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84bb98f1aee5d47692a0b776c89729b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#af84bb98f1aee5d47692a0b776c89729b">le_cfg_AddChangeHandler</a> (const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> newPath, <a class="el" href="le__cfg__interface_8h.html#ac9b4508a0faa6a5d91a4bace0b8976c0">le_cfg_ChangeHandlerFunc_t</a> handlerPtr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *contextPtr)</td></tr>
<tr class="separator:af84bb98f1aee5d47692a0b776c89729b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae839eaf925f0498c728ab44f1bdcec66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ae839eaf925f0498c728ab44f1bdcec66">le_cfg_RemoveChangeHandler</a> (<a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a> handlerRef)</td></tr>
<tr class="separator:ae839eaf925f0498c728ab44f1bdcec66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad825e1c209d5cea5a008d723732d99cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ad825e1c209d5cea5a008d723732d99cf">le_cfg_DeleteNode</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path)</td></tr>
<tr class="separator:ad825e1c209d5cea5a008d723732d99cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eec2e4cc497c98c353b7a7f9c05c68"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ad4eec2e4cc497c98c353b7a7f9c05c68">le_cfg_IsEmpty</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path)</td></tr>
<tr class="separator:ad4eec2e4cc497c98c353b7a7f9c05c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb99506c800a2dcaae2c2a7c7cf5e3d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#adb99506c800a2dcaae2c2a7c7cf5e3d1">le_cfg_SetEmpty</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path)</td></tr>
<tr class="separator:adb99506c800a2dcaae2c2a7c7cf5e3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a26378faf84f4d95532c359a2d9e0c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a4a26378faf84f4d95532c359a2d9e0c2">le_cfg_NodeExists</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path)</td></tr>
<tr class="separator:a4a26378faf84f4d95532c359a2d9e0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8917f78c8434c2418d7612706d0c1a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ac8917f78c8434c2418d7612706d0c1a9">le_cfg_GetString</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, char *value, size_t valueSize, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> defaultValue)</td></tr>
<tr class="separator:ac8917f78c8434c2418d7612706d0c1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f31a75f9140825c7ba9b8c0922dcfc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a8f31a75f9140825c7ba9b8c0922dcfc1">le_cfg_SetString</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> value)</td></tr>
<tr class="separator:a8f31a75f9140825c7ba9b8c0922dcfc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf09647cee8da04d1059e2c4853d0f56"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#adf09647cee8da04d1059e2c4853d0f56">le_cfg_GetInt</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, int32_t defaultValue)</td></tr>
<tr class="separator:adf09647cee8da04d1059e2c4853d0f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b76404cf41ab83d5136ac95e9361146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a8b76404cf41ab83d5136ac95e9361146">le_cfg_SetInt</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, int32_t value)</td></tr>
<tr class="separator:a8b76404cf41ab83d5136ac95e9361146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb5cc5f7cabc3d3783b0836069868e0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#afdb5cc5f7cabc3d3783b0836069868e0">le_cfg_GetFloat</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, double defaultValue)</td></tr>
<tr class="separator:afdb5cc5f7cabc3d3783b0836069868e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918ac92140db2cd6d5254d24f2b0238a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a918ac92140db2cd6d5254d24f2b0238a">le_cfg_SetFloat</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, double value)</td></tr>
<tr class="separator:a918ac92140db2cd6d5254d24f2b0238a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c400e8c5d74ff7068885fac0ea241c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a41c400e8c5d74ff7068885fac0ea241c">le_cfg_GetBool</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, bool defaultValue)</td></tr>
<tr class="separator:a41c400e8c5d74ff7068885fac0ea241c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae21ad3f9372ae47880e028981acc0a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aae21ad3f9372ae47880e028981acc0a5">le_cfg_SetBool</a> (<a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> iteratorRef, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, bool value)</td></tr>
<tr class="separator:aae21ad3f9372ae47880e028981acc0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed55baa6230a9f4dbaf2ab866df8498f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#aed55baa6230a9f4dbaf2ab866df8498f">le_cfg_QuickDeleteNode</a> (const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path)</td></tr>
<tr class="separator:aed55baa6230a9f4dbaf2ab866df8498f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eade6f9db86d436f9bb6d3880338bfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a9eade6f9db86d436f9bb6d3880338bfb">le_cfg_QuickSetEmpty</a> (const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path)</td></tr>
<tr class="separator:a9eade6f9db86d436f9bb6d3880338bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2052658a14783a42066a598e2c8bf78b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a2052658a14783a42066a598e2c8bf78b">le_cfg_QuickGetString</a> (const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, char *value, size_t valueSize, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> defaultValue)</td></tr>
<tr class="separator:a2052658a14783a42066a598e2c8bf78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0f85ab12026bb61f6c1741c99955fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a0a0f85ab12026bb61f6c1741c99955fe">le_cfg_QuickSetString</a> (const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> value)</td></tr>
<tr class="separator:a0a0f85ab12026bb61f6c1741c99955fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af050868a37a4345c369bc5018fb1a214"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#af050868a37a4345c369bc5018fb1a214">le_cfg_QuickGetInt</a> (const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, int32_t defaultValue)</td></tr>
<tr class="separator:af050868a37a4345c369bc5018fb1a214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7b8a204cf4216282cfb5e43364f51a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#ab7b8a204cf4216282cfb5e43364f51a3">le_cfg_QuickSetInt</a> (const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, int32_t value)</td></tr>
<tr class="separator:ab7b8a204cf4216282cfb5e43364f51a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb62a6c8d943aa33a5f59dbd297ff8c0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#adb62a6c8d943aa33a5f59dbd297ff8c0">le_cfg_QuickGetFloat</a> (const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, double defaultValue)</td></tr>
<tr class="separator:adb62a6c8d943aa33a5f59dbd297ff8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1336c5084379dfcb11f2417e0960c338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a1336c5084379dfcb11f2417e0960c338">le_cfg_QuickSetFloat</a> (const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, double value)</td></tr>
<tr class="separator:a1336c5084379dfcb11f2417e0960c338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbb9270f05e4b5989bf8dc3b10d362f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a9dbb9270f05e4b5989bf8dc3b10d362f">le_cfg_QuickGetBool</a> (const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, bool defaultValue)</td></tr>
<tr class="separator:a9dbb9270f05e4b5989bf8dc3b10d362f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6df26410f5e9194e400ab8d60cfe94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__cfg__interface_8h.html#a1b6df26410f5e9194e400ab8d60cfe94">le_cfg_QuickSetBool</a> (const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a> path, bool value)</td></tr>
<tr class="separator:a1b6df26410f5e9194e400ab8d60cfe94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Legato <a class="el" href="c_config.html">Config Tree API</a> include file.</p>
<p>Copyright (C) Sierra Wireless Inc. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a3967baad29e54db0f06459c38696e064"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LE_CFG_NAME_LEN&#160;&#160;&#160;127</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allowed length of a node name. </p>

</div>
</div>
<a class="anchor" id="a28ddb1ec9647e834325a62fbe82c6a85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LE_CFG_NAME_LEN_BYTES&#160;&#160;&#160;128</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The node name length, including a trailing NULL. </p>

</div>
</div>
<a class="anchor" id="a883b19e65e43b6f7ab2e1e31f0e88572"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LE_CFG_STR_LEN&#160;&#160;&#160;511</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of the strings used by this API. </p>

</div>
</div>
<a class="anchor" id="aea00ee500b7beccc4bf46ab637190a55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LE_CFG_STR_LEN_BYTES&#160;&#160;&#160;512</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Length of the strings used by this API, including the trailing NULL. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ac9b4508a0faa6a5d91a4bace0b8976c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>(* le_cfg_ChangeHandlerFunc_t) (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *contextPtr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handler for node change notifications. </p>

</div>
</div>
<a class="anchor" id="ad02e652d8ea74b6e8ebb8125190e5244"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct le_cfg_ChangeHandler* <a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reference type used by Add/Remove functions for EVENT 'le_cfg_Change' </p>

</div>
</div>
<a class="anchor" id="aff2b4ba4a4eacc417e0e2b9fd32bdf12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>(* le_cfg_DisconnectHandler_t) (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for handler called when a server disconnects. </p>

</div>
</div>
<a class="anchor" id="a646829934bb23a878e19ade2c3e01eba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct le_cfg_Iterator* <a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reference to a tree iterator object. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a29c8480b3310d1235487d7ea96d8b57d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="le__cfg__interface_8h.html#a29c8480b3310d1235487d7ea96d8b57d">le_cfg_nodeType_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identifies the data type of node. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a29c8480b3310d1235487d7ea96d8b57da545f7e9317020efc82e268c2c08b7e4b"></a>LE_CFG_TYPE_EMPTY&#160;</td><td class="fielddoc">
<p>A node with no value. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29c8480b3310d1235487d7ea96d8b57da7f65f22b4f8a8baca2f3ac4087a09730"></a>LE_CFG_TYPE_STRING&#160;</td><td class="fielddoc">
<p>A string encoded as utf8. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29c8480b3310d1235487d7ea96d8b57dafe64ea58a518cef6fbeefe9ee8fea944"></a>LE_CFG_TYPE_BOOL&#160;</td><td class="fielddoc">
<p>Boolean value. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29c8480b3310d1235487d7ea96d8b57dae15135ce3aea7925fba96a16eefd7d01"></a>LE_CFG_TYPE_INT&#160;</td><td class="fielddoc">
<p>Signed 32-bit. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29c8480b3310d1235487d7ea96d8b57da51f9f84c78b8ce049f85f28da0d3596b"></a>LE_CFG_TYPE_FLOAT&#160;</td><td class="fielddoc">
<p>64-bit floating point value. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29c8480b3310d1235487d7ea96d8b57dab720da857c99845f5fac9499b3bfed4e"></a>LE_CFG_TYPE_STEM&#160;</td><td class="fielddoc">
<p>Non-leaf node, this node is the parent of other nodes. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a29c8480b3310d1235487d7ea96d8b57da2eaa4a8ac9d9b37b4cdd9b43c0168d17"></a>LE_CFG_TYPE_DOESNT_EXIST&#160;</td><td class="fielddoc">
<p>Node doesn't exist. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af84bb98f1aee5d47692a0b776c89729b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a> le_cfg_AddChangeHandler </td>
          <td>(</td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>newPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#ac9b4508a0faa6a5d91a4bace0b8976c0">le_cfg_ChangeHandlerFunc_t</a>&#160;</td>
          <td class="paramname"><em>handlerPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>contextPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add handler function for EVENT 'le_cfg_Change'</p>
<p>This event provides information on changes to the given node object, or any of it's children, where a change could be either a read, write, create or delete operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">newPath</td><td>Path to the object to watch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerPtr</td><td>Handler to receive change notification </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5f10497ed85d2e647b41ca460228483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_CancelTxn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes and frees the given iterator object. If the iterator is a write iterator, the transaction will be canceled. If the iterator is a read iterator, the transaction will be closed. No data is written to the tree</p>
<dl class="section note"><dt>Note</dt><dd>This operation will also delete the iterator object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9825af4d2e007d82f4385ee444a348ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_CommitTxn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the write iterator and commits the write transaction. This updates the config tree with all of the writes that occurred within the iterator.</p>
<dl class="section note"><dt>Note</dt><dd>This operation will also delete the iterator object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to commit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbcfae9ac989c5cb82d1cf72a32a7079"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_ConnectService </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect the current client thread to the service providing this API. Block until the service is available.</p>
<p>For each thread that wants to use this API, either ConnectService or TryConnectService must be called before any other functions in this API. Normally, ConnectService is automatically called for the main thread, but not for any other thread. For details, see <a class="el" href="apiFilesC.html#apiFilesC_client">Client-specific Functions</a>.</p>
<p>This function is created automatically. </p>

</div>
</div>
<a class="anchor" id="ae70663c8b4bd50327bb3771acb694c18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> le_cfg_CreateReadTxn </td>
          <td>(</td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>basePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a read transaction and open a new iterator for traversing the config tree.</p>
<p>This action creates a read lock on the given tree, which will start a read-timeout. Once the read timeout expires, all active read iterators on that tree will be expired and their clients will be killed.</p>
<dl class="section note"><dt>Note</dt><dd>A tree transaction is global to that tree; a long-held read transaction will block other user's write transactions from being committed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This will return the newly created iterator reference. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basePath</td><td>Path to the location to create the new iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a263340159319b01bb64e32341a7786"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a> le_cfg_CreateWriteTxn </td>
          <td>(</td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>basePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a write transaction and open a new iterator for both reading and writing.</p>
<p>This action creates a write transaction. If the app holds the iterator for longer than the configured write transaction timeout, the iterator will cancel the transaction. Other reads will fail to return data, and all writes will be thrown away.</p>
<dl class="section note"><dt>Note</dt><dd>A tree transaction is global to that tree; a long-held write transaction will block other user's write transactions from being started. Other trees in the system won't be affected.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>This will return a newly created iterator reference. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">basePath</td><td>Path to the location to create the new iterator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad825e1c209d5cea5a008d723732d99cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_DeleteNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the node specified by the path. If the node doesn't exist, nothing happens. All child nodes are also deleted.</p>
<p>If the path is empty, the iterator's current node is deleted.</p>
<p>This function is only valid during a write transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a772505f5bd6d7e68ace12aa36e51d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_DisconnectService </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disconnect the current client thread from the service providing this API.</p>
<p>Normally, this function doesn't need to be called. After this function is called, there's no longer a connection to the service, and the functions in this API can't be used. For details, see <a class="el" href="apiFilesC.html#apiFilesC_client">Client-specific Functions</a>.</p>
<p>This function is created automatically. </p>

</div>
</div>
<a class="anchor" id="a41c400e8c5d74ff7068885fac0ea241c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_cfg_GetBool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a value from the tree as a boolean. If the node is empty or doesn't exist, the default value is returned. Default value is also returned if the node is a different type than expected.</p>
<p>Valid for both read and write transactions.</p>
<p>If the path is empty, the iterator's current node will be read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afdb5cc5f7cabc3d3783b0836069868e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double le_cfg_GetFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 64-bit floating point value from the config tree.</p>
<p>If the value is an integer then the value will be promoted to a float. Otherwise, if the underlying value is not a float or integer, the default value will be returned.</p>
<p>If the path is empty, the iterator's current node will be read.</p>
<dl class="section note"><dt>Note</dt><dd>Floating point values will only be stored up to 6 digits of precision. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf09647cee8da04d1059e2c4853d0f56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t le_cfg_GetInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a signed integer value from the config tree.</p>
<p>If the underlying value is not an integer, the default value will be returned instead. The default value is also returned if the node does not exist or if it's empty.</p>
<p>If the value is a floating point value, then it will be rounded and returned as an integer.</p>
<p>Valid for both read and write transactions.</p>
<p>If the path is empty, the iterator's current node will be read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4f1604038fde1f5d378920ec7e3c7254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_cfg_GetNodeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nameSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of the node where the iterator is currently pointing.</p>
<dl class="section return"><dt>Returns</dt><dd>- LE_OK Read was completed successfully.<ul>
<li>LE_OVERFLOW Supplied string buffer was not large enough to hold the value. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to use to read from the tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">name</td><td>Read the name of the node object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nameSize</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a103715312749704c5ab41755bc904fa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__cfg__interface_8h.html#a29c8480b3310d1235487d7ea96d8b57d">le_cfg_nodeType_t</a> le_cfg_GetNodeType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the data type of node where the iterator is currently pointing.</p>
<dl class="section return"><dt>Returns</dt><dd>le_cfg_nodeType_t value indicating the stored value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to use to read from the tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37174a5934ea2ad5774231f0c8e7c316"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_cfg_GetPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pathBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pathBufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get path to the node where the iterator is currently pointed.</p>
<p>Assuming the following tree:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;baseNode</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     |</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     +childA</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;         |</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;         +valueA</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;         |</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;         +valueB</div></div><!-- fragment --><p>If the iterator was currently pointing at valueA, GetPath would return the following path:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/baseNode/childA/valueA</div></div><!-- fragment --><p>Optionally, a path to another node can be supplied to this function. So, if the iterator is again on valueA and the relative path ".." is supplied then this function will return the the path relative to the node given:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;/baseNode/childA/</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>- LE_OK - The write was completed successfully.<ul>
<li>LE_OVERFLOW - The supplied string buffer was not large enough to hold the value. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to move. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pathBuffer</td><td>Absolute path to the iterator's current node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathBufferSize</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8917f78c8434c2418d7612706d0c1a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_cfg_GetString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>valueSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a string value from the config tree. If the value isn't a string, or if the node is empty or doesn't exist, the default value will be returned.</p>
<p>Valid for both read and write transactions.</p>
<p>If the path is empty, the iterator's current node will be read.</p>
<dl class="section return"><dt>Returns</dt><dd>- LE_OK - Read was completed successfully.<ul>
<li>LE_OVERFLOW - Supplied string buffer was not large enough to hold the value. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Buffer to write the value into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueSize</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb7ab8d52ca9bf5e0977341e18740079"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_cfg_GoToFirstChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the iterator to the the first child of the node from the current location.</p>
<p>For read iterators without children, this function will fail. If the iterator is a write iterator, then a new node is automatically created. If this node or newly created children of this node are not written to, then this node will not persist even if the iterator is committed.</p>
<dl class="section return"><dt>Returns</dt><dd>Return code will be one of the following values: <pre class="fragment">    - LE_OK        - Move was completed successfully.
    - LE_NOT_FOUND - The given node has no children.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator object to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafcdb4bf55c14d960b7d16bb05af4bbe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_cfg_GoToNextSibling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Jumps the iterator to the next child node of the current node. Assuming the following tree:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;baseNode</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     |</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;     +childA</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;         |</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;         +valueA</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;         |</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;         +valueB</div></div><!-- fragment --><p>If the iterator is moved to the path, "/baseNode/childA/valueA". After the first GoToNextSibling the iterator will be pointing at valueB. A second call to GoToNextSibling will cause the function to return LE_NOT_FOUND.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns one of the following values: <pre class="fragment">    - LE_OK            - Commit was completed successfully.
    - LE_NOT_FOUND     - Iterator has reached the end of the current list of siblings.
                         Also returned if the the current node has no siblings.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to iterate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af85e0663dcd80f5ff262de7c6adbf607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_GoToNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>newPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the location of iterator. The path passed can be an absolute or a relative path from the iterators current location.</p>
<p>The target node does not need to exist. Writing a value to a non-existent node will automatically create that node and any ancestor nodes (parent, parent's parent, etc.) that also don't exist. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to move. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPath</td><td>Absolute or relative path from the current location. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7d7debfc7c78b3a8b3908fcbc1a5966"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_cfg_GoToParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move the iterator to the parent of the current node (moves up the tree).</p>
<dl class="section return"><dt>Returns</dt><dd>Return code will be one of the following values: <pre class="fragment">    - LE_OK        - Commit was completed successfully.
    - LE_NOT_FOUND - Current node is the root node: has no parent.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4eec2e4cc497c98c353b7a7f9c05c68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_cfg_IsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the given node is empty. A node is also considered empty if it doesn't yet exist. A node is also considered empty if it has no value or is a stem with no children.</p>
<p>If the path is empty, the iterator's current node is queried for emptiness.</p>
<p>Valid for both read and write transactions.</p>
<dl class="section return"><dt>Returns</dt><dd>A true if the node is considered empty, false if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a26378faf84f4d95532c359a2d9e0c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_cfg_NodeExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks to see if a given node in the config tree exists.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the specified node exists in the tree. False if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed55baa6230a9f4dbaf2ab866df8498f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickDeleteNode </td>
          <td>(</td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the node specified by the path. If the node doesn't exist, nothing happens. All child nodes are also deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the node to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9dbb9270f05e4b5989bf8dc3b10d362f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_cfg_QuickGetBool </td>
          <td>(</td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a value from the tree as a boolean. If the node is empty or doesn't exist, the default value is returned. This is also true if the node is a different type than expected.</p>
<p>If the value is empty or the node doesn't exist, the default value is returned instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb62a6c8d943aa33a5f59dbd297ff8c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double le_cfg_QuickGetFloat </td>
          <td>(</td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 64-bit floating point value from the config tree. If the value is an integer, then it is promoted to a float. Otherwise, if the underlying value is not a float, or an integer the default value will be returned.</p>
<p>If the value is empty or the node doesn't exist, the default value is returned.</p>
<dl class="section note"><dt>Note</dt><dd>Floating point values will only be stored up to 6 digits of precision. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af050868a37a4345c369bc5018fb1a214"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t le_cfg_QuickGetInt </td>
          <td>(</td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a signed integer value from the config tree. If the value is a floating point value, then it will be rounded and returned as an integer. Otherwise If the underlying value is not an integer or a float, the default value will be returned instead.</p>
<p>If the value is empty or the node doesn't exist, the default value is returned instead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2052658a14783a42066a598e2c8bf78b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_cfg_QuickGetString </td>
          <td>(</td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>valueSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a string value from the config tree. If the value isn't a string, or if the node is empty or doesn't exist, the default value will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>- LE_OK - Commit was completed successfully.<ul>
<li>LE_OVERFLOW - Supplied string buffer was not large enough to hold the value. </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>Value read from the requested node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valueSize</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use if the original can't be read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1b6df26410f5e9194e400ab8d60cfe94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickSetBool </td>
          <td>(</td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a boolean value to the config tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9eade6f9db86d436f9bb6d3880338bfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickSetEmpty </td>
          <td>(</td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the current value of a node. If the node doesn't currently exist then it is created as a new empty node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Absolute or relative path to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1336c5084379dfcb11f2417e0960c338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickSetFloat </td>
          <td>(</td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a 64-bit floating point value to the config tree.</p>
<dl class="section note"><dt>Note</dt><dd>Floating point values will only be stored up to 6 digits of precision. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab7b8a204cf4216282cfb5e43364f51a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickSetInt </td>
          <td>(</td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a signed integer value to the config tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0a0f85ab12026bb61f6c1741c99955fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_QuickSetString </td>
          <td>(</td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a string value to the config tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the value to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae839eaf925f0498c728ab44f1bdcec66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_RemoveChangeHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a>&#160;</td>
          <td class="paramname"><em>handlerRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove handler function for EVENT 'le_cfg_Change'</p>
<p>This function removes a handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerRef</td><td>Previously registered handler to remove. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aae21ad3f9372ae47880e028981acc0a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_SetBool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a boolean value to the config tree. Only valid during a write transaction.</p>
<p>If the path is empty, the iterator's current node will be set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adb99506c800a2dcaae2c2a7c7cf5e3d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_SetEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears out the node's value. If the node doesn't exist it will be created, and have no value.</p>
<p>If the path is empty, the iterator's current node will be cleared. If the node is a stem then all children will be removed from the tree.</p>
<p>Only valid during a write transaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a918ac92140db2cd6d5254d24f2b0238a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_SetFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a 64-bit floating point value to the config tree. Only valid during a write transaction.</p>
<p>If the path is empty, the iterator's current node will be set.</p>
<dl class="section note"><dt>Note</dt><dd>Floating point values will only be stored up to 6 digits of precision. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b76404cf41ab83d5136ac95e9361146"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_SetInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a signed integer value to the config tree. Only valid during a write transaction.</p>
<p>If the path is empty, the iterator's current node will be set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4a110f59916a8073d39b1cfc1e8cf51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_SetServerDisconnectHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#aff2b4ba4a4eacc417e0e2b9fd32bdf12">le_cfg_DisconnectHandler_t</a>&#160;</td>
          <td class="paramname"><em>disconnectHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>contextPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set handler called when server disconnection is detected.</p>
<p>When a server connection is lost, call this handler then exit with LE_FATAL. If a program wants to continue without exiting, it should call longjmp() from inside the handler. </p>

</div>
</div>
<a class="anchor" id="a8f31a75f9140825c7ba9b8c0922dcfc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_cfg_SetString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#a646829934bb23a878e19ade2c3e01eba">le_cfg_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *<a class="el" href="le__basics_8h.html#a760a74eea43e0fd498db39b33bc9396d">LE_NONNULL</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a string value to the config tree. Only valid during a write transaction.</p>
<p>If the path is empty, the iterator's current node will be set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Iterator to use as a basis for the transaction. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>Path to the target node. Can be an absolute path, or a path relative from the iterator's current position. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>Value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae95903ceaf3bf1037f9ea5712d74d490"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_cfg_TryConnectService </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Try to connect the current client thread to the service providing this API. Return with an error if the service is not available.</p>
<p>For each thread that wants to use this API, either ConnectService or TryConnectService must be called before any other functions in this API. Normally, ConnectService is automatically called for the main thread, but not for any other thread. For details, see <a class="el" href="apiFilesC.html#apiFilesC_client">Client-specific Functions</a>.</p>
<p>This function is created automatically.</p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>LE_OK if the client connected successfully to the service.</li>
<li>LE_UNAVAILABLE if the server is not currently offering the service to which the client is bound.</li>
<li>LE_NOT_PERMITTED if the client interface is not bound to any service (doesn't have a binding).</li>
<li>LE_COMM_ERROR if the Service Directory cannot be reached. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
