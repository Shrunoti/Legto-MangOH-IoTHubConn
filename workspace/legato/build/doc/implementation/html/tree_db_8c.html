<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: framework/daemons/linux/configTree/treeDb.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tree_db_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">treeDb.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="legato_8h_source.html">legato.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="limit_8h_source.html">limit.h</a>&quot;</code><br />
<code>#include &quot;interfaces.h&quot;</code><br />
<code>#include &quot;<a class="el" href="dynamic_string_8h_source.html">dynamicString.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tree_path_8h_source.html">treePath.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tree_db_8h_source.html">treeDb.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tree_user_8h_source.html">treeUser.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="node_iterator_8h_source.html">nodeIterator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="sys_paths_8h_source.html">sysPaths.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_registration__t.html">Registration_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_handler__t.html">Handler_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_clean_up_context__t.html">CleanUpContext_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_node__t.html">Node_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree__t.html">Tree_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1d2150932161254475a1d66bb3f4b283"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a1d2150932161254475a1d66bb3f4b283">CFG_MAX_PATH_SIZE</a>&#160;&#160;&#160;<a class="el" href="le__cfg__interface_8h.html#aea00ee500b7beccc4bf46ab637190a55">LE_CFG_STR_LEN_BYTES</a></td></tr>
<tr class="memdesc:a1d2150932161254475a1d66bb3f4b283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum path size for the config tree.  <a href="#a1d2150932161254475a1d66bb3f4b283">More...</a><br /></td></tr>
<tr class="separator:a1d2150932161254475a1d66bb3f4b283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac040648019c6f080627383473d8cbf90"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ac040648019c6f080627383473d8cbf90">SMALL_STR</a>&#160;&#160;&#160;24</td></tr>
<tr class="memdesc:ac040648019c6f080627383473d8cbf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum size (in bytes) of a "small" string, including the null terminator.  <a href="#ac040648019c6f080627383473d8cbf90">More...</a><br /></td></tr>
<tr class="separator:ac040648019c6f080627383473d8cbf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d27fb36c713eeb0d0f162cc66d3bc4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a33d27fb36c713eeb0d0f162cc66d3bc4">CFG_NODE_POOL_NAME</a>&#160;&#160;&#160;&quot;nodePool&quot;</td></tr>
<tr class="memdesc:a33d27fb36c713eeb0d0f162cc66d3bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the memory pool that handles tree nodes.  <a href="#a33d27fb36c713eeb0d0f162cc66d3bc4">More...</a><br /></td></tr>
<tr class="separator:a33d27fb36c713eeb0d0f162cc66d3bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a1663e198f24eacafc9993a6348b83"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a77a1663e198f24eacafc9993a6348b83">CFG_TREE_COLLECTION_NAME</a>&#160;&#160;&#160;&quot;treeCollection&quot;</td></tr>
<tr class="memdesc:a77a1663e198f24eacafc9993a6348b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the tree collection object.  <a href="#a77a1663e198f24eacafc9993a6348b83">More...</a><br /></td></tr>
<tr class="separator:a77a1663e198f24eacafc9993a6348b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e9b111a0029eb831cc0dd63df38694"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a18e9b111a0029eb831cc0dd63df38694">CFG_TREE_POOL_NAME</a>&#160;&#160;&#160;&quot;treePool&quot;</td></tr>
<tr class="memdesc:a18e9b111a0029eb831cc0dd63df38694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the tree object memory pool.  <a href="#a18e9b111a0029eb831cc0dd63df38694">More...</a><br /></td></tr>
<tr class="separator:a18e9b111a0029eb831cc0dd63df38694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb377e7f9fa38575a27525554eafb96"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#acfb377e7f9fa38575a27525554eafb96">CFG_HANDLER_REG_NAME</a>&#160;&#160;&#160;&quot;handlerLookupMap&quot;</td></tr>
<tr class="memdesc:acfb377e7f9fa38575a27525554eafb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the registration hash map.  <a href="#acfb377e7f9fa38575a27525554eafb96">More...</a><br /></td></tr>
<tr class="separator:acfb377e7f9fa38575a27525554eafb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad0f3709694950515a1da680f9d1f48"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a9ad0f3709694950515a1da680f9d1f48">CFG_HANDLER_POOL_NAME</a>&#160;&#160;&#160;&quot;HandlerPool&quot;</td></tr>
<tr class="memdesc:a9ad0f3709694950515a1da680f9d1f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the handler pool.  <a href="#a9ad0f3709694950515a1da680f9d1f48">More...</a><br /></td></tr>
<tr class="separator:a9ad0f3709694950515a1da680f9d1f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48ec5d2934db9009585b9b0148776d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ad48ec5d2934db9009585b9b0148776d3">CFG_HANDLER_REF_MAP</a>&#160;&#160;&#160;&quot;HandlerSafeRefMap&quot;</td></tr>
<tr class="memdesc:ad48ec5d2934db9009585b9b0148776d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the safe ref map.  <a href="#ad48ec5d2934db9009585b9b0148776d3">More...</a><br /></td></tr>
<tr class="separator:ad48ec5d2934db9009585b9b0148776d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18eb78d729670dab82f263c5c7217b36"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a18eb78d729670dab82f263c5c7217b36">CFG_REGISTRATION_POOL_NAME</a>&#160;&#160;&#160;&quot;RegistrationPool&quot;</td></tr>
<tr class="memdesc:a18eb78d729670dab82f263c5c7217b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the registration pool.  <a href="#a18eb78d729670dab82f263c5c7217b36">More...</a><br /></td></tr>
<tr class="separator:a18eb78d729670dab82f263c5c7217b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ab361d964c747f936e1145315ca16ea47"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ab361d964c747f936e1145315ca16ea47">NodeFlags_t</a> { <a class="el" href="tree_db_8c.html#ab361d964c747f936e1145315ca16ea47a5a41b78319ba3ec9233f6a96c7bdcbef">NODE_FLAGS_UNSET</a> = 0x0, 
<a class="el" href="tree_db_8c.html#ab361d964c747f936e1145315ca16ea47aaf5972f4b9ce3378b2bd330f07007eb1">NODE_IS_SHADOW</a> = 0x1, 
<a class="el" href="tree_db_8c.html#ab361d964c747f936e1145315ca16ea47ac486114fd93d00a5e9728bb9a9495a61">NODE_IS_MODIFIED</a> = 0x2, 
<a class="el" href="tree_db_8c.html#ab361d964c747f936e1145315ca16ea47afce87e648111574c9c5a58a77f0d1679">NODE_IS_DELETED</a> = 0x4
 }</td></tr>
<tr class="separator:ab361d964c747f936e1145315ca16ea47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf84b8f73da30c0f59581856a399081c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#abf84b8f73da30c0f59581856a399081c">TokenType_t</a> { <br />
&#160;&#160;<a class="el" href="tree_db_8c.html#abf84b8f73da30c0f59581856a399081ca0ec791991afec319e84f7623f12798d1">TT_EMPTY_VALUE</a>, 
<a class="el" href="tree_db_8c.html#abf84b8f73da30c0f59581856a399081ca43c8c77641c4545ce7d002bca8aae76d">TT_BOOL_VALUE</a>, 
<a class="el" href="tree_db_8c.html#abf84b8f73da30c0f59581856a399081ca746a1982344999c3304b7d183d840904">TT_INT_VALUE</a>, 
<a class="el" href="tree_db_8c.html#abf84b8f73da30c0f59581856a399081ca3e9ac347a8d588c04ba93a9f47594a53">TT_FLOAT_VALUE</a>, 
<br />
&#160;&#160;<a class="el" href="tree_db_8c.html#abf84b8f73da30c0f59581856a399081cadbf70b317814f19b46998b1573e3fcf6">TT_STRING_VALUE</a>, 
<a class="el" href="tree_db_8c.html#abf84b8f73da30c0f59581856a399081ca0259fd42762a0ea0af0348a0775841cc">TT_OPEN_GROUP</a>, 
<a class="el" href="tree_db_8c.html#abf84b8f73da30c0f59581856a399081cab0d2c0ea27c3f0d34f50b986a6776a44">TT_CLOSE_GROUP</a>
<br />
 }</td></tr>
<tr class="separator:abf84b8f73da30c0f59581856a399081c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad845f815b0be9dec5ff1c5c5d8b926cf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ad845f815b0be9dec5ff1c5c5d8b926cf">ClearFlags</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:ad845f815b0be9dec5ff1c5c5d8b926cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0bbdf06dbb42f80fd6b25a87338203"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a9d0bbdf06dbb42f80fd6b25a87338203">IsShadow</a> (const <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a9d0bbdf06dbb42f80fd6b25a87338203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5210465652e8ed342b1fcefdc640915c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a5210465652e8ed342b1fcefdc640915c">SetShadowFlag</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a5210465652e8ed342b1fcefdc640915c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c40e5a2d264e327a1c126731557f186"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a9c40e5a2d264e327a1c126731557f186">IsModified</a> (const <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a9c40e5a2d264e327a1c126731557f186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bdd31fb708825c72d358a134d75863"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#af1bdd31fb708825c72d358a134d75863">SetModifiedFlag</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:af1bdd31fb708825c72d358a134d75863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abfd033d4acf015aa377cd52459f98e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a1abfd033d4acf015aa377cd52459f98e">ClearModifiedFlag</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a1abfd033d4acf015aa377cd52459f98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bd35183bc80e5c8cef037b8269d8c6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a23bd35183bc80e5c8cef037b8269d8c6">IsDeleted</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a23bd35183bc80e5c8cef037b8269d8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2cd1127af464adfdbc3df22611af2a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a5a2cd1127af464adfdbc3df22611af2a">SetDeletedFlag</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a5a2cd1127af464adfdbc3df22611af2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525bd7e40c31aa04929518cf9c80a6be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a525bd7e40c31aa04929518cf9c80a6be">ClearDeletedFlag</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a525bd7e40c31aa04929518cf9c80a6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a04f6edef8e5c2f156f1ae7911474fb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a6a04f6edef8e5c2f156f1ae7911474fb">NewNode</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a6a04f6edef8e5c2f156f1ae7911474fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27482a2ae9a1fb3c7b7ec9a695d96bb9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a27482a2ae9a1fb3c7b7ec9a695d96bb9">NodeDestructor</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *objectPtr)</td></tr>
<tr class="separator:a27482a2ae9a1fb3c7b7ec9a695d96bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c2aebdfec6cac5067b62462d10734d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a26c2aebdfec6cac5067b62462d10734d">NewShadowNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a26c2aebdfec6cac5067b62462d10734d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd9220bcfae40718c0816015efa2534"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a7fd9220bcfae40718c0816015efa2534">NewChildNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a7fd9220bcfae40718c0816015efa2534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82a0474fb23163257867d1da54b98e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ab82a0474fb23163257867d1da54b98e4">ShadowChildren</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> shadowParentRef)</td></tr>
<tr class="separator:ab82a0474fb23163257867d1da54b98e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9366048e13281055356da484455e0e6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a9366048e13281055356da484455e0e6b">GetRootParentNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a9366048e13281055356da484455e0e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2668e7f84734219b4dc2ea2d68bdc60"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#af2668e7f84734219b4dc2ea2d68bdc60">GetNamedChild</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, const char *nameRef)</td></tr>
<tr class="separator:af2668e7f84734219b4dc2ea2d68bdc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293eb0a99331851f95a0a365f4b21a20"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a293eb0a99331851f95a0a365f4b21a20">CreateNamedChild</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, const char *nameRef)</td></tr>
<tr class="separator:a293eb0a99331851f95a0a365f4b21a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572c67f3e42f63987ee79fdd000236bd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a572c67f3e42f63987ee79fdd000236bd">NodeExists</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> parentRef, const char *namePtr)</td></tr>
<tr class="separator:a572c67f3e42f63987ee79fdd000236bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad64c3592e30b0863e6bb11112445504"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#aad64c3592e30b0863e6bb11112445504">IsStringType</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:aad64c3592e30b0863e6bb11112445504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d60e38003fbe7112a221acabb00eb7d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a1d60e38003fbe7112a221acabb00eb7d">PropagateValue</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a1d60e38003fbe7112a221acabb00eb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212568aa9a31f85f77965d325dbf9f0f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a212568aa9a31f85f77965d325dbf9f0f">MergeNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a212568aa9a31f85f77965d325dbf9f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc3deaa866d7651cdaa1af4a32684e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#acdc3deaa866d7651cdaa1af4a32684e8">TriggerCallbacks</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> pathRef)</td></tr>
<tr class="separator:acdc3deaa866d7651cdaa1af4a32684e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039a361f670ec53e5460be4c723e9497"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a039a361f670ec53e5460be4c723e9497">FireTriggeredCallbacks</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a039a361f670ec53e5460be4c723e9497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b0026bf10d6a10914b6de8153583d6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a81b0026bf10d6a10914b6de8153583d6">WasRenamed</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a81b0026bf10d6a10914b6de8153583d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a23d7113d59c99551b9fe51510fc4d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a51a23d7113d59c99551b9fe51510fc4d">OriginalToBeCleared</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a51a23d7113d59c99551b9fe51510fc4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660316db535f70efab92e076beb7a41c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a660316db535f70efab92e076beb7a41c">AppendNodeName</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> pathRef, <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a660316db535f70efab92e076beb7a41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20acfad30e9881702ba88f583b9219f9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a20acfad30e9881702ba88f583b9219f9">CreateBasePath</a> (const char *treeNamePtr)</td></tr>
<tr class="separator:a20acfad30e9881702ba88f583b9219f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6cbc66756117aa48c7a344625a3fb35"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#aa6cbc66756117aa48c7a344625a3fb35">GeneratePath</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> pathRef, <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:aa6cbc66756117aa48c7a344625a3fb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a936d8d289347caeb52062f7422d173"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a7a936d8d289347caeb52062f7422d173">FireAllChildren</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> pathRef, <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a7a936d8d289347caeb52062f7422d173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e359e2e423db3c14ff5c5a1c5fac741"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a0e359e2e423db3c14ff5c5a1c5fac741">FireLostChildren</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> pathRef, <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> shadowNodeRef)</td></tr>
<tr class="separator:a0e359e2e423db3c14ff5c5a1c5fac741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55278f0ec11d9f01659f04b1747ce49b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a55278f0ec11d9f01659f04b1747ce49b">InternalMergeTree</a> (const char *treeNamePtr, <a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> pathRef, <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, bool forceFire)</td></tr>
<tr class="separator:a55278f0ec11d9f01659f04b1747ce49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded268e476a2cbe389a883a6c2e4e840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#aded268e476a2cbe389a883a6c2e4e840">NewTree</a> (const char *treeNameRef, <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> rootNodeRef)</td></tr>
<tr class="separator:aded268e476a2cbe389a883a6c2e4e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1f95f730790f77ca22c4d02772f240"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a2d1f95f730790f77ca22c4d02772f240">TreeDestructor</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *objectPtr)</td></tr>
<tr class="separator:a2d1f95f730790f77ca22c4d02772f240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef080f13a32aa7b1c03ae5ff19f6311"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a2ef080f13a32aa7b1c03ae5ff19f6311">GetTreePath</a> (const char *treeNameRef, int revisionId, char *pathBuffer, size_t pathSize)</td></tr>
<tr class="separator:a2ef080f13a32aa7b1c03ae5ff19f6311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c38e418f1c39a5fd6434799356ae1e5"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a8c38e418f1c39a5fd6434799356ae1e5">TreeFileExists</a> (const char *treeNameRef, int revisionId)</td></tr>
<tr class="separator:a8c38e418f1c39a5fd6434799356ae1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7683048eb46c44f96f9665a7e249f5e3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a7683048eb46c44f96f9665a7e249f5e3">UpdateRevision</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef)</td></tr>
<tr class="separator:a7683048eb46c44f96f9665a7e249f5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed40cb98ef22f2456a89721fdf6a6215"><td class="memItemLeft" align="right" valign="top">static signed char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#aed40cb98ef22f2456a89721fdf6a6215">PeekChar</a> (FILE *<a class="el" href="update_daemon_8c.html#acf1f3d914b42896a64e8683abe22ae7a">filePtr</a>)</td></tr>
<tr class="separator:aed40cb98ef22f2456a89721fdf6a6215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8cf20797f03f5cea044d5ea3b1b91fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ac8cf20797f03f5cea044d5ea3b1b91fe">SkipWhiteSpace</a> (FILE *<a class="el" href="update_daemon_8c.html#acf1f3d914b42896a64e8683abe22ae7a">filePtr</a>)</td></tr>
<tr class="separator:ac8cf20797f03f5cea044d5ea3b1b91fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3c7e2de6f15e1a6369c251ded6ffba"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a0d3c7e2de6f15e1a6369c251ded6ffba">ReadBoolToken</a> (FILE *<a class="el" href="update_daemon_8c.html#acf1f3d914b42896a64e8683abe22ae7a">filePtr</a>, char *stringPtr, size_t stringSize)</td></tr>
<tr class="separator:a0d3c7e2de6f15e1a6369c251ded6ffba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab323bf866b81a03427988a5a0b58a95a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ab323bf866b81a03427988a5a0b58a95a">ReadTextLiteral</a> (FILE *<a class="el" href="update_daemon_8c.html#acf1f3d914b42896a64e8683abe22ae7a">filePtr</a>, char *stringPtr, size_t stringSize, signed char terminal)</td></tr>
<tr class="separator:ab323bf866b81a03427988a5a0b58a95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa898408307fcdc5ded9abf52bd9a7890"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#aa898408307fcdc5ded9abf52bd9a7890">ReadIntToken</a> (FILE *<a class="el" href="update_daemon_8c.html#acf1f3d914b42896a64e8683abe22ae7a">filePtr</a>, char *stringPtr, size_t stringSize)</td></tr>
<tr class="separator:aa898408307fcdc5ded9abf52bd9a7890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae000d45ede8b33a7a1c83c3767c44d89"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ae000d45ede8b33a7a1c83c3767c44d89">ReadFloatToken</a> (FILE *<a class="el" href="update_daemon_8c.html#acf1f3d914b42896a64e8683abe22ae7a">filePtr</a>, char *stringPtr, size_t stringSize)</td></tr>
<tr class="separator:ae000d45ede8b33a7a1c83c3767c44d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab583482f47731bbf45223f773b1b4a89"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ab583482f47731bbf45223f773b1b4a89">ReadStringToken</a> (FILE *<a class="el" href="update_daemon_8c.html#acf1f3d914b42896a64e8683abe22ae7a">filePtr</a>, char *stringPtr, size_t stringSize)</td></tr>
<tr class="separator:ab583482f47731bbf45223f773b1b4a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe34d54cf948766c8f7757c6430f993"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#aafe34d54cf948766c8f7757c6430f993">ReadToken</a> (FILE *<a class="el" href="update_daemon_8c.html#acf1f3d914b42896a64e8683abe22ae7a">filePtr</a>, char *stringPtr, size_t stringSize, <a class="el" href="tree_db_8c.html#abf84b8f73da30c0f59581856a399081c">TokenType_t</a> *typePtr)</td></tr>
<tr class="separator:aafe34d54cf948766c8f7757c6430f993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1c4f507613c9fb29ce3d678cb8de32"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a6f1c4f507613c9fb29ce3d678cb8de32">WriteFile</a> (FILE *<a class="el" href="update_daemon_8c.html#acf1f3d914b42896a64e8683abe22ae7a">filePtr</a>, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *dataPtr, size_t dataSize)</td></tr>
<tr class="separator:a6f1c4f507613c9fb29ce3d678cb8de32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dbe2898ee7a0f2f0e6cb6b415b46483"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a0dbe2898ee7a0f2f0e6cb6b415b46483">WriteStringValue</a> (FILE *<a class="el" href="update_daemon_8c.html#acf1f3d914b42896a64e8683abe22ae7a">filePtr</a>, char startChar, char endChar, const char *stringPtr)</td></tr>
<tr class="separator:a0dbe2898ee7a0f2f0e6cb6b415b46483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec2191abb48e0af3b12ba93487a5d2b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a5ec2191abb48e0af3b12ba93487a5d2b">InternalReadNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, FILE *<a class="el" href="update_daemon_8c.html#acf1f3d914b42896a64e8683abe22ae7a">filePtr</a>, size_t pathLen)</td></tr>
<tr class="separator:a5ec2191abb48e0af3b12ba93487a5d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0b7b3e24537ff117cb74ed6c99de6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a6e0b7b3e24537ff117cb74ed6c99de6b">InternalWriteNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, FILE *<a class="el" href="update_daemon_8c.html#acf1f3d914b42896a64e8683abe22ae7a">filePtr</a>)</td></tr>
<tr class="separator:a6e0b7b3e24537ff117cb74ed6c99de6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c650f533aa69eb0cf6554a83fe10639"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a2c650f533aa69eb0cf6554a83fe10639">ComputePathLength</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a2c650f533aa69eb0cf6554a83fe10639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b055aad19c7a20efbeee5ec870609dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a3b055aad19c7a20efbeee5ec870609dc">IncrementRevision</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef)</td></tr>
<tr class="separator:a3b055aad19c7a20efbeee5ec870609dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1510933e7795b1e4feb64a10c9910afc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a1510933e7795b1e4feb64a10c9910afc">LoadTree</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef)</td></tr>
<tr class="separator:a1510933e7795b1e4feb64a10c9910afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b737a2655a66139d953f3a865064c7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a61b737a2655a66139d953f3a865064c7">RemoveHandler</a> (<a class="el" href="struct_registration__t.html">Registration_t</a> *registrationPtr, <a class="el" href="struct_handler__t.html">Handler_t</a> *handlerPtr)</td></tr>
<tr class="separator:a61b737a2655a66139d953f3a865064c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aad69f300ed59722d6c9de0e38ed1d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a90aad69f300ed59722d6c9de0e38ed1d">OnHandlerRegistrationCleanup</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *valuePtr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *contextPtr)</td></tr>
<tr class="separator:a90aad69f300ed59722d6c9de0e38ed1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd154e0b3394d969c274c0cec6b1379"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a2dd154e0b3394d969c274c0cec6b1379">DeleteTreeFile</a> (const char *filePathPtr)</td></tr>
<tr class="separator:a2dd154e0b3394d969c274c0cec6b1379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84358cd16cfcbc5a010e4969c514c13f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a84358cd16cfcbc5a010e4969c514c13f">GetPathBaseNodeRef</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, <a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> nodePathRef)</td></tr>
<tr class="separator:a84358cd16cfcbc5a010e4969c514c13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4326887ef33aa8d74f5acb2d9d9a87"><td class="memItemLeft" align="right" valign="top">static FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a6f4326887ef33aa8d74f5acb2d9d9a87">OpenFilePtr</a> (int descriptor, const char *mode)</td></tr>
<tr class="separator:a6f4326887ef33aa8d74f5acb2d9d9a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53b61f46e43e5f9271218114b72ed93"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ab53b61f46e43e5f9271218114b72ed93">CloseFilePtr</a> (FILE *<a class="el" href="update_daemon_8c.html#acf1f3d914b42896a64e8683abe22ae7a">filePtr</a>)</td></tr>
<tr class="separator:ab53b61f46e43e5f9271218114b72ed93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f89d64e5eebcd89a5f82f6062df6a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a78f89d64e5eebcd89a5f82f6062df6a2">tdb_Init</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a78f89d64e5eebcd89a5f82f6062df6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306a040d44fb19e180cc38a02786c3f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a306a040d44fb19e180cc38a02786c3f0">tdb_GetTree</a> (const char *treeNamePtr)</td></tr>
<tr class="separator:a306a040d44fb19e180cc38a02786c3f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b082fee4c950679508fcd8a537f2d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ab3b082fee4c950679508fcd8a537f2d6">tdb_DeleteTree</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef)</td></tr>
<tr class="separator:ab3b082fee4c950679508fcd8a537f2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d039df65d1ed148f4039bb35cb54f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ab9d039df65d1ed148f4039bb35cb54f1">tdb_GetTreeIterRef</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:ab9d039df65d1ed148f4039bb35cb54f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9ac5770a561d89230e2e332748b65b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a3a9ac5770a561d89230e2e332748b65b">tdb_ShadowTree</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef)</td></tr>
<tr class="separator:a3a9ac5770a561d89230e2e332748b65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abdd9449cafce1ed0771255ca879f1a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a3abdd9449cafce1ed0771255ca879f1a">tdb_GetTreeName</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef)</td></tr>
<tr class="separator:a3abdd9449cafce1ed0771255ca879f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4874d17afa8e018317e13a3958c54ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ab4874d17afa8e018317e13a3958c54ec">tdb_GetRootNode</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef)</td></tr>
<tr class="separator:ab4874d17afa8e018317e13a3958c54ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062c5719ea223afa2e5988ed52ed45f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="node_iterator_8h.html#a4e97d8e792de584da776be7c732785ba">ni_IteratorRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a062c5719ea223afa2e5988ed52ed45f6">tdb_GetActiveWriteIter</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef)</td></tr>
<tr class="separator:a062c5719ea223afa2e5988ed52ed45f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410d806b05efffbd5ddeecd570eb903a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a410d806b05efffbd5ddeecd570eb903a">tdb_HasActiveReaders</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef)</td></tr>
<tr class="separator:a410d806b05efffbd5ddeecd570eb903a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9480076d6f6b9e81a5f7ba23b11c8d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a9480076d6f6b9e81a5f7ba23b11c8d1e">tdb_RegisterIterator</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef, <a class="el" href="node_iterator_8h.html#a4e97d8e792de584da776be7c732785ba">ni_IteratorRef_t</a> iteratorRef)</td></tr>
<tr class="separator:a9480076d6f6b9e81a5f7ba23b11c8d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127e1eb483d42f3a43113f365ac3c549"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a127e1eb483d42f3a43113f365ac3c549">tdb_UnregisterIterator</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef, <a class="el" href="node_iterator_8h.html#a4e97d8e792de584da776be7c732785ba">ni_IteratorRef_t</a> iteratorRef)</td></tr>
<tr class="separator:a127e1eb483d42f3a43113f365ac3c549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14583d573fd4525dd6c484a375b5c6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structle__sls___list__t.html">le_sls_List_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a14583d573fd4525dd6c484a375b5c6b3">tdb_GetRequestQueue</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef)</td></tr>
<tr class="separator:a14583d573fd4525dd6c484a375b5c6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1ce1662066e003f5fbd52b4ee890fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#acb1ce1662066e003f5fbd52b4ee890fb">tdb_MergeTree</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> shadowTreeRef)</td></tr>
<tr class="separator:acb1ce1662066e003f5fbd52b4ee890fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad638fcbdfbfc14902b272c5f478ba2c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ad638fcbdfbfc14902b272c5f478ba2c6">tdb_ReleaseTree</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef)</td></tr>
<tr class="separator:ad638fcbdfbfc14902b272c5f478ba2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92e4a08b6254a34e472cc132b26e8fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ab92e4a08b6254a34e472cc132b26e8fe">tdb_ReadTreeNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, int descriptor)</td></tr>
<tr class="separator:ab92e4a08b6254a34e472cc132b26e8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c12e5b99c4ba79bc62b29017951e16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ad3c12e5b99c4ba79bc62b29017951e16">tdb_WriteTreeNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, int descriptor)</td></tr>
<tr class="separator:ad3c12e5b99c4ba79bc62b29017951e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9d01c31c17ca3b93f05697f3f56c94c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ad9d01c31c17ca3b93f05697f3f56c94c">tdb_GetNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> baseNodeRef, <a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> nodePathRef)</td></tr>
<tr class="separator:ad9d01c31c17ca3b93f05697f3f56c94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517454cc3b7167ed66d95627f1f5c572"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a517454cc3b7167ed66d95627f1f5c572">tdb_CreateNodePath</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> baseNodeRef, <a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> nodePathRef)</td></tr>
<tr class="separator:a517454cc3b7167ed66d95627f1f5c572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714b199b2967bc9eaff3a0ec15b3e625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a714b199b2967bc9eaff3a0ec15b3e625">tdb_EnsureExists</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a714b199b2967bc9eaff3a0ec15b3e625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7a3eb915700198471d87e51f706633"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#aec7a3eb915700198471d87e51f706633">tdb_GetNodeName</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, char *stringPtr, size_t maxSize)</td></tr>
<tr class="separator:aec7a3eb915700198471d87e51f706633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1755de1db64ca8422d417a8f200329da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a1755de1db64ca8422d417a8f200329da">tdb_SetNodeName</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, const char *stringPtr)</td></tr>
<tr class="separator:a1755de1db64ca8422d417a8f200329da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247bb725886cd54c13dac1477b14890c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__cfg__interface_8h.html#a29c8480b3310d1235487d7ea96d8b57d">le_cfg_nodeType_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a247bb725886cd54c13dac1477b14890c">tdb_GetNodeType</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a247bb725886cd54c13dac1477b14890c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80659908b38710fbfcf8387fc15e146c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a80659908b38710fbfcf8387fc15e146c">tdb_IsNodeEmpty</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a80659908b38710fbfcf8387fc15e146c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9204da20bf3252cab912e8a3b9b7946e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a9204da20bf3252cab912e8a3b9b7946e">tdb_SetEmpty</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a9204da20bf3252cab912e8a3b9b7946e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59de42b89edac4a0524ba4e45fbd720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ad59de42b89edac4a0524ba4e45fbd720">tdb_DeleteNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:ad59de42b89edac4a0524ba4e45fbd720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a04b805a0c8fcac19fb6df001f773b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a10a04b805a0c8fcac19fb6df001f773b">tdb_GetNodeParent</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a10a04b805a0c8fcac19fb6df001f773b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2172344c2e0ee9bfb4d0e9da4ed7bbe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a2172344c2e0ee9bfb4d0e9da4ed7bbe4">tdb_GetFirstChildNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a2172344c2e0ee9bfb4d0e9da4ed7bbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9332440dde7b18f8fbbfa0c056adb57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#aa9332440dde7b18f8fbbfa0c056adb57">tdb_GetNextSiblingNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:aa9332440dde7b18f8fbbfa0c056adb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c9b668274155fb0610c14148235de2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a57c9b668274155fb0610c14148235de2">tdb_GetFirstActiveChildNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:a57c9b668274155fb0610c14148235de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5d3d571db2701dbeb5299a96da4755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#acb5d3d571db2701dbeb5299a96da4755">tdb_GetNextActiveSiblingNode</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef)</td></tr>
<tr class="separator:acb5d3d571db2701dbeb5299a96da4755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7208f09af1b41c184eeb959d27d03a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a1f7208f09af1b41c184eeb959d27d03a">tdb_GetValueAsString</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, char *stringPtr, size_t maxSize, const char *defaultPtr)</td></tr>
<tr class="separator:a1f7208f09af1b41c184eeb959d27d03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1198d88087cb397af57659bdf739965"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ab1198d88087cb397af57659bdf739965">tdb_SetValueAsString</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, const char *stringPtr)</td></tr>
<tr class="separator:ab1198d88087cb397af57659bdf739965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8e27185c37eb6cc1236108dc6012dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a3c8e27185c37eb6cc1236108dc6012dc">tdb_GetValueAsBool</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, bool defaultValue)</td></tr>
<tr class="separator:a3c8e27185c37eb6cc1236108dc6012dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8b01887c1ff295b20dd2e6ba4590d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a9d8b01887c1ff295b20dd2e6ba4590d9">tdb_SetValueAsBool</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, bool value)</td></tr>
<tr class="separator:a9d8b01887c1ff295b20dd2e6ba4590d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b692bc3916ebd333400c28597ba8a6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a09b692bc3916ebd333400c28597ba8a6">tdb_GetValueAsInt</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, int32_t defaultValue)</td></tr>
<tr class="separator:a09b692bc3916ebd333400c28597ba8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4aa96b7c5ad2c2ca781d84eddf79f19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#aa4aa96b7c5ad2c2ca781d84eddf79f19">tdb_SetValueAsInt</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, int value)</td></tr>
<tr class="separator:aa4aa96b7c5ad2c2ca781d84eddf79f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751199f9adcf50dc9479123722399656"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a751199f9adcf50dc9479123722399656">tdb_GetValueAsFloat</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, double defaultValue)</td></tr>
<tr class="separator:a751199f9adcf50dc9479123722399656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4392c9e1c636c45a7d2b7615e1ff9aa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a4392c9e1c636c45a7d2b7615e1ff9aa4">tdb_SetValueAsFloat</a> (<a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> nodeRef, double value)</td></tr>
<tr class="separator:a4392c9e1c636c45a7d2b7615e1ff9aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8c87a4a71a798a14c370b9e7584acd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a2f8c87a4a71a798a14c370b9e7584acd">tdb_AddChangeHandler</a> (<a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> treeRef, <a class="el" href="le__messaging_8h.html#aebfc01e15b430a5b4f3038a5bd518904">le_msg_SessionRef_t</a> <a class="el" href="log_tool_8c.html#a0ba04d68f0faec00ca0db1c014f248be">sessionRef</a>, const char *pathPtr, <a class="el" href="le__cfg__interface_8h.html#ac9b4508a0faa6a5d91a4bace0b8976c0">le_cfg_ChangeHandlerFunc_t</a> handlerPtr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *contextPtr)</td></tr>
<tr class="separator:a2f8c87a4a71a798a14c370b9e7584acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3094c1396b8ecb809128aba4b33cc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a0e3094c1396b8ecb809128aba4b33cc2">tdb_RemoveChangeHandler</a> (<a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a> handlerRef, <a class="el" href="le__messaging_8h.html#aebfc01e15b430a5b4f3038a5bd518904">le_msg_SessionRef_t</a> <a class="el" href="log_tool_8c.html#a0ba04d68f0faec00ca0db1c014f248be">sessionRef</a>)</td></tr>
<tr class="separator:a0e3094c1396b8ecb809128aba4b33cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf4447ad56a556ef9f98d9a63e31461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a7bf4447ad56a556ef9f98d9a63e31461">tdb_CleanUpHandlers</a> (<a class="el" href="le__messaging_8h.html#aebfc01e15b430a5b4f3038a5bd518904">le_msg_SessionRef_t</a> <a class="el" href="log_tool_8c.html#a0ba04d68f0faec00ca0db1c014f248be">sessionRef</a>)</td></tr>
<tr class="separator:a7bf4447ad56a556ef9f98d9a63e31461"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a75e60404be593a1cb3da6b157e99daed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a75e60404be593a1cb3da6b157e99daed">NodePoolRef</a> = NULL</td></tr>
<tr class="memdesc:a75e60404be593a1cb3da6b157e99daed"><td class="mdescLeft">&#160;</td><td class="mdescRight">The memory pool responsible for tree nodes.  <a href="#a75e60404be593a1cb3da6b157e99daed">More...</a><br /></td></tr>
<tr class="separator:a75e60404be593a1cb3da6b157e99daed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a7425deb87e7fef2393d7c0c7f7937"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ae7a7425deb87e7fef2393d7c0c7f7937">TreeCollectionRef</a> = NULL</td></tr>
<tr class="memdesc:ae7a7425deb87e7fef2393d7c0c7f7937"><td class="mdescLeft">&#160;</td><td class="mdescRight">The collection of configuration trees managed by the system.  <a href="#ae7a7425deb87e7fef2393d7c0c7f7937">More...</a><br /></td></tr>
<tr class="separator:ae7a7425deb87e7fef2393d7c0c7f7937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac408daa3e257b1656fee369b70f0ccbf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#ac408daa3e257b1656fee369b70f0ccbf">TreePoolRef</a> = NULL</td></tr>
<tr class="memdesc:ac408daa3e257b1656fee369b70f0ccbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool from which Tree objects are allocated.  <a href="#ac408daa3e257b1656fee369b70f0ccbf">More...</a><br /></td></tr>
<tr class="separator:ac408daa3e257b1656fee369b70f0ccbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a5b1215e0378f31bda019c89e3c66d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a16a5b1215e0378f31bda019c89e3c66d">HandlerRegistrationMap</a> = NULL</td></tr>
<tr class="memdesc:a16a5b1215e0378f31bda019c89e3c66d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash map to keep track of event registrations based on the registered node path.  <a href="#a16a5b1215e0378f31bda019c89e3c66d">More...</a><br /></td></tr>
<tr class="separator:a16a5b1215e0378f31bda019c89e3c66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064d209e4eaa951f501a7ca768d37300"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a064d209e4eaa951f501a7ca768d37300">HandlerPool</a> = NULL</td></tr>
<tr class="memdesc:a064d209e4eaa951f501a7ca768d37300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool for registered change handlers.  <a href="#a064d209e4eaa951f501a7ca768d37300">More...</a><br /></td></tr>
<tr class="separator:a064d209e4eaa951f501a7ca768d37300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4d46a94a2018b6b577b5704c0ac579"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__safe_ref_8h.html#aaf8fb3412fb840cb50366856affaf69b">le_ref_MapRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#adf4d46a94a2018b6b577b5704c0ac579">HandlerSafeRefMap</a> = NULL</td></tr>
<tr class="memdesc:adf4d46a94a2018b6b577b5704c0ac579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe ref map for the change handler objects.  <a href="#adf4d46a94a2018b6b577b5704c0ac579">More...</a><br /></td></tr>
<tr class="separator:adf4d46a94a2018b6b577b5704c0ac579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6449750b904a7aa35f8a0eae7f7d8a22"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tree_db_8c.html#a6449750b904a7aa35f8a0eae7f7d8a22">RegistrationPool</a> = NULL</td></tr>
<tr class="memdesc:a6449750b904a7aa35f8a0eae7f7d8a22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pool to handle the registration objects.  <a href="#a6449750b904a7aa35f8a0eae7f7d8a22">More...</a><br /></td></tr>
<tr class="separator:a6449750b904a7aa35f8a0eae7f7d8a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of the low level tree DB structure. This code also handles the persisting of the tree db to the filesystem.</p>
<p>The tree structure looks like this:</p>
<pre class="fragment">    Shadow Tree ------------+----------+  +------------------------+
                            |          |  |                        |
                            v          v  v                        |
    Tree Collection --*--&gt; Tree --+--&gt; Node --+--&gt; Child List --*--+
                                  |           |
                                  |           +--&gt; Value
                                  |           |
                                  |           +--&gt; Handler List --*--&gt; Handler
                                  |
                                  +--&gt; Request Queue
                                  |
                                  +--&gt; Write Iterator Reference
                                  |
                                  +--&gt; Read Iterator Count</pre> <pre class="fragment">The Tree Collection holds Tree objects. There's one Tree object for each configuration tree.
They are indexed by tree name.

Each Tree object has a single "root" Node.

Each Node can have either a value or a list of child Nodes.

When a write transaction is started for a Tree, the iterator reference for that transaction
is recorded in the Tree object.  When the transaction is committed or cancelled, that reference
is cleared out.

When a read transaction is started for a Tree, the count of read iterators in that Tree is
incremented.  When it ends, the count is decremented.

When client requests are received that cannot be processed immediately, because of the state
of the tree the request is for (e.g., if a write transaction commit request is received while
there are read transactions in progress on the tree), then the request is queued onto the tree's
Request Queue.

&lt;b&gt;Shadow Trees:&lt;/b&gt;

In addition, there's the notion of a "Shadow Tree", which is a tree that contains changes
that have been made to another tree in a write transaction that has not yet been committed.
Each node in a shadow tree is called a "Shadow Node".

When a write transaction is started on a tree, a shadow tree is created for that tree, and
a shadow node is created for the root node.  As a shadow node is traversed (using the normal
tree traversal functions), new shadow nodes are created for any nodes that have been traversed
to and any of their sibling nodes.  When changes are made to a node, the new value is stored
in the shadow node.  When new nodes are added, a new shadow node is created in the shadow
tree.  When nodes are deleted, the shadow node is marked "deleted".

When a write transaction is cancelled, the shadow tree and all its shadow nodes are discarded.

When a write transaction is committed, the shadow tree is traversed, and any changes found
in it are applied to the "original" tree that the shadow tree was shadowing.  This process is
called "merging".

Shadow Trees don't have handlers, request queues, write iterator references or read iterator
counts.

&lt;b&gt;Event Handler Registration:&lt;/b&gt;

The config tree allows clients to register callbacks to be notified if certian sections of a
configuration tree is modified.

The way this works is that a global hash map of registrations is maintained.  With the hash being
generated from the path to the tree and node of interest.  So, if an program was interested in
watching the apps collection in the system tree it would use the path:
</pre><pre class="fragment">system:/apps </pre> <pre class="fragment">For each unique path a registration object is created, and that registration object will hold a
list of event handlers for the node.
</pre><pre class="fragment">    +------------------------+
    | HandlerRegistrationMap |
    +------------------------+
      |
      | Hash of 'system:/apps'  +--------------+
      *------------------------&gt;| Registration |
                                +--------------+
                                    |
                                    |  List of handlers  +---------+
                                    +--------------------| Handler |
                                    |                    +---------+
                                    |                       |
                                    |                       +- Function Pointer
                                    |                       +- Context Pointer
                                    |                       +- Other data...
                                    |
                                    |                    +---------+
                                    +--------------------| Handler |
                                    |                    +---------+
                                    |
                                    .
                                    .
                                    .</pre><p>The system also employs the use of SafeRefs to keep track of each registered handler so that a handler can quickly and easily remove a handler as required.</p>
<p>When a merge occurs each modified node path is checked against the registration map. If there is a registration object for that node each of the registered handlers is invoked.</p>
<p>Handlers are registered in this hash map so that the target node doesn't need to actually exist in order to have a handler registed for it. In fact, a handler will be called when a node is deleted and when it is recreated.</p>
<p>Copyright (C) Sierra Wireless Inc. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a9ad0f3709694950515a1da680f9d1f48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_HANDLER_POOL_NAME&#160;&#160;&#160;&quot;HandlerPool&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the handler pool. </p>

</div>
</div>
<a class="anchor" id="ad48ec5d2934db9009585b9b0148776d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_HANDLER_REF_MAP&#160;&#160;&#160;&quot;HandlerSafeRefMap&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the safe ref map. </p>

</div>
</div>
<a class="anchor" id="acfb377e7f9fa38575a27525554eafb96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_HANDLER_REG_NAME&#160;&#160;&#160;&quot;handlerLookupMap&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the registration hash map. </p>

</div>
</div>
<a class="anchor" id="a1d2150932161254475a1d66bb3f4b283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_MAX_PATH_SIZE&#160;&#160;&#160;<a class="el" href="le__cfg__interface_8h.html#aea00ee500b7beccc4bf46ab637190a55">LE_CFG_STR_LEN_BYTES</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum path size for the config tree. </p>

</div>
</div>
<a class="anchor" id="a33d27fb36c713eeb0d0f162cc66d3bc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_NODE_POOL_NAME&#160;&#160;&#160;&quot;nodePool&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The name of the memory pool that handles tree nodes. </p>

</div>
</div>
<a class="anchor" id="a18eb78d729670dab82f263c5c7217b36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_REGISTRATION_POOL_NAME&#160;&#160;&#160;&quot;RegistrationPool&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the registration pool. </p>

</div>
</div>
<a class="anchor" id="a77a1663e198f24eacafc9993a6348b83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TREE_COLLECTION_NAME&#160;&#160;&#160;&quot;treeCollection&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the tree collection object. </p>

</div>
</div>
<a class="anchor" id="a18e9b111a0029eb831cc0dd63df38694"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CFG_TREE_POOL_NAME&#160;&#160;&#160;&quot;treePool&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the tree object memory pool. </p>

</div>
</div>
<a class="anchor" id="ac040648019c6f080627383473d8cbf90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SMALL_STR&#160;&#160;&#160;24</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum size (in bytes) of a "small" string, including the null terminator. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ab361d964c747f936e1145315ca16ea47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="tree_db_8c.html#ab361d964c747f936e1145315ca16ea47">NodeFlags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags that can be set on a node to allow the code to keep track of the various changes as they're made to the nodes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ab361d964c747f936e1145315ca16ea47a5a41b78319ba3ec9233f6a96c7bdcbef"></a>NODE_FLAGS_UNSET&#160;</td><td class="fielddoc">
<p>No flags have been set. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab361d964c747f936e1145315ca16ea47aaf5972f4b9ce3378b2bd330f07007eb1"></a>NODE_IS_SHADOW&#160;</td><td class="fielddoc">
<p>The node is a shadow for a node in another tree. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab361d964c747f936e1145315ca16ea47ac486114fd93d00a5e9728bb9a9495a61"></a>NODE_IS_MODIFIED&#160;</td><td class="fielddoc">
<p>This node has been modified. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ab361d964c747f936e1145315ca16ea47afce87e648111574c9c5a58a77f0d1679"></a>NODE_IS_DELETED&#160;</td><td class="fielddoc">
<p>This node has been marked as deleted, the actual deletion will take place later. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="abf84b8f73da30c0f59581856a399081c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="tree_db_8c.html#abf84b8f73da30c0f59581856a399081c">TokenType_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Types of lexical tokens that can be found in configuration data files. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="abf84b8f73da30c0f59581856a399081ca0ec791991afec319e84f7623f12798d1"></a>TT_EMPTY_VALUE&#160;</td><td class="fielddoc">
<p>Node without any value. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abf84b8f73da30c0f59581856a399081ca43c8c77641c4545ce7d002bca8aae76d"></a>TT_BOOL_VALUE&#160;</td><td class="fielddoc">
<p>Boolean value. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abf84b8f73da30c0f59581856a399081ca746a1982344999c3304b7d183d840904"></a>TT_INT_VALUE&#160;</td><td class="fielddoc">
<p>Signed integer. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abf84b8f73da30c0f59581856a399081ca3e9ac347a8d588c04ba93a9f47594a53"></a>TT_FLOAT_VALUE&#160;</td><td class="fielddoc">
<p>Floating point number. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abf84b8f73da30c0f59581856a399081cadbf70b317814f19b46998b1573e3fcf6"></a>TT_STRING_VALUE&#160;</td><td class="fielddoc">
<p>UTF-8 text string. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abf84b8f73da30c0f59581856a399081ca0259fd42762a0ea0af0348a0775841cc"></a>TT_OPEN_GROUP&#160;</td><td class="fielddoc">
<p>Start of grouping. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abf84b8f73da30c0f59581856a399081cab0d2c0ea27c3f0d34f50b986a6776a44"></a>TT_CLOSE_GROUP&#160;</td><td class="fielddoc">
<p>End of grouping. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a660316db535f70efab92e076beb7a41c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> AppendNodeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>pathRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append the name of a node onto the end of a path object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathRef</td><td>The path we're appending to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node we're appending. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a525bd7e40c31aa04929518cf9c80a6be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> ClearDeletedFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the deleted flag on a node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad845f815b0be9dec5ff1c5c5d8b926cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> ClearFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear all flags from the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1abfd033d4acf015aa377cd52459f98e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> ClearModifiedFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the modified flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab53b61f46e43e5f9271218114b72ed93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> CloseFilePtr </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Close the file pointer and flush any data left unwritten. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePtr</td><td>The file pointer to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c650f533aa69eb0cf6554a83fe10639"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t ComputePathLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the number of bytes required to store a node path, including seperators and a trailing NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>The amount of bytes required to store the whole path string. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>Compute a path for this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20acfad30e9881702ba88f583b9219f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> CreateBasePath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>treeNamePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new config path for the tree name given.</p>
<dl class="section return"><dt>Returns</dt><dd>A new config path, rooted on the given tree. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeNamePtr</td><td>The tree name to use for the new path object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a293eb0a99331851f95a0a365f4b21a20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> CreateNamedChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nameRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called to create a named child in a nodes child collection. However, this function will only create nodes on shadow trees.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to newly created child node, or NULL if it can not be created. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nameRef</td><td>The name we're searching for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2dd154e0b3394d969c274c0cec6b1379"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> DeleteTreeFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePathPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call this function to delete a tree file from the filesystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filePathPtr</td><td>Path to the tree file in question. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a936d8d289347caeb52062f7422d173"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> FireAllChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>pathRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trigger callbacks for this node and all of it's children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathRef</td><td>Path to the parent of the current node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>Node and any children to merge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e359e2e423db3c14ff5c5a1c5fac741"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> FireLostChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>pathRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>shadowNodeRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check a given shadow node and the original node it's shadowing. If the original has children that will be lost because of a merge, then we need to fire callbacks for those nodes that are about to go away.</p>
<p>The algorithm employed by this function is as follows: </p><pre class="fragment">1. Check the original node for the given shadow node.  If it exists and is a stem node,
   mark all of the children as deleted.  (This is done with the expectation that the
   original tree does not have nodes with the deleted flag set.)

2. Go through the shadow collection, and any shadow children that have links to the original
   nodes, clear the deleted flag.  These nodes are still considered "live."

3. Travers the original children one more time.  For any node that is still marked as
   deleted we queue up an event handler.  As this node has been removed from the colection
   and will be removed as part of the final merge.  The delete flag is also cleared at this
   step to ensure that there are no external side effects.</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathRef</td><td>Path to the parent of the current node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shadowNodeRef</td><td>Node and any children to merge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a039a361f670ec53e5460be4c723e9497"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> FireTriggeredCallbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Go through all of the registered event callbacks, and fire the call backs for each of the registrations that has been makred as triggered.</p>
<p>Once this is done, the triggered flag is cleared for next time. </p>

</div>
</div>
<a class="anchor" id="aa6cbc66756117aa48c7a344625a3fb35"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> GeneratePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>pathRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a config path to the given node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathRef</td><td>The path object we're updating. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node we're creating a path for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af2668e7f84734219b4dc2ea2d68bdc60"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> GetNamedChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nameRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called to look for a named child in a given node's child collection.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the found child node, or NULL if a node was not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nameRef</td><td>The name we're searching for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84358cd16cfcbc5a010e4969c514c13f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> GetPathBaseNodeRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>nodePathRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the root node represented by the path ref.</p>
<p>If the path is an absolute path, then the base node for the reference is the root node of the tree in question.</p>
<p>If the path is a relative path, then the base node of the request is the node given.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the base node of the operation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The base node to start from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodePathRef</td><td>The path we're searching for in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9366048e13281055356da484455e0e6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> GetRootParentNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search up through a node tree until we find the root node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>Find the greatest grand parent of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ef080f13a32aa7b1c03ae5ff19f6311"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> GetTreePath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>treeNameRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>revisionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pathBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pathSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a path to a tree file with the given revision id.</p>
<dl class="section return"><dt>Returns</dt><dd>A stringBuffer backed string containing the full path to the tree file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeNameRef</td><td>The name of the tree we're generating a name for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">revisionId</td><td>Generate a name based on the tree revision. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathBuffer</td><td>Buffer to hold the new path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathSize</td><td>Size of the path buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b055aad19c7a20efbeee5ec870609dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> IncrementRevision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bump up the version id of this tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>Increment the revision of this tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a55278f0ec11d9f01659f04b1747ce49b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool InternalMergeTree </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>treeNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>pathRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceFire</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Recursive function to merge a collection of shadow nodes with the original tree.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the given node or any if it's children have been modified. False if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeNamePtr</td><td>The name of the tree we're merging. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathRef</td><td>Path to the parent of hte current node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>Node and any children to merge. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forceFire</td><td>Should update handlers be fired for this node and all it's children, regardless of wether or not this node has been directly modified? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ec2191abb48e0af3b12ba93487a5d2b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> InternalReadNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pathLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a node value from the given file. If the value is a collection, then read in those nodes too.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the read is successful. LE_FORMAT_ERROR if parse errors are encountered. LE_NOT_FOUND if the end of file is reached. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node we're reading a value for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filePtr</td><td>The file we're reading the value from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathLen</td><td>The length of the path including nodeRef. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6e0b7b3e24537ff117cb74ed6c99de6b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> InternalWriteNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Serialize a tree node and it's children to a file in the filesystem.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the write succeeded, LE_IO_ERROR if the write failed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node being written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filePtr</td><td>The file being written to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23bd35183bc80e5c8cef037b8269d8c6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IsDeleted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Has the node been marked as deleted? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c40e5a2d264e327a1c126731557f186"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IsModified </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check to see if this node has been modified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d0bbdf06dbb42f80fd6b25a87338203"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IsShadow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check to see if this node is in fact a shadow node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad64c3592e30b0863e6bb11112445504"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IsStringType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the given node type and see if it should have a string value.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the given node could hold a string value. False if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1510933e7795b1e4feb64a10c9910afc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> LoadTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to load a configuration tree from a config file. This function will look for the latest valid version of the config file and load that one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>The tree object to load from the filesystem. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a212568aa9a31f85f77965d325dbf9f0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> MergeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge a shadow node with the original it represents. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The shadow node to merge. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fd9220bcfae40718c0816015efa2534"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> NewChildNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new node and insert it into the given node's children collection.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly create node, already inserted into the supplied node's child collection. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to be given with a new child. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a04f6edef8e5c2f156f1ae7911474fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> NewNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate a new node and fill out it's default information.</p>
<dl class="section return"><dt>Returns</dt><dd>The newly created node. </dd></dl>

</div>
</div>
<a class="anchor" id="a26c2aebdfec6cac5067b62462d10734d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> NewShadowNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocate a new node from our pool, and turn it into a shadow of an existing node.</p>
<dl class="section return"><dt>Returns</dt><dd>A new node that shadows the existing node. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to shadow. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aded268e476a2cbe389a883a6c2e4e840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> NewTree </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>treeNameRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>rootNodeRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new tree object and set it to default values.</p>
<dl class="section return"><dt>Returns</dt><dd>A ref to the newly created tree object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeNameRef</td><td>The name of the new tree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rootNodeRef</td><td>The root node of this new tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27482a2ae9a1fb3c7b7ec9a695d96bb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> NodeDestructor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>objectPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The node destructor function. This will take care of freeing a node's string values and any children it may have. Called automaticly by the memory system when a node is released. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">objectPtr</td><td>The generic object to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a572c67f3e42f63987ee79fdd000236bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool NodeExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>parentRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>namePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check to see if a given node exists within a node's child collection.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the given node exists within the parent node's collection. False if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parentRef</td><td>The parent node to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">namePtr</td><td>The name to search for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90aad69f300ed59722d6c9de0e38ed1d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OnHandlerRegistrationCleanup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>valuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>contextPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is called by the hash map ForEach function, which is invoked when a session closed event occurs.</p>
<p>This function takes care of cleaning out orphaned event handlers from the registration objects currently stored in the registration hash map. If a given registration handler is no longer required then the object itself is queued for deletion. It is queued and not deleted in place because the hash map does not support deleting objects in the middle of an iteration.</p>
<dl class="section return"><dt>Returns</dt><dd>True. This function always returns true to indicate that iteration should continue until the end of the hash map. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>The key used by this hash entry. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valuePtr</td><td>The registration object. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td>Context info including the ref for the session that closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f4326887ef33aa8d74f5acb2d9d9a87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FILE* OpenFilePtr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new C style file pointer from the POSIX file descriptor.</p>
<dl class="section return"><dt>Returns</dt><dd>A file pointer that may be read or written if successful. A null pointer otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptor</td><td>The POSIX file descriptor to create a file pointer from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td>The mode to open the file pointer in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51a23d7113d59c99551b9fe51510fc4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool OriginalToBeCleared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the original non-shadow node to see if it will need to be cleared during the merge.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the merge will clear out the original value. False if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The shadow node to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aed40cb98ef22f2456a89721fdf6a6215"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static signed char PeekChar </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Peek into the input stream one character ahead. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePtr</td><td>The file stream to peek into. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1d60e38003fbe7112a221acabb00eb7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> PropagateValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function will copy a string value from an original tree node into a node that has shadowed it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node ref to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d3c7e2de6f15e1a6369c251ded6ffba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ReadBoolToken </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stringPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a boolean literal from the input file.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the literal could be read. LE_FORMAT_ERROR if the literal could not be read. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePtr</td><td>The file we're reading from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stringPtr</td><td>String buffer to hold the token we've read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>How big is the supplied string buffer? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae000d45ede8b33a7a1c83c3767c44d89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> ReadFloatToken </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stringPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a floating point token string from the file.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the string is read from the file. LE_FORMAT_ERROR if the text fails to be read from the file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePtr</td><td>The file we're reading from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stringPtr</td><td>String buffer to hold the token we've read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>How big is the supplied string buffer? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa898408307fcdc5ded9abf52bd9a7890"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> ReadIntToken </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stringPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read an integer token string from the file.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the string is read from the file. LE_FORMAT_ERROR if the text fails to be read from the file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePtr</td><td>The file we're reading from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stringPtr</td><td>String buffer to hold the token we've read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>How big is the supplied string buffer? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab583482f47731bbf45223f773b1b4a89"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> ReadStringToken </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stringPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a string from the config tree file.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the string is read from the file. LE_FORMAT_ERROR if the text fails to be read from the file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePtr</td><td>The file we're reading from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stringPtr</td><td>String buffer to hold the token we've read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>How big is the supplied string buffer? </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab323bf866b81a03427988a5a0b58a95a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> ReadTextLiteral </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stringPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char&#160;</td>
          <td class="paramname"><em>terminal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a textual literal from the input file, the read is terminated successfuly if the terminal character is found.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the string is read from the file. LE_FORMAT_ERROR if the text fails to be read from the file. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePtr</td><td>The file we're reading from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stringPtr</td><td>String buffer to hold the token we've read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>How big is the supplied string buffer? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">terminal</td><td>The terminal character we're searching for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafe34d54cf948766c8f7757c6430f993"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> ReadToken </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stringPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stringSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tree_db_8c.html#abf84b8f73da30c0f59581856a399081c">TokenType_t</a> *&#160;</td>
          <td class="paramname"><em>typePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read a token from the input stream.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if a token could be read. LE_OUT_OF_RANGE if the end of the stream is reached before a token could be finished. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePtr</td><td>The file we're reading from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stringPtr</td><td>String buffer to hold the token we've read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringSize</td><td>How big is the supplied string buffer? </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">typePtr</td><td>The type of token read from the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61b737a2655a66139d953f3a865064c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> RemoveHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_registration__t.html">Registration_t</a> *&#160;</td>
          <td class="paramname"><em>registrationPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_handler__t.html">Handler_t</a> *&#160;</td>
          <td class="paramname"><em>handlerPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the handler object from the given registration object. This function will also free the memory that the handler object had used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">registrationPtr</td><td>The registration object to remove the link from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerPtr</td><td>The handler object we're removing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a2cd1127af464adfdbc3df22611af2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> SetDeletedFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the deleted flag on the node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1bdd31fb708825c72d358a134d75863"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> SetModifiedFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mark the node as modified. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5210465652e8ed342b1fcefdc640915c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> SetShadowFlag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the shadow flag in this node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab82a0474fb23163257867d1da54b98e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> ShadowChildren </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>shadowParentRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called to shadow a node's collection of children. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shadowParentRef</td><td>The node we're shadowing the children of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac8cf20797f03f5cea044d5ea3b1b91fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> SkipWhiteSpace </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Skip any whitespace encountered in the input stream. Stop skipping once we hit a valid token.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the whitespace is skiped and there is still more file to read. LE_OUT_OF_RANGE if the end of the file is hit. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePtr</td><td>The file stream to seek through. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f8c87a4a71a798a14c370b9e7584acd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a> tdb_AddChangeHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__messaging_8h.html#aebfc01e15b430a5b4f3038a5bd518904">le_msg_SessionRef_t</a>&#160;</td>
          <td class="paramname"><em>sessionRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#ac9b4508a0faa6a5d91a4bace0b8976c0">le_cfg_ChangeHandlerFunc_t</a>&#160;</td>
          <td class="paramname"><em>handlerPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>contextPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a handler function to be called when a node at or below a given path changes.</p>
<dl class="section return"><dt>Returns</dt><dd>A new safe ref backed object, or NULL if the creation failed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>The tree to register the handler on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sessionRef</td><td>The session that the request came in on. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Path of the node to watch. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerPtr</td><td>Function to call back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">contextPtr</td><td>Opaque value to pass to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7bf4447ad56a556ef9f98d9a63e31461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_CleanUpHandlers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__messaging_8h.html#aebfc01e15b430a5b4f3038a5bd518904">le_msg_SessionRef_t</a>&#160;</td>
          <td class="paramname"><em>sessionRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean out any event handlers registered on the given session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sessionRef</td><td>The session that's been closed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a517454cc3b7167ed66d95627f1f5c572"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> tdb_CreateNodePath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>baseNodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>nodePathRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Traverse the given path and create nodes as needed.</p>
<dl class="section return"><dt>Returns</dt><dd>The found or newly created node at the end of the given path. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseNodeRef</td><td>The base node to start from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodePathRef</td><td>The path we're creating within the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad59de42b89edac4a0524ba4e45fbd720"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_DeleteNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete a given node from it's tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3b082fee4c950679508fcd8a537f2d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_DeleteTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called to delete the given tree both from memory and from the filesystem.</p>
<p>If the given tree has active iterators on it, then it will only be marked for deletion. After all of the iterators close, the tree will be removed from the system automatically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>The tree object to permanently delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a714b199b2967bc9eaff3a0ec15b3e625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_EnsureExists </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make sure that the given node and any of it's parents are not marked as having been deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>Update this node, and all of it's parentage and make sure none of them are marked for deletion. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a062c5719ea223afa2e5988ed52ed45f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="node_iterator_8h.html#a4e97d8e792de584da776be7c732785ba">ni_IteratorRef_t</a> tdb_GetActiveWriteIter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the write iterator that's active on the current tree.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the write iterator currently active on the tree. NULL if there isn't an iterator on the tree. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>The tree object to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57c9b668274155fb0610c14148235de2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> tdb_GetFirstActiveChildNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like tdb_GetFirstChildNode this will return a child of the given parent node. However, this function will ignore all nodes that are marked as deleted.</p>
<dl class="section return"><dt>Returns</dt><dd>The first not-deleted child node of the given node. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>Get the first child of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2172344c2e0ee9bfb4d0e9da4ed7bbe4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> tdb_GetFirstChildNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called to get the first child node of this node. If this node has no children, then return NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>The first child of the given node. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>Get the first child of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb5d3d571db2701dbeb5299a96da4755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> tdb_GetNextActiveSiblingNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will return the first active, that is not deleted, sibling of the given node.</p>
<dl class="section return"><dt>Returns</dt><dd>The next "live" node in the sibling chain. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node object to iterate from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9332440dde7b18f8fbbfa0c056adb57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> tdb_GetNextSiblingNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the next sibling for a given node.</p>
<dl class="section return"><dt>Returns</dt><dd>The next sibling node for the given node. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node object to iterate from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad9d01c31c17ca3b93f05697f3f56c94c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> tdb_GetNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>baseNodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>nodePathRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a base node and a path, find another node in the tree.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the required node if found, NULL if not. NULL is also returned if the path is eitehr too big to process or if a node name within the path is too large. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">baseNodeRef</td><td>The base node to start from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodePathRef</td><td>The path we're searching for in the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec7a3eb915700198471d87e51f706633"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> tdb_GetNodeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stringPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of a given node.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the name copied successfuly. LE_OVERFLOW if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stringPtr</td><td>Destination buffer to hold the name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSize</td><td>Size of this buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10a04b805a0c8fcac19fb6df001f773b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> tdb_GetNodeParent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the parent of the given node.</p>
<dl class="section return"><dt>Returns</dt><dd>The parent node of the given node. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node object to read the parent object from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a247bb725886cd54c13dac1477b14890c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__cfg__interface_8h.html#a29c8480b3310d1235487d7ea96d8b57d">le_cfg_nodeType_t</a> tdb_GetNodeType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call to read out what kind of value the node object holds.</p>
<dl class="section return"><dt>Returns</dt><dd>A member of the le_cfg_nodeType_t indicating the type of node in question. If the node is NULL or is marked as deleted, then LE_CFG_TYPE_DOESNT_EXIST. Othwerwise if the value is empty or the node is an empty collection LE_CFG_TYPE_EMPTY is returned. The node's recorded type is returned in all other cases. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a14583d573fd4525dd6c484a375b5c6b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structle__sls___list__t.html">le_sls_List_t</a>* tdb_GetRequestQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the list of requests on this tree.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the request queue for this tree. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>The tree object to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4874d17afa8e018317e13a3958c54ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a> tdb_GetRootNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called to get the root node of a tree object.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the root node of a tree. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>The tree object to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a306a040d44fb19e180cc38a02786c3f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> tdb_GetTree </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>treeNamePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the named tree.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the named tree object. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeNamePtr</td><td>The tree to load. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9d039df65d1ed148f4039bb35cb54f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> tdb_GetTreeIterRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called to get the poitner to the tree collection iterator.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the tree collection iterator. </dd></dl>

</div>
</div>
<a class="anchor" id="a3abdd9449cafce1ed0771255ca879f1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* tdb_GetTreeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called to create a new tree that shadows an existing one.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the tree name string. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>The tree object to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c8e27185c37eb6cc1236108dc6012dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tdb_GetValueAsBool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the given node and interpret it as a boolean value.</p>
<dl class="section return"><dt>Returns</dt><dd>The node's value as a 32-bit boolean. If the node doesn't exists or has the wrong type the default value is returned instead. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use in the event that the requested value doesn't exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a751199f9adcf50dc9479123722399656"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double tdb_GetValueAsFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the given node and interpret it as a floating point value.</p>
<dl class="section return"><dt>Returns</dt><dd>The node's value as a 64-bit floating point number. If the value is an int, it is converted. Otherwise, the default value is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to read. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use in the event that the requested value doesn't exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09b692bc3916ebd333400c28597ba8a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t tdb_GetValueAsInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the given node and interpret it as an integer value.</p>
<dl class="section return"><dt>Returns</dt><dd>The node's current value as an int. If the value was originaly a float then it is rounded. If the node doesn't exist or is some other type then the default value is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultValue</td><td>Default value to use in the event that the requested value doesn't exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1f7208f09af1b41c184eeb959d27d03a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> tdb_GetValueAsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>stringPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the nodes string value and copy into the destination buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the value is copied ok. LE_OVERFLOW if the value can not fit in the supplied buffer. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node object to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stringPtr</td><td>Target buffer for the value string. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxSize</td><td>Maximum size the buffer can hold. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">defaultPtr</td><td>Default value to use in the event that the requested value doesn't exist. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a410d806b05efffbd5ddeecd570eb903a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tdb_HasActiveReaders </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call to check for any active read iterator's on the tree.</p>
<dl class="section return"><dt>Returns</dt><dd>True if there are active iterators on the tree, False otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>The tree object to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a78f89d64e5eebcd89a5f82f6062df6a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the tree DB subsystem, and automaticly load the system tree from the filesystem. </p>

</div>
</div>
<a class="anchor" id="a80659908b38710fbfcf8387fc15e146c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tdb_IsNodeEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is the node currently empty?</p>
<dl class="section return"><dt>Returns</dt><dd>If tdb_GetNodeType would return either LE_CFG_TYPE_EMPTY or LE_CFG_TYPE_DOESNT_EXIST then this function will return true. Otherwise this function will return false. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acb1ce1662066e003f5fbd52b4ee890fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_MergeTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>shadowTreeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge a shadow tree into the original tree it was created from. Once the change is merged the updated tree is serialized to the filesystem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shadowTreeRef</td><td>Merge the nodes from this tree into their base tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab92e4a08b6254a34e472cc132b26e8fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tdb_ReadTreeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>descriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a configuration tree node's contents from the file system.</p>
<dl class="section note"><dt>Note</dt><dd>On exit the descriptor's file pointer will be at EOF. If the function fails, then the file pointer will be somewhere in the middle of the file.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the read is successful, or false if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to write the new data to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptor</td><td>The file to read from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9480076d6f6b9e81a5f7ba23b11c8d1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_RegisterIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_iterator_8h.html#a4e97d8e792de584da776be7c732785ba">ni_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register an iterator on the given tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>The tree object to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>The iterator object we're registering. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad638fcbdfbfc14902b272c5f478ba2c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_ReleaseTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call this to realease a tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>The tree to free. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e3094c1396b8ecb809128aba4b33cc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_RemoveChangeHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__cfg__interface_8h.html#ad02e652d8ea74b6e8ebb8125190e5244">le_cfg_ChangeHandlerRef_t</a>&#160;</td>
          <td class="paramname"><em>handlerRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__messaging_8h.html#aebfc01e15b430a5b4f3038a5bd518904">le_msg_SessionRef_t</a>&#160;</td>
          <td class="paramname"><em>sessionRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deregisters a handler function that was registered using <a class="el" href="tree_db_8c.html#a2f8c87a4a71a798a14c370b9e7584acd">tdb_AddChangeHandler()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handlerRef</td><td>Reference returned by <a class="el" href="tree_db_8c.html#a2f8c87a4a71a798a14c370b9e7584acd">tdb_AddChangeHandler()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sessionRef</td><td>The session of the user making this request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9204da20bf3252cab912e8a3b9b7946e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_SetEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear out the data from a node, releasing any children it may have. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to clear. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1755de1db64ca8422d417a8f200329da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> tdb_SetNodeName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>stringPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the name of a given node. But also validate the name as there are certain names that nodes shouldn't have.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the set is successful. LE_FORMAT_ERROR if the name contains illegial characters, or otherwise would not work as a node name. LE_OVERFLOW if the name is too long. LE_DUPLICATE, if there is another node with the new name in the same collection. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringPtr</td><td>New name for the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9d8b01887c1ff295b20dd2e6ba4590d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_SetValueAsBool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overwite a node value as a new boolen value.. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The new value to write to that node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4392c9e1c636c45a7d2b7615e1ff9aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_SetValueAsFloat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overwite a given node's value with a floating point one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write to that node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa4aa96b7c5ad2c2ca781d84eddf79f19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_SetValueAsInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set an integer value to a given node, overwriting the previous value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1198d88087cb397af57659bdf739965"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_SetValueAsString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>stringPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the given node to a string value. If the given node is a stem then all children will be lost. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>The node to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringPtr</td><td>The value to write to the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a9ac5770a561d89230e2e332748b65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a> tdb_ShadowTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called to create a new tree that shadows an existing one.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the new shadow tree. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>The tree to shadow. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a127e1eb483d42f3a43113f365ac3c549"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> tdb_UnregisterIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="node_iterator_8h.html#a4e97d8e792de584da776be7c732785ba">ni_IteratorRef_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a prior iterator registration from a tree object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>The tree object to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>The iterator object we're removing from the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3c12e5b99c4ba79bc62b29017951e16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> tdb_WriteTreeNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>descriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize a tree node and it's children to a file in the filesystem.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the write succeeded, LE_IO_ERROR if the write failed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>Write the contents of this node to a file descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptor</td><td>The file descriptor to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2d1f95f730790f77ca22c4d02772f240"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> TreeDestructor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>objectPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor called when a tree object is to be freed from memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">objectPtr</td><td>The memory object to destruct. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c38e418f1c39a5fd6434799356ae1e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TreeFileExists </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>treeNameRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>revisionId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check to see if a configTree file at the given revision already exists in the filesystem.</p>
<dl class="section note"><dt>Note</dt><dd>If the tree file exists, but is empty, then it is invalid and will be deleted.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if the named file exists, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeNameRef</td><td>Name of the tree to check. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">revisionId</td><td>The revision of the tree to check against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acdc3deaa866d7651cdaa1af4a32684e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> TriggerCallbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>pathRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called to fire any callbacks registered on the given node path. If nothing is registered on the given path, nothing happens. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathRef</td><td>The path to search for callback registrations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7683048eb46c44f96f9665a7e249f5e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> UpdateRevision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#aa4d033a6e03f068d0e99455012b060c3">tdb_TreeRef_t</a>&#160;</td>
          <td class="paramname"><em>treeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the filesystem and get the current "valid" version of the file and update the tree object with that version number.</p>
<p>If there are two files for a given tree, we use the older one. The idea being, if there are two versions of the same file in the filesystem then there was a system failure during a save operation. So we abandon the newer (probably incomplete) file and go with the older file; unless the size of the older file is zero, which can happen if deletion of that file is interrupted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treeRef</td><td>Update the revision for this tree object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a81b0026bf10d6a10914b6de8153583d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool WasRenamed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tree_db_8h.html#a4c1f526addd1a1042694efa439a97801">tdb_NodeRef_t</a>&#160;</td>
          <td class="paramname"><em>nodeRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the given node to see if it was renamed.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the node was renamed within this transaction. False if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeRef</td><td>Check this node to see if it was renamed in this transaction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6f1c4f507613c9fb29ce3d678cb8de32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> WriteFile </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>dataPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write data to the output stream. This function will record any faults to the system log.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the write succeeded, LE_IO_ERROR if the write failed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePtr</td><td>The file being written to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataPtr</td><td>The data being written to the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dataSize</td><td>The amount of data being written. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0dbe2898ee7a0f2f0e6cb6b415b46483"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> WriteStringValue </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>filePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>startChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>endChar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>stringPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a string token to the output stream. This function will write the string and escape all control characters as it does so.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the write succeeded, LE_IO_ERROR if the write failed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePtr</td><td>The file to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startChar</td><td>The delimiter to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endChar</td><td>The closing delimiter to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stringPtr</td><td>The actual string to write. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a064d209e4eaa951f501a7ca768d37300"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a> HandlerPool = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pool for registered change handlers. </p>

</div>
</div>
<a class="anchor" id="a16a5b1215e0378f31bda019c89e3c66d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> HandlerRegistrationMap = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hash map to keep track of event registrations based on the registered node path. </p>

</div>
</div>
<a class="anchor" id="adf4d46a94a2018b6b577b5704c0ac579"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__safe_ref_8h.html#aaf8fb3412fb840cb50366856affaf69b">le_ref_MapRef_t</a> HandlerSafeRefMap = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Safe ref map for the change handler objects. </p>

</div>
</div>
<a class="anchor" id="a75e60404be593a1cb3da6b157e99daed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a> NodePoolRef = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The memory pool responsible for tree nodes. </p>

</div>
</div>
<a class="anchor" id="a6449750b904a7aa35f8a0eae7f7d8a22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a> RegistrationPool = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pool to handle the registration objects. </p>

</div>
</div>
<a class="anchor" id="ae7a7425deb87e7fef2393d7c0c7f7937"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> TreeCollectionRef = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The collection of configuration trees managed by the system. </p>

</div>
</div>
<a class="anchor" id="ac408daa3e257b1656fee369b70f0ccbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a> TreePoolRef = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pool from which Tree objects are allocated. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
