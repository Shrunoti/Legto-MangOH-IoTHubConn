<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: framework/include/le_hashmap.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('le__hashmap_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">le_hashmap.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="le__hashmap_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a88f09b10323839a1a187b2fddab3ba0b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a88f09b10323839a1a187b2fddab3ba0b">LE_HASHMAP_MAKE_HASH</a>(type)</td></tr>
<tr class="separator:a88f09b10323839a1a187b2fddab3ba0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae81c60860dbdb8c59beaf25985e5605a"><td class="memItemLeft" align="right" valign="top">typedef struct le_hashmap *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a></td></tr>
<tr class="separator:ae81c60860dbdb8c59beaf25985e5605a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ab2021261a368add28c1be14f248459"><td class="memItemLeft" align="right" valign="top">typedef struct le_hashmap_It *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a></td></tr>
<tr class="separator:a8ab2021261a368add28c1be14f248459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354b7f0a30dd40266d367351a4b248b7"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a354b7f0a30dd40266d367351a4b248b7">le_hashmap_HashFunc_t</a>) (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyToHashPtr)</td></tr>
<tr class="separator:a354b7f0a30dd40266d367351a4b248b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe15673aeaa2400d3147d62abffee40"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#adfe15673aeaa2400d3147d62abffee40">le_hashmap_EqualsFunc_t</a>) (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *firstKeyPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *secondKeyPtr)</td></tr>
<tr class="separator:adfe15673aeaa2400d3147d62abffee40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae181524ccab8958e1c8fd5855995b1"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#acae181524ccab8958e1c8fd5855995b1">le_hashmap_ForEachHandler_t</a>) (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *valuePtr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *contextPtr)</td></tr>
<tr class="separator:acae181524ccab8958e1c8fd5855995b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ade79896a5b2ceec82c570fe21f7efe3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create</a> (const char *nameStr, size_t capacity, <a class="el" href="le__hashmap_8h.html#a354b7f0a30dd40266d367351a4b248b7">le_hashmap_HashFunc_t</a> hashFunc, <a class="el" href="le__hashmap_8h.html#adfe15673aeaa2400d3147d62abffee40">le_hashmap_EqualsFunc_t</a> equalsFunc)</td></tr>
<tr class="separator:ade79896a5b2ceec82c570fe21f7efe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68759fb8291c487a507eae6d92710fc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a68759fb8291c487a507eae6d92710fc7">le_hashmap_Put</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *valuePtr)</td></tr>
<tr class="separator:a68759fb8291c487a507eae6d92710fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4322a312a2e4b00112022c2cb04eb416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a4322a312a2e4b00112022c2cb04eb416">le_hashmap_Get</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr)</td></tr>
<tr class="separator:a4322a312a2e4b00112022c2cb04eb416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9645e5b363c335e1dd324f536e2b754c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a9645e5b363c335e1dd324f536e2b754c">le_hashmap_GetStoredKey</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr)</td></tr>
<tr class="separator:a9645e5b363c335e1dd324f536e2b754c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64eab4c096da5b66aa54c70ec5d5a776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a64eab4c096da5b66aa54c70ec5d5a776">le_hashmap_Remove</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr)</td></tr>
<tr class="separator:a64eab4c096da5b66aa54c70ec5d5a776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5530fc9656f5e49f891541900bc21f34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a5530fc9656f5e49f891541900bc21f34">le_hashmap_isEmpty</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a5530fc9656f5e49f891541900bc21f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481e3fa6b0fe8319074140a2cb2ae1cc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a481e3fa6b0fe8319074140a2cb2ae1cc">le_hashmap_Size</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a481e3fa6b0fe8319074140a2cb2ae1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42bc33eaed4e6183edfbded3203beb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#af42bc33eaed4e6183edfbded3203beb4">le_hashmap_ContainsKey</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr)</td></tr>
<tr class="separator:af42bc33eaed4e6183edfbded3203beb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e3af23871a2f9e8adffb748111aab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a27e3af23871a2f9e8adffb748111aab2">le_hashmap_RemoveAll</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a27e3af23871a2f9e8adffb748111aab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4b88ce71592392d075e57142edecaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a4b4b88ce71592392d075e57142edecaf">le_hashmap_ForEach</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, <a class="el" href="le__hashmap_8h.html#acae181524ccab8958e1c8fd5855995b1">le_hashmap_ForEachHandler_t</a> forEachFn, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *contextPtr)</td></tr>
<tr class="separator:a4b4b88ce71592392d075e57142edecaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb1d3a3d4c4b1b52a45205ac11a12c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a8fb1d3a3d4c4b1b52a45205ac11a12c1">le_hashmap_GetIterator</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a8fb1d3a3d4c4b1b52a45205ac11a12c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601b7d3e5d92e91e4090d726e5b190ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr class="separator:a601b7d3e5d92e91e4090d726e5b190ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5cdb7a6d36d28699b255814c0d639d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#aad5cdb7a6d36d28699b255814c0d639d">le_hashmap_PrevNode</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr class="separator:aad5cdb7a6d36d28699b255814c0d639d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0e64b3fee37053bba166c8a283f387"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#aea0e64b3fee37053bba166c8a283f387">le_hashmap_GetKey</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr class="separator:aea0e64b3fee37053bba166c8a283f387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4761be6e9bf5a58155296e32c35c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#adf4761be6e9bf5a58155296e32c35c4b">le_hashmap_GetValue</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr class="separator:adf4761be6e9bf5a58155296e32c35c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec5d4c2a49b8d0304efdfd469a1b2a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#aeec5d4c2a49b8d0304efdfd469a1b2a4">le_hashmap_GetFirstNode</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **firstKeyPtr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **firstValuePtr)</td></tr>
<tr class="separator:aeec5d4c2a49b8d0304efdfd469a1b2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a30f4e7da8135ef0274b24a86b7fcb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a6a30f4e7da8135ef0274b24a86b7fcb7">le_hashmap_GetNodeAfter</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **nextKeyPtr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **nextValuePtr)</td></tr>
<tr class="separator:a6a30f4e7da8135ef0274b24a86b7fcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31a0f34a74f765998467fa30096e46b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#ad31a0f34a74f765998467fa30096e46b">le_hashmap_CountCollisions</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:ad31a0f34a74f765998467fa30096e46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff75de814b38d4c4283379acb406b65"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a3ff75de814b38d4c4283379acb406b65">le_hashmap_HashString</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *stringToHashPtr)</td></tr>
<tr class="separator:a3ff75de814b38d4c4283379acb406b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d2b6c0689ece50ce979557029b8483"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a63d2b6c0689ece50ce979557029b8483">le_hashmap_EqualsString</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *firstStringPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *secondStringPtr)</td></tr>
<tr class="separator:a63d2b6c0689ece50ce979557029b8483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcf5d26bec7e15b6ec30fec4701ce03"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a1bcf5d26bec7e15b6ec30fec4701ce03">le_hashmap_HashUInt32</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *intToHashPtr)</td></tr>
<tr class="separator:a1bcf5d26bec7e15b6ec30fec4701ce03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e3edfdbd30d06729486060a75a77c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#ab3e3edfdbd30d06729486060a75a77c7">le_hashmap_EqualsUInt32</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *firstIntPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *secondIntPtr)</td></tr>
<tr class="separator:ab3e3edfdbd30d06729486060a75a77c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12558f1e0eeb68991ffb8f8ad442ce86"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a12558f1e0eeb68991ffb8f8ad442ce86">le_hashmap_HashUInt64</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *intToHashPtr)</td></tr>
<tr class="separator:a12558f1e0eeb68991ffb8f8ad442ce86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7ac9c681fc54fb121d94ee1e6f4c40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a3b7ac9c681fc54fb121d94ee1e6f4c40">le_hashmap_EqualsUInt64</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *firstIntPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *secondIntPtr)</td></tr>
<tr class="separator:a3b7ac9c681fc54fb121d94ee1e6f4c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9fc51c9f65c44f6c78cdaf101ab0e4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a2c9fc51c9f65c44f6c78cdaf101ab0e4">le_hashmap_HashVoidPointer</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *voidToHashPtr)</td></tr>
<tr class="separator:a2c9fc51c9f65c44f6c78cdaf101ab0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecdbbdb5cc0773f0f9946e6e4dec89c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a8ecdbbdb5cc0773f0f9946e6e4dec89c">le_hashmap_EqualsVoidPointer</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *firstVoidPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *secondVoidPtr)</td></tr>
<tr class="separator:a8ecdbbdb5cc0773f0f9946e6e4dec89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853082500b05e57d899606cfc0e34fab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a853082500b05e57d899606cfc0e34fab">le_hashmap_MakeTraceable</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a853082500b05e57d899606cfc0e34fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b30e794df1c866fe39c40c7949eb29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="le__hashmap_8h.html#a10b30e794df1c866fe39c40c7949eb29">le_hashmap_EnableTrace</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a10b30e794df1c866fe39c40c7949eb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Legato <a class="el" href="c_hashmap.html">HashMap API</a> include file.</p>
<p>Copyright (C) Sierra Wireless Inc. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a88f09b10323839a1a187b2fddab3ba0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LE_HASHMAP_MAKE_HASH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keywordtype">size_t</span> Hash##type                                    \</div><div class="line">    (                                                           \</div><div class="line">        const <span class="keywordtype">void</span>* type##Name                                  \</div><div class="line">    )                                                           \</div><div class="line">    {                                                           \</div><div class="line">        size_t byte=0, hash = 0;                                \</div><div class="line">        unsigned <span class="keywordtype">char</span> c;                                        \</div><div class="line">        const <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* ptr = type##Name;                  \</div><div class="line">        for (byte = 0; byte &lt; <span class="keyword">sizeof</span>(type); ++byte)             \</div><div class="line">        {                                                       \</div><div class="line">            c = *ptr++;                                         \</div><div class="line">            hash = c + (hash &lt;&lt; 6) + (hash &lt;&lt; 16) - hash;       \</div><div class="line">        }                                                       \</div><div class="line">        return hash;                                            \</div><div class="line">    }                                                           \</div><div class="line">    static <span class="keywordtype">bool</span> Equals##type                                    \</div><div class="line">    (                                                           \</div><div class="line">        const <span class="keywordtype">void</span>* first##type,                                \</div><div class="line">        const <span class="keywordtype">void</span>* second##type                                \</div><div class="line">    )                                                           \</div><div class="line">    {                                                           \</div><div class="line">        return memcmp(first##type, second##type, <span class="keyword">sizeof</span>(type)) == 0; \</div><div class="line">    }</div></div><!-- fragment --><p>Generic hash for any plain-old-datatype. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="adfe15673aeaa2400d3147d62abffee40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* le_hashmap_EqualsFunc_t) (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *firstKeyPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *secondKeyPtr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prototype for equality functions. The equality function returns true if the the keys point to values are equivalent. The HashMap doesn't know in advance which types are to be stored so this function must be supplied by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstKeyPtr</td><td>Pointer to the first key for comparing. </td></tr>
    <tr><td class="paramname">secondKeyPtr</td><td>Pointer to the second key for comparing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the values are the same, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="acae181524ccab8958e1c8fd5855995b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* le_hashmap_ForEachHandler_t) (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *valuePtr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *contextPtr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prototype for callback functions for the iterator function <a class="el" href="le__hashmap_8h.html#a4b4b88ce71592392d075e57142edecaf">le_hashmap_ForEach()</a>. This function should return true in order to continue iterating, or false to stop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyPtr</td><td>Pointer to the key at the current position in the map </td></tr>
    <tr><td class="paramname">valuePtr</td><td>Pointer to the value associated to this key </td></tr>
    <tr><td class="paramname">contextPtr</td><td>Pointer to the context supplied to <a class="el" href="le__hashmap_8h.html#a4b4b88ce71592392d075e57142edecaf">le_hashmap_ForEach()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true to continue, false to stop </dd></dl>

</div>
</div>
<a class="anchor" id="a354b7f0a30dd40266d367351a4b248b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* le_hashmap_HashFunc_t) (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyToHashPtr)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prototype for hash functions. The hash function must generate a good spread of hashes without consuming lots of processing power.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyToHashPtr</td><td>Pointer to the key which will be hashed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated hash value </dd></dl>

</div>
</div>
<a class="anchor" id="a8ab2021261a368add28c1be14f248459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct le_hashmap_It* <a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reference to a HashMap Iterator. </p>

</div>
</div>
<a class="anchor" id="ae81c60860dbdb8c59beaf25985e5605a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct le_hashmap* <a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reference to a HashMap. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af42bc33eaed4e6183edfbded3203beb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_ContainsKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests if the HashMap contains a particular key.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the key is found, false otherwise.</dd></dl>
<p>Tests if the HashMap contains a particular key</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the key is found, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be searched for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad31a0f34a74f765998467fa30096e46b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t le_hashmap_CountCollisions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counts the total number of collisions in the map. A collision occurs when more than one entry is stored in the map at the same index.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the total collisions in the map.</dd></dl>
<p>Counts the total number of collisions in the map. A collision occurs when more than one entry is stored in the map at the same index.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns The sum of the collisions in the map </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade79896a5b2ceec82c570fe21f7efe3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> le_hashmap_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nameStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a354b7f0a30dd40266d367351a4b248b7">le_hashmap_HashFunc_t</a>&#160;</td>
          <td class="paramname"><em>hashFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#adfe15673aeaa2400d3147d62abffee40">le_hashmap_EqualsFunc_t</a>&#160;</td>
          <td class="paramname"><em>equalsFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a HashMap.</p>
<p>If you create a hashmap with a smaller capacity than you actually use, then the map will continue to work, but performance will degrade the more you put in the map.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the map.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Terminates the process on failure, so no need to check the return value for errors.</dd></dl>
<p>Create a HashMap</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the map.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Terminates the process on failure, so no need to check the return value for errors. </dd></dl>
<p>0.75 load factor. We have more buckets than expected keys as we want to reduce the chance of collisions. 1-1 would assume a perfect hashing function which is rather unlikely. Also, ensure that the capacity is at least 3 which avoids strange issues in the hashing algorithm</p>
<p>The memory pool is required to store entries. We set a default size and expansion size to reduce the number of forced allocations. Initial entries for each hash are actually doubly linked list objects which store where the starting entry is in the pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nameStr</td><td>Name of the HashMap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>Expected capacity of the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashFunc</td><td>The hash function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">equalsFunc</td><td>The equality function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10b30e794df1c866fe39c40c7949eb29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_hashmap_EnableTrace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately enables tracing on a particular hashmap object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63d2b6c0689ece50ce979557029b8483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_EqualsString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>firstStringPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>secondStringPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>String equality function. Can be used as a parameter to <a class="el" href="hashmap_8c.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is a string</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the strings are identical, false otherwise.</dd></dl>
<p>String equality function. This can be used as a paramter to le_hashmap_Create if the key to the table is a string</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the strings are identical, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstStringPtr</td><td>Pointer to the first string for comparing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondStringPtr</td><td>Pointer to the second string for comparing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3e3edfdbd30d06729486060a75a77c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_EqualsUInt32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>firstIntPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>secondIntPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integer equality function. Can be used as a parameter to <a class="el" href="hashmap_8c.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is a uint32_t.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the integers are equal, false otherwise.</dd></dl>
<p>Integer equality function. This can be used as a paramter to le_hashmap_Create if the key to the table is a uint32_t</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the integers are equal, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIntPtr</td><td>Pointer to the first integer for comparing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondIntPtr</td><td>Pointer to the second integer for comparing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b7ac9c681fc54fb121d94ee1e6f4c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_EqualsUInt64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>firstIntPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>secondIntPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Long integer equality function. This can be used as a paramter to le_hashmap_Create if the key to the table is a uint64_t</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the integers are equal, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIntPtr</td><td>Pointer to the first long integer for comparing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondIntPtr</td><td>Pointer to the second long integer for comparing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ecdbbdb5cc0773f0f9946e6e4dec89c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_EqualsVoidPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>firstVoidPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>secondVoidPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer equality function. Can be used as a parameter to <a class="el" href="hashmap_8c.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is an pointer or reference.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the pointers are equal, false otherwise</dd></dl>
<p>Pointer equality function. This can be used as a parameter to <a class="el" href="hashmap_8c.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is an pointer or reference.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the pointers are equal, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstVoidPtr</td><td>First pointer for comparing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondVoidPtr</td><td>PSecond pointer for comparing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b4b88ce71592392d075e57142edecaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_ForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#acae181524ccab8958e1c8fd5855995b1">le_hashmap_ForEachHandler_t</a>&#160;</td>
          <td class="paramname"><em>forEachFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates over the whole map, calling the supplied callback with each key-value pair. If the callback returns false for any key then this function will return.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if all elements were checked; or false if iteration was stopped early </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forEachFn</td><td>Callback function to be called with each pair </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to a context to be supplied to the callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4322a312a2e4b00112022c2cb04eb416"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* le_hashmap_Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a value from a HashMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the value or NULL if the key is not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be retrieved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeec5d4c2a49b8d0304efdfd469a1b2a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_hashmap_GetFirstNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **&#160;</td>
          <td class="paramname"><em>firstKeyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **&#160;</td>
          <td class="paramname"><em>firstValuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the key and value of the first node stored in the hashmap. The hashmap is not sorted so this will simply return the first node stored in the map. There is no guarantee that a subsequent call to this function will return the same pair if new keys have been added to the map. If NULL is passed as the firstValuePointer then only the key will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the first node is returned or LE_NOT_FOUND if the map is empty. LE_BAD_PARAMETER if the key is NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">firstKeyPtr</td><td>Pointer to the first key </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">firstValuePtr</td><td><blockquote class="doxtable">
<p>[out] Pointer to the first key&gt; [out] Pointer to the first value </p>
</blockquote>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fb1d3a3d4c4b1b52a45205ac11a12c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> le_hashmap_GetIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets an iterator for step-by-step iteration over the map. In this mode, the iteration is controlled by the calling function using the <a class="el" href="hashmap_8c.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> function. There is one iterator per map, and calling this function resets the iterator position to the start of the map. The iterator is not ready for data access until <a class="el" href="hashmap_8c.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> has been called at least once.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns A reference to a hashmap iterator which is ready for <a class="el" href="hashmap_8c.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> to be called on it</dd></dl>
<p>Gets an interator for step-by-step iteration over the map. In this mode the iteration is controlled by the calling function using the le_hashmap_NextNode function. There is one iterator per map, and calling this function resets the iterator position to the start of the map.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns A reference to a hashmap iterator which is ready for le_hashmap_NextNode to be called on it </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea0e64b3fee37053bba166c8a283f387"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* le_hashmap_GetKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a pointer to the key where the iterator is currently pointing. If the iterator has just been initialized and <a class="el" href="hashmap_8c.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> has not been called, or if the iterator has been invalidated, this will return NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the current key, or NULL if the iterator has been invalidated or is not ready.</dd></dl>
<p>Retrieves a pointer to the key which the iterator is currently pointing at</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the current key, or NULL if the iterator has been invalidated </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a30f4e7da8135ef0274b24a86b7fcb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_hashmap_GetNodeAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **&#160;</td>
          <td class="paramname"><em>nextKeyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **&#160;</td>
          <td class="paramname"><em>nextValuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the key and value of the node after the passed in key. The hashmap is not sorted so this will simply return the next node stored in the map. There is no guarantee that a subsequent call to this function will return the same pair if new keys have been added to the map. If NULL is passed as the nextValuePtr then only the key will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the next node is returned. If the keyPtr is not found in the map then LE_BAD_PARAMETER is returned. LE_NOT_FOUND is returned if the passed in key is the last one in the map. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be searched for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nextKeyPtr</td><td>Pointer to the first key </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nextValuePtr</td><td><blockquote class="doxtable">
<p>[out] Pointer to the first key&gt; [out] Pointer to the first value </p>
</blockquote>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9645e5b363c335e1dd324f536e2b754c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* le_hashmap_GetStoredKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a stored key from a HashMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the key that was stored in the HashMap by <a class="el" href="le__hashmap_8h.html#a68759fb8291c487a507eae6d92710fc7">le_hashmap_Put()</a> or NULL if the key is not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be retrieved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf4761be6e9bf5a58155296e32c35c4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* le_hashmap_GetValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a pointer to the value where the iterator is currently pointing. If the iterator has just been initialized and <a class="el" href="hashmap_8c.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode()</a> has not been called, or if the iterator has been invalidated, this will return NULL.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the current value, or NULL if the iterator has been invalidated or is not ready.</dd></dl>
<p>Retrieves a pointer to the value which the iterator is currently pointing at</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the current value, or NULL if the iterator has been invalidated </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ff75de814b38d4c4283379acb406b65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t le_hashmap_HashString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>stringToHashPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>String hashing function. Can be used as a parameter to <a class="el" href="hashmap_8c.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is a string.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the string pointed to by stringToHash.</dd></dl>
<p>String hashing function. This can be used as a parameter to le_hashmap_Create if the key to the table is a string</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the string pointed to by stringToHash </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stringToHashPtr</td><td>Pointer to the string to be hashed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bcf5d26bec7e15b6ec30fec4701ce03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t le_hashmap_HashUInt32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>intToHashPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integer hashing function. Can be used as a parameter to <a class="el" href="hashmap_8c.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is a uint32_t.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the uint32_t pointed to by intToHash.</dd></dl>
<p>Integer hashing function. This can be used as a paramter to le_hashmap_Create if the key to the table is a uint32_t</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the uint32_t pointed to by intToHash </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intToHashPtr</td><td>Pointer to the integer to be hashed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12558f1e0eeb68991ffb8f8ad442ce86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t le_hashmap_HashUInt64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>intToHashPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Long integer hashing function. This can be used as a paramter to le_hashmap_Create if the key to the table is a uint64_t</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the uint64_t pointed to by intToHash </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intToHashPtr</td><td>Pointer to the long integer to be hashed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c9fc51c9f65c44f6c78cdaf101ab0e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t le_hashmap_HashVoidPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>voidToHashPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer hashing function. Can be used as a parameter to <a class="el" href="hashmap_8c.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is an pointer or reference. Simply pass in the address as the key.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the pointer pointed to by voidToHashPtr</dd></dl>
<p>Pointer hashing function. This can be used as a parameter to <a class="el" href="hashmap_8c.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is an pointer or reference. Simply pass in the address as the key.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the pointer pointed to by voidToHashPtr </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">voidToHashPtr</td><td>Pointer to be hashed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5530fc9656f5e49f891541900bc21f34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_isEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests if the HashMap is empty (i.e. contains zero keys).</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if empty, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a853082500b05e57d899606cfc0e34fab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_hashmap_MakeTraceable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a particular hashmap traceable without enabling the tracing. After this is called, when the trace keyword for this hashmap (the hashmap's name) is enabled for the "framework" component in the process, tracing will start. If that keyword was enabled before this function was called, tracing will start immediately when it is called.</p>
<p>Makes a particular hashmap traceable without enabling the tracing. After this is called, when the trace keyword for this hashmap (the hashmap's name) is enabled for the "framework" component in the process, then tracing will commence. If that keyword was already enabled before this function is called, then tracing will commence immediately when this function is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a601b7d3e5d92e91e4090d726e5b190ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_hashmap_NextNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the iterator to the next key/value pair in the map. Order is dependent on the hash algorithm and the order of inserts, and is not sorted at all.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns LE_OK unless you go past the end of the map, then returns LE_NOT_FOUND.</dd></dl>
<p>Moves the iterator to the next key/value pair in the map. Order is dependent on the hash algorithm and the order of inserts and is not sorted at all.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns LE_OK unless you go past the end of the map, then returns LE_NOT_FOUND </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad5cdb7a6d36d28699b255814c0d639d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_hashmap_PrevNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the iterator to the previous key/value pair in the map. Order is dependent on the hash algorithm and the order of inserts, and is not sorted at all.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns LE_OK unless you go past the beginning of the map, then returns LE_NOT_FOUND. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68759fb8291c487a507eae6d92710fc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* le_hashmap_Put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>valuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a key-value pair to a HashMap. If the key already exists in the map, the previous value will be replaced with the new value passed into this function.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns NULL for a new entry or a pointer to the old value if it is replaced.</dd></dl>
<p>Add a key-value pair to a HashMap. If the key already exists in the map then the previous value will be replaced with the new value passed into this function.</p>
<p>The process will terminate if this fails as it implies an inability to allocate any more memory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valuePtr</td><td>Pointer to the value to be stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64eab4c096da5b66aa54c70ec5d5a776"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* le_hashmap_Remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a value from a HashMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the value or NULL if the key is not found.</dd></dl>
<p>Remove a value from a HashMap.</p>
<dl class="section note"><dt>Note</dt><dd>If the iterator is currently on the item being removed, then it's value is invalidated. The iterator will have to be moved before values and keys can be read from it again.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the value or NULL if the key is not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27e3af23871a2f9e8adffb748111aab2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_hashmap_RemoveAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all the entries held in the hashmap. This will not delete the data pointed to by the key and value pointers. That cleanup is the responsibility of the caller. This allows the map to be re-used. Currently maps can't be deleted.</p>
<p>Deletes all the entries held in the hashmap. This will not delete the data pointed to by the key and value pointers. That cleanup is the responsibility of the caller. This allows the map to be re-used. Currently maps cannot be deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a481e3fa6b0fe8319074140a2cb2ae1cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t le_hashmap_Size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the number of keys in the HashMap.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of keys in the HashMap. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
