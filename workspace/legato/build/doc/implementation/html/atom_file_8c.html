<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: framework/liblegato/linux/atomFile.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('atom_file_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">atomFile.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="legato_8h_source.html">legato.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="file_descriptor_8h_source.html">fileDescriptor.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="liblegato_2linux_2file_8h_source.html">file.h</a>&quot;</code><br />
<code>#include &lt;sys/file.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_file_access__t.html">FileAccess_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a373fa9b161f8f28a558898495a3c6ea9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a373fa9b161f8f28a558898495a3c6ea9">TEMP_FILE_EXTENSION</a>&#160;&#160;&#160;&quot;.bak~~XXXXXX&quot;</td></tr>
<tr class="separator:a373fa9b161f8f28a558898495a3c6ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcace1b5b34edd5d4222e933b5a49d3a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#abcace1b5b34edd5d4222e933b5a49d3a">LOCK_FILE_EXTENSION</a>&#160;&#160;&#160;&quot;.lock~~XXXXXX&quot;</td></tr>
<tr class="separator:abcace1b5b34edd5d4222e933b5a49d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836e28e9463a55cf4b1ef12822e74bc9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a836e28e9463a55cf4b1ef12822e74bc9">LOCK_FILE_TEMP_DIR</a>&#160;&#160;&#160;&quot;/tmp/&quot;</td></tr>
<tr class="separator:a836e28e9463a55cf4b1ef12822e74bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0376b2ead2de10bb7ab6a4d21ec304e9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a0376b2ead2de10bb7ab6a4d21ec304e9">LOCK</a>&#160;&#160;&#160;<a class="el" href="sbtrace_8c.html#a7c6c2e5e914cf8eca19d150e90f3b106">LE_ASSERT</a>(pthread_mutex_lock(&amp;<a class="el" href="thread_8c.html#abc03085ccf7c38e092cdf06bf6b98ea6">Mutex</a>) == 0);</td></tr>
<tr class="memdesc:a0376b2ead2de10bb7ab6a4d21ec304e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the mutex.  <a href="#a0376b2ead2de10bb7ab6a4d21ec304e9">More...</a><br /></td></tr>
<tr class="separator:a0376b2ead2de10bb7ab6a4d21ec304e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82effb31e82e32254efc8b57251d59e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#ac82effb31e82e32254efc8b57251d59e">UNLOCK</a>&#160;&#160;&#160;<a class="el" href="sbtrace_8c.html#a7c6c2e5e914cf8eca19d150e90f3b106">LE_ASSERT</a>(pthread_mutex_unlock(&amp;<a class="el" href="thread_8c.html#abc03085ccf7c38e092cdf06bf6b98ea6">Mutex</a>) == 0);</td></tr>
<tr class="memdesc:ac82effb31e82e32254efc8b57251d59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the mutex.  <a href="#ac82effb31e82e32254efc8b57251d59e">More...</a><br /></td></tr>
<tr class="separator:ac82effb31e82e32254efc8b57251d59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4c9e5c68d2f4fe9426343651f03fe2cf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_file_access__t.html">FileAccess_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a4c9e5c68d2f4fe9426343651f03fe2cf">GetFileData</a> (int <a class="el" href="app_stop_client_8c.html#a44f21d5190b5a6df8089f54799628d7e">fd</a>)</td></tr>
<tr class="separator:a4c9e5c68d2f4fe9426343651f03fe2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5574d8131a085023934d9b50f091a05"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#af5574d8131a085023934d9b50f091a05">SaveFileData</a> (int <a class="el" href="app_stop_client_8c.html#a44f21d5190b5a6df8089f54799628d7e">fd</a>, int lockFd, int tempFd, const char *pathNamePtr)</td></tr>
<tr class="separator:af5574d8131a085023934d9b50f091a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a083ec8b672de9898cab404ed1624e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a3a083ec8b672de9898cab404ed1624e8">DeleteFileData</a> (<a class="el" href="struct_file_access__t.html">FileAccess_t</a> *accessPtr)</td></tr>
<tr class="separator:a3a083ec8b672de9898cab404ed1624e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27dc4d8a7a49f4c795f8951fbb2a2e5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#ae27dc4d8a7a49f4c795f8951fbb2a2e5">DeleteFile</a> (const char *filePath)</td></tr>
<tr class="separator:ae27dc4d8a7a49f4c795f8951fbb2a2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c4c93762cff42d96ac2cf13ff0a347b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a9c4c93762cff42d96ac2cf13ff0a347b">GetFilePath</a> (const char *originFilePath, const char *fileExtension, char *outFilePath, size_t filePathSize)</td></tr>
<tr class="separator:a9c4c93762cff42d96ac2cf13ff0a347b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a66ae9105529160fa42862c93a18347"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a8a66ae9105529160fa42862c93a18347">CheckIfRegFileExist</a> (const char *filePath)</td></tr>
<tr class="separator:a8a66ae9105529160fa42862c93a18347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a2db1a9c91aaaeb98e7e1ce6550ba0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a09a2db1a9c91aaaeb98e7e1ce6550ba0">OpenLockFile</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, bool blocking)</td></tr>
<tr class="separator:a09a2db1a9c91aaaeb98e7e1ce6550ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aea9e98b5bc5c62952bd47471deacf4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a2aea9e98b5bc5c62952bd47471deacf4">CreateTempFromOriginal</a> (const char *origPathPtr, const char *tempPathPtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, bool copy)</td></tr>
<tr class="separator:a2aea9e98b5bc5c62952bd47471deacf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b45a33096b6719d6255e67e701afa3"><td class="memItemLeft" align="right" valign="top">static FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a38b45a33096b6719d6255e67e701afa3">CreateTempStreamFromOriginal</a> (const char *origPathPtr, const char *tempPathPtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, bool copy, <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *resultPtr)</td></tr>
<tr class="separator:a38b45a33096b6719d6255e67e701afa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4542679429a6fb1dcb83ede721892a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a7d4542679429a6fb1dcb83ede721892a">Open</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, bool blocking)</td></tr>
<tr class="separator:a7d4542679429a6fb1dcb83ede721892a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdeb415e99062762b23a0ede864e9c3c"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#acdeb415e99062762b23a0ede864e9c3c">Create</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a> createMode, mode_t permissions, bool blocking)</td></tr>
<tr class="separator:acdeb415e99062762b23a0ede864e9c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61038be2a1d8b3eb207a6d02d56feaf"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#aa61038be2a1d8b3eb207a6d02d56feaf">SyncFile</a> (<a class="el" href="struct_file_access__t.html">FileAccess_t</a> *accessPtr, const char *tempFilePath)</td></tr>
<tr class="separator:aa61038be2a1d8b3eb207a6d02d56feaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bc94af099b19318174960fcdea7598"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#ac9bc94af099b19318174960fcdea7598">Close</a> (int <a class="el" href="app_stop_client_8c.html#a44f21d5190b5a6df8089f54799628d7e">fd</a>, bool commit)</td></tr>
<tr class="separator:ac9bc94af099b19318174960fcdea7598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4af2116243474c7494ca9319414797"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a2f4af2116243474c7494ca9319414797">Delete</a> (const char *pathNamePtr, bool blocking)</td></tr>
<tr class="separator:a2f4af2116243474c7494ca9319414797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f88f0430d01f3828ac9310b48974e7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a43f88f0430d01f3828ac9310b48974e7">le_atomFile_Open</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode)</td></tr>
<tr class="separator:a43f88f0430d01f3828ac9310b48974e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17672cb7568a41dfc4c84244e1104204"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a17672cb7568a41dfc4c84244e1104204">le_atomFile_Create</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a> createMode, mode_t permissions)</td></tr>
<tr class="separator:a17672cb7568a41dfc4c84244e1104204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e9641d647ae59106bab67b5690cfb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a57e9641d647ae59106bab67b5690cfb4">le_atomFile_TryOpen</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode)</td></tr>
<tr class="separator:a57e9641d647ae59106bab67b5690cfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56b841ef635512caf5011824ace74e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#af56b841ef635512caf5011824ace74e8">le_atomFile_TryCreate</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a> createMode, mode_t permissions)</td></tr>
<tr class="separator:af56b841ef635512caf5011824ace74e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c44b530b5d7513e1de9ed28bbf651c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a2c44b530b5d7513e1de9ed28bbf651c0">le_atomFile_Cancel</a> (int <a class="el" href="app_stop_client_8c.html#a44f21d5190b5a6df8089f54799628d7e">fd</a>)</td></tr>
<tr class="separator:a2c44b530b5d7513e1de9ed28bbf651c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8397f267beafb22701b422b4410707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a8f8397f267beafb22701b422b4410707">le_atomFile_Close</a> (int <a class="el" href="app_stop_client_8c.html#a44f21d5190b5a6df8089f54799628d7e">fd</a>)</td></tr>
<tr class="separator:a8f8397f267beafb22701b422b4410707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1780cd0da9775abe9210542d2fcb3d5a"><td class="memItemLeft" align="right" valign="top">static FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a1780cd0da9775abe9210542d2fcb3d5a">OpenStream</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, bool blocking, <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *resultPtr)</td></tr>
<tr class="separator:a1780cd0da9775abe9210542d2fcb3d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24589147c26f6b8aabe049ef5a45fd24"><td class="memItemLeft" align="right" valign="top">static FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a24589147c26f6b8aabe049ef5a45fd24">CreateStream</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a> createMode, mode_t permissions, bool blocking, <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *resultPtr)</td></tr>
<tr class="separator:a24589147c26f6b8aabe049ef5a45fd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9e1cd1e9865bc1b81611697420da02"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#aaf9e1cd1e9865bc1b81611697420da02">CloseStream</a> (FILE *file, bool commit)</td></tr>
<tr class="separator:aaf9e1cd1e9865bc1b81611697420da02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eecd192057a65b94255cc3fe042d7a2"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a9eecd192057a65b94255cc3fe042d7a2">le_atomFile_OpenStream</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *resultPtr)</td></tr>
<tr class="separator:a9eecd192057a65b94255cc3fe042d7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84bd503ee3efb23393bc7228715b85c1"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a84bd503ee3efb23393bc7228715b85c1">le_atomFile_CreateStream</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a> createMode, mode_t permissions, <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *resultPtr)</td></tr>
<tr class="separator:a84bd503ee3efb23393bc7228715b85c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5112afbf738c0f9d4909bdbc6da5c99d"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a5112afbf738c0f9d4909bdbc6da5c99d">le_atomFile_TryOpenStream</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *resultPtr)</td></tr>
<tr class="separator:a5112afbf738c0f9d4909bdbc6da5c99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0376766efe9b1768e939714420c0b47d"><td class="memItemLeft" align="right" valign="top">FILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a0376766efe9b1768e939714420c0b47d">le_atomFile_TryCreateStream</a> (const char *pathNamePtr, <a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a> accessMode, <a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a> createMode, mode_t permissions, <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *resultPtr)</td></tr>
<tr class="separator:a0376766efe9b1768e939714420c0b47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cf35b73463f7eea098aba57587b7c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#ae5cf35b73463f7eea098aba57587b7c3">le_atomFile_CancelStream</a> (FILE *fileStreamPtr)</td></tr>
<tr class="separator:ae5cf35b73463f7eea098aba57587b7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea745228ae746df24005a10ba06edd57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#aea745228ae746df24005a10ba06edd57">le_atomFile_CloseStream</a> (FILE *fileStreamPtr)</td></tr>
<tr class="separator:aea745228ae746df24005a10ba06edd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c305e7a46be873ce33e59fcd4285dfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a0c305e7a46be873ce33e59fcd4285dfe">le_atomFile_Delete</a> (const char *pathNamePtr)</td></tr>
<tr class="separator:a0c305e7a46be873ce33e59fcd4285dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113bc9bb8b5c685092263061b018e8ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a113bc9bb8b5c685092263061b018e8ce">le_atomFile_TryDelete</a> (const char *pathNamePtr)</td></tr>
<tr class="separator:a113bc9bb8b5c685092263061b018e8ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8643568006aedb9cd5f8f720f7932042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a8643568006aedb9cd5f8f720f7932042">atomFile_Init</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:a8643568006aedb9cd5f8f720f7932042"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:abc03085ccf7c38e092cdf06bf6b98ea6"><td class="memItemLeft" align="right" valign="top">static pthread_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#abc03085ccf7c38e092cdf06bf6b98ea6">Mutex</a> = PTHREAD_MUTEX_INITIALIZER</td></tr>
<tr class="separator:abc03085ccf7c38e092cdf06bf6b98ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9b284eb284bb2630b4ecf35c42a8e0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#a1d9b284eb284bb2630b4ecf35c42a8e0">FileAccessPool</a></td></tr>
<tr class="separator:a1d9b284eb284bb2630b4ecf35c42a8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aebd4f0d4334495126870207af62ed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structle__dls___list__t.html">le_dls_List_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atom_file_8c.html#ac9aebd4f0d4334495126870207af62ed">FileAccessList</a> = <a class="el" href="le__doubly_linked_list_8h.html#a68f28b61cdfd004591f24730b4d5a740">LE_DLS_LIST_INIT</a></td></tr>
<tr class="separator:ac9aebd4f0d4334495126870207af62ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a0376b2ead2de10bb7ab6a4d21ec304e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK&#160;&#160;&#160;<a class="el" href="sbtrace_8c.html#a7c6c2e5e914cf8eca19d150e90f3b106">LE_ASSERT</a>(pthread_mutex_lock(&amp;<a class="el" href="thread_8c.html#abc03085ccf7c38e092cdf06bf6b98ea6">Mutex</a>) == 0);</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the mutex. </p>

</div>
</div>
<a class="anchor" id="abcace1b5b34edd5d4222e933b5a49d3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_FILE_EXTENSION&#160;&#160;&#160;&quot;.lock~~XXXXXX&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extension used for lock file </p>

</div>
</div>
<a class="anchor" id="a836e28e9463a55cf4b1ef12822e74bc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOCK_FILE_TEMP_DIR&#160;&#160;&#160;&quot;/tmp/&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Temp directory to use for lock file when directory is not writable </p>

</div>
</div>
<a class="anchor" id="a373fa9b161f8f28a558898495a3c6ea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TEMP_FILE_EXTENSION&#160;&#160;&#160;&quot;.bak~~XXXXXX&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extension used for temporary file </p>

</div>
</div>
<a class="anchor" id="ac82effb31e82e32254efc8b57251d59e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UNLOCK&#160;&#160;&#160;<a class="el" href="sbtrace_8c.html#a7c6c2e5e914cf8eca19d150e90f3b106">LE_ASSERT</a>(pthread_mutex_unlock(&amp;<a class="el" href="thread_8c.html#abc03085ccf7c38e092cdf06bf6b98ea6">Mutex</a>) == 0);</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks the mutex. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8643568006aedb9cd5f8f720f7932042"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> atomFile_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the atomic file access internal memory pools. This function is meant to be called from Legato's internal init. </p>

</div>
</div>
<a class="anchor" id="a8a66ae9105529160fa42862c93a18347"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> CheckIfRegFileExist </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks the file at given file system path.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the file exists and is a normal file. LE_NOT_FOUND if file does not exists. LE_FAULT for any other error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePath</td><td>Path to the file in question. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac9bc94af099b19318174960fcdea7598"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> Close </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Commit or cancel all changes done on the file.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_FAULT if there was an error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor to close. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commit</td><td>true to commit, false to cancel changes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf9e1cd1e9865bc1b81611697420da02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> CloseStream </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>commit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Commit or cancel all changes done on the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file</td><td>File Stream to close </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">commit</td><td>true to commit, false to cancel changes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acdeb415e99062762b23a0ede864e9c3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a>&#160;</td>
          <td class="paramname"><em>createMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>permissions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a file for atomic operation.</p>
<dl class="section return"><dt>Returns</dt><dd>File descriptor for doing atomic operation. LE_DUPLICATE if the file already exists and LE_FLOCK_FAIL_IF_EXIST is specified in createMode LE_WOULD_BLOCK if there is already an incompatible lock on the file. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createMode</td><td>The action to take if the file already exists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>The file permissions used when creating the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocking</td><td>true if blocking, false if non-blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a24589147c26f6b8aabe049ef5a45fd24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FILE* CreateStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a>&#160;</td>
          <td class="paramname"><em>createMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>permissions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *&#160;</td>
          <td class="paramname"><em>resultPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a file stream for atomic operation.</p>
<p>If there was an error NULL is returned and resultPtr is set to:</p><ul>
<li>LE_DUPLICATE if the file already exists and LE_FLOCK_FAIL_IF_EXIST is specified in createMode.</li>
<li>LE_WOULD_BLOCK if there is already an incompatible lock on the file.</li>
<li>LE_FAULT if there was an error.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Buffered file stream handle to the file if successful. NULL if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createMode</td><td>The action to take if the file already exists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>The file permissions used when creating the file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocking</td><td>true if blocking, false if non-blocking. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPtr</td><td>A pointer to result code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2aea9e98b5bc5c62952bd47471deacf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int CreateTempFromOriginal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>origPathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tempPathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates temporary file for doing all intermediate operations. This function is used to create temporary file when original file exists. File permissions are copied from the original file.</p>
<dl class="section return"><dt>Returns</dt><dd>A file descriptor for doing atomic operation. LE_NOT_FOUND if the file does not exist. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origPathPtr</td><td>Path to original file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tempPathPtr</td><td>Path to temporary file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>Whether content of original file should be copied to temporary file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a38b45a33096b6719d6255e67e701afa3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FILE* CreateTempStreamFromOriginal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>origPathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tempPathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *&#160;</td>
          <td class="paramname"><em>resultPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates temporary file stream for doing all intermediate operations. This function is used to create temporary file when original file exists. File permissions are copied from the original file.</p>
<p>If there was an error NULL is returned and resultPtr is set to: LE_NOT_FOUND if file doesn't exists. LE_FAULT if there was an error.</p>
<dl class="section return"><dt>Returns</dt><dd>Buffered file stream handle to the file if successful. NULL if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">origPathPtr</td><td>Path to original file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tempPathPtr</td><td>Path to temporary file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">copy</td><td>Whether content of original file should be copied to temporary file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPtr</td><td>A pointer to result code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2f4af2116243474c7494ca9319414797"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> Delete </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Atomically and safely deletes a file.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_NOT_FOUND if file doesn't exists. LE_WOULD_BLOCK if file is already locked (i.e. someone is using it). LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to delete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocking</td><td>True if blocking, false if non-blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae27dc4d8a7a49f4c795f8951fbb2a2e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> DeleteFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes a file at a given path.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_FAULT if failed, </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filePath</td><td>Path to the file to delete. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a083ec8b672de9898cab404ed1624e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> DeleteFileData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_file_access__t.html">FileAccess_t</a> *&#160;</td>
          <td class="paramname"><em>accessPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete atomically accessed file data from memory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accessPtr</td><td>File access data to be deleted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4c9e5c68d2f4fe9426343651f03fe2cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_file_access__t.html">FileAccess_t</a>* GetFileData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Search and return <a class="el" href="struct_file_access__t.html">FileAccess_t</a> object using file descriptor of temporary file.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_file_access__t.html">FileAccess_t</a> object if exists any. NULL if doesn't exist </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>File descriptor of atomically accessed file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c4c93762cff42d96ac2cf13ff0a347b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> GetFilePath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>originFilePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fileExtension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>outFilePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>filePathSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get file path with file extension appended. If the directory is not writable, the lock is created into /tmp instead and in path name '/' are replaced by '.'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">originFilePath</td><td>Path of original file. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fileExtension</td><td>Extension that should be appended with file path </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">outFilePath</td><td>Path of appended file extension </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">filePathSize</td><td>File path length </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c44b530b5d7513e1de9ed28bbf651c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_atomFile_Cancel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancels all changes and closes the file descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>The file descriptor to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5cf35b73463f7eea098aba57587b7c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_atomFile_CancelStream </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fileStreamPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancels all changes and closes the file stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileStreamPtr</td><td>File stream pointer to close </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f8397f267beafb22701b422b4410707"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_atomFile_Close </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Commits all changes and closes the file descriptor. No need to close the file descriptor again if this function returns error (i.e. file descriptor is closed in both success and error scenario).</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_FAULT if there was an error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>The file descriptor to close. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea745228ae746df24005a10ba06edd57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_atomFile_CloseStream </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fileStreamPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Commits all changes and closes the file stream. No need to close the file stream again if this function returns error (i.e. file stream is closed in both success and error scenario).</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_FAULT if there was an error </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fileStreamPtr</td><td>File stream pointer to close </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17672cb7568a41dfc4c84244e1104204"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int le_atomFile_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a>&#160;</td>
          <td class="paramname"><em>createMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and opens file for atomic operation.</p>
<p>If the file does not exist it will be created with the file permissions specified in the argument permissions (modified by the process's umask). Refer to the POSIX function open(2) for details of mode_t:</p>
<p><a href="http://man7.org/linux/man-pages/man2/open.2.html">http://man7.org/linux/man-pages/man2/open.2.html</a></p>
<p>The file can be opened for reading, writing or both as specified in the accessMode argument. Parameter accessMode specifies the lock to be applied on the file (read lock will be applied for LE_FLOCK_READ and write lock will be placed for all other cases).</p>
<p>This is a blocking call. It will block until it can create and open the target file with specified parameters(i.e. accessMode, createMode, permissions).</p>
<dl class="section return"><dt>Returns</dt><dd>A file descriptor if successful. LE_DUPLICATE if the file already exists and LE_FLOCK_FAIL_IF_EXIST is specified in createMode LE_FAULT if there was an error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>File must be closed using <a class="el" href="atom_file_8c.html#a8f8397f267beafb22701b422b4410707">le_atomFile_Close()</a> or <a class="el" href="atom_file_8c.html#a2c44b530b5d7513e1de9ed28bbf651c0">le_atomFile_Cancel()</a> function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createMode</td><td>The action to take if the file already exists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>The file permissions used when creating the file. See the function header comments for more details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84bd503ee3efb23393bc7228715b85c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* le_atomFile_CreateStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a>&#160;</td>
          <td class="paramname"><em>createMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>permissions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *&#160;</td>
          <td class="paramname"><em>resultPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and open a file via C standard library buffered file stream for atomic operation.</p>
<p>If the file does not exist it will be created with the file permissions specified in the argument permissions (modified by the process's umask). Refer to the POSIX function open(2) for details of mode_t:</p>
<p><a href="http://man7.org/linux/man-pages/man2/open.2.html">http://man7.org/linux/man-pages/man2/open.2.html</a></p>
<p>The file can be opened for reading, writing or both as specified in the accessMode argument. Parameter accessMode specifies the lock to be applied on the file (read lock will be applied for LE_FLOCK_READ and write lock will be placed for all other cases).</p>
<p>This is a blocking call. It will block until it can create and open the target file with specified parameters(i.e. accessMode, createMode, permissions).</p>
<p>If there was an error NULL is returned and resultPtr is set to:</p><ul>
<li>LE_DUPLICATE if the file already exists and LE_FLOCK_FAIL_IF_EXIST is specified in createMode.</li>
<li>LE_FAULT if there was an error.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Buffered file stream handle to the file if successful. NULL if there was an error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Stream must be closed using <a class="el" href="atom_file_8c.html#aea745228ae746df24005a10ba06edd57">le_atomFile_CloseStream()</a> or <a class="el" href="atom_file_8c.html#ae5cf35b73463f7eea098aba57587b7c3">le_atomFile_CancelStream()</a> function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createMode</td><td>The action to take if the file already exists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>The file permissions used when creating the file. See the function header comments for more details. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPtr</td><td>A pointer to result code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c305e7a46be873ce33e59fcd4285dfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_atomFile_Delete </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomically deletes a file. This function also ensures safe deletion of file (i.e. if any other process/thread is using the file by acquiring file lock, it won't delete the file unless lock is released). This is a blocking call. It will block until lock on file is released.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_NOT_FOUND if file doesn't exists. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43f88f0430d01f3828ac9310b48974e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int le_atomFile_Open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens an existing file for atomic access operation.</p>
<p>The file can be open for reading, writing or both as specified in the accessMode argument. Parameter accessMode specifies the lock to be applied on the file (read lock will be applied for LE_FLOCK_READ and write lock will be placed for all other cases).</p>
<p>This is a blocking call. It will block until it can open the target file with specified accessMode.</p>
<dl class="section return"><dt>Returns</dt><dd>A file descriptor if successful. LE_NOT_FOUND if the file does not exist. LE_FAULT if there was an error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>File must be closed using <a class="el" href="atom_file_8c.html#a8f8397f267beafb22701b422b4410707">le_atomFile_Close()</a> or <a class="el" href="atom_file_8c.html#a2c44b530b5d7513e1de9ed28bbf651c0">le_atomFile_Cancel()</a> function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9eecd192057a65b94255cc3fe042d7a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* le_atomFile_OpenStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *&#160;</td>
          <td class="paramname"><em>resultPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens an existing file via C standard library buffered file stream for atomic operation.</p>
<p>The file can be open for reading, writing or both as specified in the accessMode argument. Parameter accessMode specifies the lock to be applied on the file (read lock will be applied for LE_FLOCK_READ and write lock will be placed for all other cases).</p>
<p>This is a blocking call. It will block until it can open the target file with specified accessMode.</p>
<p>If there was an error NULL is returned and resultPtr is set to:</p><ul>
<li>LE_NOT_FOUND if the file does not exist.</li>
<li>LE_FAULT if there was an error.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Buffered file stream handle to the file if successful. NULL if there was an error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Stream must be closed using <a class="el" href="atom_file_8c.html#aea745228ae746df24005a10ba06edd57">le_atomFile_CloseStream()</a> or <a class="el" href="atom_file_8c.html#ae5cf35b73463f7eea098aba57587b7c3">le_atomFile_CancelStream()</a> function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPtr</td><td>A pointer to result code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af56b841ef635512caf5011824ace74e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int le_atomFile_TryCreate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a>&#160;</td>
          <td class="paramname"><em>createMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>permissions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <code><a class="el" href="atom_file_8c.html#a17672cb7568a41dfc4c84244e1104204">le_atomFile_Create()</a></code> except that it is non-blocking function and it will fail and return LE_WOULD_BLOCK immediately if target file has incompatible lock.</p>
<dl class="section return"><dt>Returns</dt><dd>A file descriptor if successful. LE_DUPLICATE if the file already exists and LE_FLOCK_FAIL_IF_EXIST is specified in createMode LE_WOULD_BLOCK if there is already an incompatible lock on the file. LE_FAULT if there was an error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>File must be closed using <a class="el" href="atom_file_8c.html#a8f8397f267beafb22701b422b4410707">le_atomFile_Close()</a> or <a class="el" href="atom_file_8c.html#a2c44b530b5d7513e1de9ed28bbf651c0">le_atomFile_Cancel()</a> function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createMode</td><td>The action to take if the file already exists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>The file permissions used when creating the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0376766efe9b1768e939714420c0b47d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* le_atomFile_TryCreateStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a35d8c575df68d1da52a1048916f7e7d9">le_flock_CreateMode_t</a>&#160;</td>
          <td class="paramname"><em>createMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>permissions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *&#160;</td>
          <td class="paramname"><em>resultPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <code><a class="el" href="atom_file_8c.html#a84bd503ee3efb23393bc7228715b85c1">le_atomFile_CreateStream()</a></code> except that it is non-blocking function and it will fail and return LE_WOULD_BLOCK immediately if target file has incompatible lock.</p>
<p>If there was an error NULL is returned and resultPtr is set to:</p><ul>
<li>LE_DUPLICATE if the file already exists and LE_FLOCK_FAIL_IF_EXIST is specified in createMode.</li>
<li>LE_WOULD_BLOCK if there is already an incompatible lock on the file.</li>
<li>LE_FAULT if there was an error.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Buffered file stream handle to the file if successful. NULL if there was an error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Stream must be closed using <a class="el" href="atom_file_8c.html#aea745228ae746df24005a10ba06edd57">le_atomFile_CloseStream()</a> or <a class="el" href="atom_file_8c.html#ae5cf35b73463f7eea098aba57587b7c3">le_atomFile_CancelStream()</a> function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createMode</td><td>The action to take if the file already exists. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">permissions</td><td>The file permissions used when creating the file. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPtr</td><td>A pointer to result code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a113bc9bb8b5c685092263061b018e8ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_atomFile_TryDelete </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <code><a class="el" href="atom_file_8c.html#a0c305e7a46be873ce33e59fcd4285dfe">le_atomFile_Delete()</a></code> except that it is non-blocking function and it will fail and return LE_WOULD_BLOCK immediately if target file is locked.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_NOT_FOUND if file doesn't exists. LE_WOULD_BLOCK if file is already locked (i.e. someone is using it). LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57e9641d647ae59106bab67b5690cfb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int le_atomFile_TryOpen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <code><a class="el" href="atom_file_8c.html#a43f88f0430d01f3828ac9310b48974e7">le_atomFile_Open()</a></code> except that it is non-blocking function and it will fail and return LE_WOULD_BLOCK immediately if target file has incompatible lock.</p>
<dl class="section return"><dt>Returns</dt><dd>A file descriptor if successful. LE_NOT_FOUND if the file does not exist. LE_WOULD_BLOCK if there is already an incompatible lock on the file. LE_FAULT if there was an error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>File must be closed using <a class="el" href="atom_file_8c.html#a8f8397f267beafb22701b422b4410707">le_atomFile_Close()</a> or <a class="el" href="atom_file_8c.html#a2c44b530b5d7513e1de9ed28bbf651c0">le_atomFile_Cancel()</a> function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5112afbf738c0f9d4909bdbc6da5c99d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FILE* le_atomFile_TryOpenStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *&#160;</td>
          <td class="paramname"><em>resultPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as <code><a class="el" href="atom_file_8c.html#a9eecd192057a65b94255cc3fe042d7a2">le_atomFile_OpenStream()</a></code> except that it is non-blocking function and it will fail and return LE_WOULD_BLOCK immediately if target file has incompatible lock.</p>
<p>If there was an error NULL is returned and resultPtr is set to:</p><ul>
<li>LE_NOT_FOUND if the file does not exist.</li>
<li>LE_WOULD_BLOCK if there is already an incompatible lock on the file.</li>
<li>LE_FAULT if there was an error.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Buffered file stream handle to the file if successful. NULL if there was an error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Stream must be closed using <a class="el" href="atom_file_8c.html#aea745228ae746df24005a10ba06edd57">le_atomFile_CloseStream()</a> or <a class="el" href="atom_file_8c.html#ae5cf35b73463f7eea098aba57587b7c3">le_atomFile_CancelStream()</a> function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPtr</td><td>A pointer to result code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7d4542679429a6fb1dcb83ede721892a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int Open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open an existing file for atomic operation.</p>
<dl class="section return"><dt>Returns</dt><dd>A file descriptor for doing atomic operation. LE_NOT_FOUND if the file does not exist. LE_WOULD_BLOCK if there is already an incompatible lock on the file. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocking</td><td>true if blocking, false if non-blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09a2db1a9c91aaaeb98e7e1ce6550ba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int OpenLockFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open lock file for the file which will do atomic operation. If there is no lock file, this function will create and open lock file</p>
<dl class="section return"><dt>Returns</dt><dd>A file descriptor for doing atomic operation. LE_WOULD_BLOCK if there is already an incompatible lock on the file. LE_FAULT if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file for which lockfile should be open </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocking</td><td>true if blocking, false if non-blocking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1780cd0da9775abe9210542d2fcb3d5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static FILE* OpenStream </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__file_lock_8h.html#a5e5400e33a5e10b7c624748a9ce11280">le_flock_AccessMode_t</a>&#160;</td>
          <td class="paramname"><em>accessMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>blocking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> *&#160;</td>
          <td class="paramname"><em>resultPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open a stream for atomic operation.</p>
<p>If there was an error NULL is returned and resultPtr is set to:</p><ul>
<li>LE_NOT_FOUND if the file does not exist.</li>
<li>LE_WOULD_BLOCK if there is already an incompatible lock on the file.</li>
<li>LE_FAULT if there was an error.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>Buffered file stream handle to the file if successful. NULL if there was an error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathNamePtr</td><td>Path of the file to open. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">accessMode</td><td>The access mode to open the file with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocking</td><td>true if blocking, false if non-blocking. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">resultPtr</td><td>A pointer to result code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af5574d8131a085023934d9b50f091a05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> SaveFileData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lockFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tempFd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathNamePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store atomically accessed file info to memory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>File descriptor of atomically accessed file. </td></tr>
    <tr><td class="paramname">lockFd</td><td>File descriptor of lock file. </td></tr>
    <tr><td class="paramname">tempFd</td><td>File descriptor of temporary file. </td></tr>
    <tr><td class="paramname">pathNamePtr</td><td>Path to atomically accessed file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa61038be2a1d8b3eb207a6d02d56feaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> SyncFile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_file_access__t.html">FileAccess_t</a> *&#160;</td>
          <td class="paramname"><em>accessPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>tempFilePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sync files to disk</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful LE_FAULT if failed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">accessPtr</td><td>Object containing files to be Sync-ed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tempFilePath</td><td>Path to temporary file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ac9aebd4f0d4334495126870207af62ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structle__dls___list__t.html">le_dls_List_t</a> FileAccessList = <a class="el" href="le__doubly_linked_list_8h.html#a68f28b61cdfd004591f24730b4d5a740">LE_DLS_LIST_INIT</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Linked list of <a class="el" href="struct_file_access__t.html">FileAccess_t</a> objects. </p>

</div>
</div>
<a class="anchor" id="a1d9b284eb284bb2630b4ecf35c42a8e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a> FileAccessPool</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pool to allocate <a class="el" href="struct_file_access__t.html">FileAccess_t</a> objects. </p>

</div>
</div>
<a class="anchor" id="abc03085ccf7c38e092cdf06bf6b98ea6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t Mutex = PTHREAD_MUTEX_INITIALIZER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mutex used to protect shared data structures in this module. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
