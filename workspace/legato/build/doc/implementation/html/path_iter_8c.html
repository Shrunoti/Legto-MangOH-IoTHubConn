<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: framework/liblegato/linux/pathIter.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('path_iter_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">pathIter.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="legato_8h_source.html">legato.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="limit_8h_source.html">limit.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_path_iterator__t.html">PathIterator_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a4ab86e7102448b00d4a7b23a07a6431a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a4ab86e7102448b00d4a7b23a07a6431a">MAX_COMPONENT_NAME_BYTES</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:a4ab86e7102448b00d4a7b23a07a6431a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac3fb15e4a7ede25216d772b6bcf3496a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_path_iterator__t.html">PathIterator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#ac3fb15e4a7ede25216d772b6bcf3496a">GetPathIterPtr</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:ac3fb15e4a7ede25216d772b6bcf3496a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8da82fe54dc735b1490e66b12db6c3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#aba8da82fe54dc735b1490e66b12db6c3">IsAtSeperator</a> (const char *pathStr, size_t pathSize, const char *sepStr, size_t sepSize, size_t currentPosition)</td></tr>
<tr class="separator:aba8da82fe54dc735b1490e66b12db6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466a28b96e9eeb700ad7ab51825ef548"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a466a28b96e9eeb700ad7ab51825ef548">FindNextNodeIndex</a> (const char *pathStr, size_t pathSize, const char *sepStr, size_t sepSize, size_t startPoint)</td></tr>
<tr class="separator:a466a28b96e9eeb700ad7ab51825ef548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94519cbdc96eacad5288899af7513bdd"><td class="memItemLeft" align="right" valign="top">static ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a94519cbdc96eacad5288899af7513bdd">FindPrevNodeIndex</a> (const <a class="el" href="struct_path_iterator__t.html">PathIterator_t</a> *iterPtr, ssize_t startPoint)</td></tr>
<tr class="separator:a94519cbdc96eacad5288899af7513bdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79daeda2b90f10381bdedea01e8b262c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a79daeda2b90f10381bdedea01e8b262c">NodeEqual</a> (const char *pathStrPtr, const char *comparePtr, size_t compareSize, const char *separatorPtr, size_t separatorSize)</td></tr>
<tr class="separator:a79daeda2b90f10381bdedea01e8b262c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7499735013bfcc387e4c7b1b0534abc7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a7499735013bfcc387e4c7b1b0534abc7">EndsInParentSpec</a> (const <a class="el" href="struct_path_iterator__t.html">PathIterator_t</a> *iterPtr)</td></tr>
<tr class="separator:a7499735013bfcc387e4c7b1b0534abc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617925dad65206502ab6ef6fb2e8b510"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a617925dad65206502ab6ef6fb2e8b510">EndsWithSeparator</a> (const <a class="el" href="struct_path_iterator__t.html">PathIterator_t</a> *iterPtr)</td></tr>
<tr class="separator:a617925dad65206502ab6ef6fb2e8b510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe97246a010c2bea697404afc2a86d9d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#afe97246a010c2bea697404afc2a86d9d">ResetIterator</a> (<a class="el" href="struct_path_iterator__t.html">PathIterator_t</a> *iterPtr)</td></tr>
<tr class="separator:afe97246a010c2bea697404afc2a86d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dfab5e479136b01383c7f1e8d41ab6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a20dfab5e479136b01383c7f1e8d41ab6">AppendSeparator</a> (<a class="el" href="struct_path_iterator__t.html">PathIterator_t</a> *iterPtr)</td></tr>
<tr class="separator:a20dfab5e479136b01383c7f1e8d41ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b282954333012f182d43f271531e057"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a8b282954333012f182d43f271531e057">AppendNode</a> (<a class="el" href="struct_path_iterator__t.html">PathIterator_t</a> *iterPtr, const char *newSegmentPtr)</td></tr>
<tr class="separator:a8b282954333012f182d43f271531e057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89601ee1ee30ba590989ede8dad248b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#ab89601ee1ee30ba590989ede8dad248b">pathIter_Init</a> (<a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>)</td></tr>
<tr class="separator:ab89601ee1ee30ba590989ede8dad248b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fac1b657b752b17395c66fb1ae324b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a73fac1b657b752b17395c66fb1ae324b">le_pathIter_Create</a> (const char *pathPtr, const char *separatorPtr, const char *parentSpecPtr, const char *currentSpecPtr)</td></tr>
<tr class="separator:a73fac1b657b752b17395c66fb1ae324b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a38b307f9fdc0de82552e96a5a2d1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a35a38b307f9fdc0de82552e96a5a2d1d">le_pathIter_CreateForUnix</a> (const char *pathPtr)</td></tr>
<tr class="separator:a35a38b307f9fdc0de82552e96a5a2d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50349a6c2afa4415d65a6efd443894d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a50349a6c2afa4415d65a6efd443894d3">le_pathIter_Clone</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> originalRef)</td></tr>
<tr class="separator:a50349a6c2afa4415d65a6efd443894d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b57267a2c0db0210aab96c66459f9a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a6b57267a2c0db0210aab96c66459f9a1">le_pathIter_Delete</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:a6b57267a2c0db0210aab96c66459f9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586cd64de7f1a6797da3a17896946ee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a586cd64de7f1a6797da3a17896946ee5">le_pathIter_GetSeparator</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>, char *bufferPtr, size_t bufferSize)</td></tr>
<tr class="separator:a586cd64de7f1a6797da3a17896946ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1707a310401be209aeada07f6d0f43f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#af1707a310401be209aeada07f6d0f43f">le_pathIter_GetParentSpecifier</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>, char *bufferPtr, size_t bufferSize)</td></tr>
<tr class="separator:af1707a310401be209aeada07f6d0f43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12ea9bbe193fd9239abd10a4b07feba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#ac12ea9bbe193fd9239abd10a4b07feba">le_pathIter_GetCurrentSpecifier</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>, char *bufferPtr, size_t bufferSize)</td></tr>
<tr class="separator:ac12ea9bbe193fd9239abd10a4b07feba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1c39584a779518395b41f957765283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a4a1c39584a779518395b41f957765283">le_pathIter_GetPath</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>, char *bufferPtr, size_t bufferSize)</td></tr>
<tr class="separator:a4a1c39584a779518395b41f957765283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4352480ab3c9ffb09e740f2899d504e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#af4352480ab3c9ffb09e740f2899d504e">le_pathIter_GoToStart</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:af4352480ab3c9ffb09e740f2899d504e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c0b90132171b3f3cf5cfb614329b13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#ab1c0b90132171b3f3cf5cfb614329b13">le_pathIter_GoToEnd</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:ab1c0b90132171b3f3cf5cfb614329b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83a619dcc34ecf03da1859b3da2f57f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#ad83a619dcc34ecf03da1859b3da2f57f">le_pathIter_GoToNext</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:ad83a619dcc34ecf03da1859b3da2f57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a740759fe5c3b0a18e39dd8c73466b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a92a740759fe5c3b0a18e39dd8c73466b">le_pathIter_GoToPrev</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:a92a740759fe5c3b0a18e39dd8c73466b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00916d853b3a869748b0195cc2a8f11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#ab00916d853b3a869748b0195cc2a8f11">le_pathIter_GetCurrentNode</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>, char *bufferPtr, size_t bufferSize)</td></tr>
<tr class="separator:ab00916d853b3a869748b0195cc2a8f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04be1341536a3e330a815171e7cdbf7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a04be1341536a3e330a815171e7cdbf7a">le_pathIter_Truncate</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:a04be1341536a3e330a815171e7cdbf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6aa59696c54d2523009037cc78f9725"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#ae6aa59696c54d2523009037cc78f9725">le_pathIter_Append</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>, const char *pathStr)</td></tr>
<tr class="separator:ae6aa59696c54d2523009037cc78f9725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657f779873a2220f463f705298c1399f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a657f779873a2220f463f705298c1399f">le_pathIter_IsAbsolute</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:a657f779873a2220f463f705298c1399f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ceddae696158d04fdbc1802614c5d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#ab4ceddae696158d04fdbc1802614c5d6">le_pathIter_IsEmpty</a> (<a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> <a class="el" href="watchdog_8c.html#a77e3a5a5d413fe9ec45738ef01c65514">iterRef</a>)</td></tr>
<tr class="separator:ab4ceddae696158d04fdbc1802614c5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:acb091d1e9e4b0a7da772cbe76c7881eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#acb091d1e9e4b0a7da772cbe76c7881eb">PathIteratorPool</a> = NULL</td></tr>
<tr class="separator:acb091d1e9e4b0a7da772cbe76c7881eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615a9810b19ab1a8b971a0da57f5078c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="le__safe_ref_8h.html#aaf8fb3412fb840cb50366856affaf69b">le_ref_MapRef_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="path_iter_8c.html#a615a9810b19ab1a8b971a0da57f5078c">PathIteratorMap</a> = NULL</td></tr>
<tr class="separator:a615a9810b19ab1a8b971a0da57f5078c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements the path iterator API.</p>
<p>See <a class="el" href="c_pathIter.html">Path Iterator API</a> for details.</p>
<p>Copyright (C) Sierra Wireless Inc. license. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a4ab86e7102448b00d4a7b23a07a6431a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_COMPONENT_NAME_BYTES&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum size of the various path components within the path object. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a8b282954333012f182d43f271531e057"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> AppendNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_path_iterator__t.html">PathIterator_t</a> *&#160;</td>
          <td class="paramname"><em>iterPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newSegmentPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append a node onto the end of an iterator's path string.</p>
<p>This function also deals with parent and current node specs. For instance, if the new node to append is a parent specifier then the last node on the iterator's path is removed. If a currentNode specifier is appended onto an empty path string then it is kept at the beginning of the path, otherwise it's thrown away.</p>
<p>This way you can end up with paths like:</p>
<p>./a/path/to/somewhere</p>
<p>But not the less sensible:</p>
<p>./a/./path/to/./somewhere</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the append is fits within the path string. LE_OVERFLOW if the new stirng overflows the path buffer. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">iterPtr</td><td>The iterator to update. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newSegmentPtr</td><td>The new segment we're writing to the path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20dfab5e479136b01383c7f1e8d41ab6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> AppendSeparator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_path_iterator__t.html">PathIterator_t</a> *&#160;</td>
          <td class="paramname"><em>iterPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the current path to see if it currently ends in a separator, and if not, append one.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the trailing separator fit within the string. LE_OVERFLOW if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterPtr</td><td>The iterator to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7499735013bfcc387e4c7b1b0534abc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool EndsInParentSpec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_path_iterator__t.html">PathIterator_t</a> *&#160;</td>
          <td class="paramname"><em>iterPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the current path to see if it currently ends in a parent specification.</p>
<dl class="section return"><dt>Returns</dt><dd>True if it does, false if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterPtr</td><td>The iterator to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a617925dad65206502ab6ef6fb2e8b510"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool EndsWithSeparator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_path_iterator__t.html">PathIterator_t</a> *&#160;</td>
          <td class="paramname"><em>iterPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the current path to see if it currently ends in a separator.</p>
<dl class="section return"><dt>Returns</dt><dd>True if it does, false if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterPtr</td><td>The iterator path to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a466a28b96e9eeb700ad7ab51825ef548"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t FindNextNodeIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pathSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sepStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sepSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>startPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the next start of node index in the given string, starting the search from the given position.</p>
<dl class="section return"><dt>Returns</dt><dd>A position within the string if a next node is found. Otherwise pathSize is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathStr</td><td>The string to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathSize</td><td>Size of that string, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sepStr</td><td>Path separator string to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sepSize</td><td>Size of the path separator in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPoint</td><td>Where to start in that search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a94519cbdc96eacad5288899af7513bdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ssize_t FindPrevNodeIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_path_iterator__t.html">PathIterator_t</a> *&#160;</td>
          <td class="paramname"><em>iterPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>startPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the start of the previous node index in the given string. Starting this search from the given position.</p>
<dl class="section return"><dt>Returns</dt><dd>The index of the beginning of the previous node. Or -1 if no node can be found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterPtr</td><td>The iterator to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startPoint</td><td>Where to start in that search. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3fb15e4a7ede25216d772b6bcf3496a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_path_iterator__t.html">PathIterator_t</a>* GetPathIterPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given an iterator safe reference, find the original object pointer. If this can not be done a fatal error is issued. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The ref to translate to a pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba8da82fe54dc735b1490e66b12db6c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool IsAtSeperator </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pathSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sepStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sepSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>currentPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check the string at the current postion and see if we're currently sitting on a separator.</p>
<dl class="section return"><dt>Returns</dt><dd>True if there is a separator at the current position, false if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathStr</td><td>The string to search. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathSize</td><td>Size of that string, in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sepStr</td><td>Path separator string to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sepSize</td><td>Size of the path separator in bytes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currentPosition</td><td>The position to check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae6aa59696c54d2523009037cc78f9725"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_Append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take the new string path and combine it with the object's existing path.</p>
<dl class="section note"><dt>Note</dt><dd>This function looks for the current and parent node strings and treats them specially. So, (assuming defaults,) combining the path "/a/b" with the path "../x" will give you the combined path of: "/a/x".</dd>
<dd>
Appending a non-relative path onto an existing path effectivly replaces the current path, for example, appending /a/rooted/path, onto the existing /a/seperate/path will given you the path: /a/rooted/path.</dd>
<dd>
This will automatically reset the internal iterator to point at the end of the newly formed path. Also, this function always appends to the end of a path, ignoring the current position of the iterator.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if successful. LE_OVERFLOW if the output buffer is too small for the new string. LE_UNDERFLOW if combining the path the new path tries to traverse past the root. For example: "/a/b" + "../../../x" will result in LE_UNDERFLOW. However if the base path is relative, "a/b", then the resulting string will be "../x" and a return code of LE_OK. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The path object to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pathStr</td><td>The new path segment to append. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a50349a6c2afa4415d65a6efd443894d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> le_pathIter_Clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>originalRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a clone of an existing path iterator object.</p>
<dl class="section return"><dt>Returns</dt><dd>A new path iterator object that is a duplicate of the original one. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">originalRef</td><td>The path object to duplicate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a73fac1b657b752b17395c66fb1ae324b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> le_pathIter_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separatorPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>parentSpecPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>currentSpecPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new path iterator object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Optional. Pointer to the inital path to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separatorPtr</td><td>Required. Path separator to use. The separator can not be NULL or empty. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parentSpecPtr</td><td>Optional. Used to traverse upwards in a path. Leave as NULL or empty to not use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">currentSpecPtr</td><td>Optional. Used to refer to a current node. Much like how a '.' is use in a filesystem path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a35a38b307f9fdc0de82552e96a5a2d1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a> le_pathIter_CreateForUnix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new path iterator object that is pre-configured for Unix styled paths.</p>
<dl class="section return"><dt>Returns</dt><dd>A new path iterator object that's ready for iterating on Unix paths. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathPtr</td><td>Optional. Create an iterator for this path, or start with an empty path. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b57267a2c0db0210aab96c66459f9a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_pathIter_Delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete an iterator object and free it's memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to destroy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab00916d853b3a869748b0195cc2a8f11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GetCurrentNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the text for the node the iterator is pointing at.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if succesful. LE_OVERFLOW if the bufferPtr is too small to hold the whole string. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bufferPtr</td><td>The utf-8 formatted text buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size in bytes of the text buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac12ea9bbe193fd9239abd10a4b07feba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GetCurrentSpecifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the iterators string for the current node specifier. The for Unix style paths for this is ".". If an empty string is used, then this is ignored for the purposes of appending and normalizing paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bufferPtr</td><td>The string buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of the string buffer being written to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1707a310401be209aeada07f6d0f43f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GetParentSpecifier </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the string that represents parent nodes in a path string. By for Unix style paths this is "..". If an empty string is used, then it is ignored for the purposes of appending and normalizing paths. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bufferPtr</td><td>The string buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of the buffer being written to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a1c39584a779518395b41f957765283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GetPath </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a copy of the path currently contained within the iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bufferPtr</td><td>The string buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of the buffer being written to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a586cd64de7f1a6797da3a17896946ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GetSeparator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>bufferPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the string that is being used to represent path separators in this iterator object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bufferPtr</td><td>The string buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufferSize</td><td>The size of the buffer being written to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1c0b90132171b3f3cf5cfb614329b13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GoToEnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Jump the iterator to the end of the path.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the move was successful. LE_NOT_FOUND if the path is empty, or only contains a separator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad83a619dcc34ecf03da1859b3da2f57f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GoToNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move to the next node in the path.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the itrator was successful in jumping to the next node. LE_NOT_FOUND is returned if there are no more nodes to move to in the path. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92a740759fe5c3b0a18e39dd8c73466b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GoToPrev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move to the previous node in the path.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the iterator was successfuly moved, LE_NOT_FOUND if there are no prior nodes to move to. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4352480ab3c9ffb09e740f2899d504e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_pathIter_GoToStart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Jump the iterator to the beginning of the path.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the move was successful. LE_NOT_FOUND if the path is empty, or only contains a separator. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a657f779873a2220f463f705298c1399f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_pathIter_IsAbsolute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is this an absolute or relative path?</p>
<dl class="section return"><dt>Returns</dt><dd>True if the path is rooted, that is that it begins with a separator. False if the path is considered relative. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator object to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab4ceddae696158d04fdbc1802614c5d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_pathIter_IsEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is the path object holding an empty string?</p>
<dl class="section return"><dt>Returns</dt><dd>True if the path is empty, false if not. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterRef</td><td>The path object to read. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04be1341536a3e330a815171e7cdbf7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_pathIter_Truncate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__path_iter_8h.html#a0facb15e56e7ef896384eca415a7147a">le_pathIter_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iterRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Truncate the path at the current iterator node. If the iterator is at the beginning of the path, then the whole path is cleared. If the iterator is at the end of the path, then nothing happens.</p>
<p>Once done, then the iterator will be pointing at the new end of the path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iterRef</td><td>The iterator to update. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a79daeda2b90f10381bdedea01e8b262c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool NodeEqual </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pathStrPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>comparePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>compareSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>separatorPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>separatorSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check to see if the current node string is equal to the comparison string. Comparison stops at either the end of the source string or at the beginning of the next separator.</p>
<p>So, given the path string: "things/and/stuff" or simply "things", compared with the string: "things" this function will return true.</p>
<p>If path string was: "thingsand/stuff" then the function would return false.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the node matches the compare string, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathStrPtr</td><td>Compare this string with compareStr. However, ignore </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comparePtr</td><td>The name we're comparing to the node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compareSize</td><td>How big is the compare string? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separatorPtr</td><td>The separators in the path. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">separatorSize</td><td>The size of the separators </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab89601ee1ee30ba590989ede8dad248b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> pathIter_Init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the path subsystem's internal memory pools. This function is ment to be called from Legato's internal init. </p>

</div>
</div>
<a class="anchor" id="afe97246a010c2bea697404afc2a86d9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> ResetIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_path_iterator__t.html">PathIterator_t</a> *&#160;</td>
          <td class="paramname"><em>iterPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the iterator indicies to their proper positions. With start index at the beginning, last and current at the end. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iterPtr</td><td>The iterator to reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a615a9810b19ab1a8b971a0da57f5078c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__safe_ref_8h.html#aaf8fb3412fb840cb50366856affaf69b">le_ref_MapRef_t</a> PathIteratorMap = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map of object refs to help validate external accesses to this API. </p>

</div>
</div>
<a class="anchor" id="acb091d1e9e4b0a7da772cbe76c7881eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a> PathIteratorPool = NULL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pool of path iterators. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
