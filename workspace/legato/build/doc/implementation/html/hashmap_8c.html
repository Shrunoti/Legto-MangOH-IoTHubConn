<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>LEGATO: framework/liblegato/linux/hashmap.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="fonts.css" rel="stylesheet" type="text/css" />
<link href="legato.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/javascript">
//<![CDATA[
    // Detect if doc is served by eclipse
    if( ( (window.location.hostname == "127.0.0.1") || (window.location.hostname == "localhost") ) &&
        ( (window.location.port != "") && (window.location.port != 80) && (window.location.port != 443) ) )
    {
        // Inhibit init function from navtree
        initNavTree = function(toroot,relpath) {}
        $(document).ready(function(){
            navTree = document.getElementById("side-nav");
            if(navTree)
            {
                navTree.parentElement.removeChild(navTree);
            }
            $("#doc-content").css('margin-left',10);
        });
    }
//]]>
</script>
<link rel="icon" type="image/png" href="favicon.ico" />
</head>
<body>
<div id="top"><!-- do not remove this div! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo">
    <a href="index.html" title="Legato">
      <img alt="Logo" src="legatoLogo.png"/>
    </a>
    <div id="projectbrief">Simplifying IoT development</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hashmap_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">hashmap.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="legato_8h_source.html">legato.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hsieh__hash_8h_source.html">hsieh_hash.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="limit_8h_source.html">limit.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="hashmap_8h_source.html">hashmap.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:acec821b2e3eea469f41c390808c78f59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#acec821b2e3eea469f41c390808c78f59">HASHMAP_TRACE</a>(mapRef, ...)</td></tr>
<tr class="separator:acec821b2e3eea469f41c390808c78f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adbd47824b26347b65083969c01b06a75"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#adbd47824b26347b65083969c01b06a75">HashKey</a> (<a class="el" href="struct_hashmap__t.html">Hashmap_t</a> *map, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *key)</td></tr>
<tr class="separator:adbd47824b26347b65083969c01b06a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937b7dee5eae8ce295a6ed63d686ddf6"><td class="memItemLeft" align="right" valign="top">static Entry_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a937b7dee5eae8ce295a6ed63d686ddf6">CreateEntry</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *newKeyPtr, int newHash, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *newValuePtr, <a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a> poolRef)</td></tr>
<tr class="separator:a937b7dee5eae8ce295a6ed63d686ddf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988a91c4df4f165688de94e5c990e1c7"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a988a91c4df4f165688de94e5c990e1c7">CalculateIndex</a> (size_t bucketCount, size_t hash)</td></tr>
<tr class="separator:a988a91c4df4f165688de94e5c990e1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b20356dad41e586198defe1f8cb78e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a19b20356dad41e586198defe1f8cb78e">EqualKeys</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyAPtr, int hashA, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyBPtr, int hashB, <a class="el" href="le__hashmap_8h.html#adfe15673aeaa2400d3147d62abffee40">le_hashmap_EqualsFunc_t</a> equalsFuncPtr)</td></tr>
<tr class="separator:a19b20356dad41e586198defe1f8cb78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade79896a5b2ceec82c570fe21f7efe3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create</a> (const char *nameStr, size_t capacity, <a class="el" href="le__hashmap_8h.html#a354b7f0a30dd40266d367351a4b248b7">le_hashmap_HashFunc_t</a> hashFunc, <a class="el" href="le__hashmap_8h.html#adfe15673aeaa2400d3147d62abffee40">le_hashmap_EqualsFunc_t</a> equalsFunc)</td></tr>
<tr class="separator:ade79896a5b2ceec82c570fe21f7efe3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68759fb8291c487a507eae6d92710fc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a68759fb8291c487a507eae6d92710fc7">le_hashmap_Put</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *valuePtr)</td></tr>
<tr class="separator:a68759fb8291c487a507eae6d92710fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4322a312a2e4b00112022c2cb04eb416"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a4322a312a2e4b00112022c2cb04eb416">le_hashmap_Get</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr)</td></tr>
<tr class="separator:a4322a312a2e4b00112022c2cb04eb416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9645e5b363c335e1dd324f536e2b754c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a9645e5b363c335e1dd324f536e2b754c">le_hashmap_GetStoredKey</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr)</td></tr>
<tr class="separator:a9645e5b363c335e1dd324f536e2b754c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64eab4c096da5b66aa54c70ec5d5a776"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a64eab4c096da5b66aa54c70ec5d5a776">le_hashmap_Remove</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr)</td></tr>
<tr class="separator:a64eab4c096da5b66aa54c70ec5d5a776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5530fc9656f5e49f891541900bc21f34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a5530fc9656f5e49f891541900bc21f34">le_hashmap_isEmpty</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a5530fc9656f5e49f891541900bc21f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481e3fa6b0fe8319074140a2cb2ae1cc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a481e3fa6b0fe8319074140a2cb2ae1cc">le_hashmap_Size</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a481e3fa6b0fe8319074140a2cb2ae1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42bc33eaed4e6183edfbded3203beb4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#af42bc33eaed4e6183edfbded3203beb4">le_hashmap_ContainsKey</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr)</td></tr>
<tr class="separator:af42bc33eaed4e6183edfbded3203beb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e3af23871a2f9e8adffb748111aab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a27e3af23871a2f9e8adffb748111aab2">le_hashmap_RemoveAll</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a27e3af23871a2f9e8adffb748111aab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af142213c63ebac35b0d0e474f0d9c2f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#af142213c63ebac35b0d0e474f0d9c2f3">le_hashmap_ForEach</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, <a class="el" href="le__hashmap_8h.html#acae181524ccab8958e1c8fd5855995b1">le_hashmap_ForEachHandler_t</a> forEachFn, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *context)</td></tr>
<tr class="separator:af142213c63ebac35b0d0e474f0d9c2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb1d3a3d4c4b1b52a45205ac11a12c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a8fb1d3a3d4c4b1b52a45205ac11a12c1">le_hashmap_GetIterator</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a8fb1d3a3d4c4b1b52a45205ac11a12c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601b7d3e5d92e91e4090d726e5b190ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a601b7d3e5d92e91e4090d726e5b190ca">le_hashmap_NextNode</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr class="separator:a601b7d3e5d92e91e4090d726e5b190ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5cdb7a6d36d28699b255814c0d639d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#aad5cdb7a6d36d28699b255814c0d639d">le_hashmap_PrevNode</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr class="separator:aad5cdb7a6d36d28699b255814c0d639d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0e64b3fee37053bba166c8a283f387"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#aea0e64b3fee37053bba166c8a283f387">le_hashmap_GetKey</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr class="separator:aea0e64b3fee37053bba166c8a283f387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4761be6e9bf5a58155296e32c35c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#adf4761be6e9bf5a58155296e32c35c4b">le_hashmap_GetValue</a> (<a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> iteratorRef)</td></tr>
<tr class="separator:adf4761be6e9bf5a58155296e32c35c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec5d4c2a49b8d0304efdfd469a1b2a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#aeec5d4c2a49b8d0304efdfd469a1b2a4">le_hashmap_GetFirstNode</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **firstKeyPtr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **firstValuePtr)</td></tr>
<tr class="separator:aeec5d4c2a49b8d0304efdfd469a1b2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a30f4e7da8135ef0274b24a86b7fcb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a6a30f4e7da8135ef0274b24a86b7fcb7">le_hashmap_GetNodeAfter</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *keyPtr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **nextKeyPtr, <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **nextValuePtr)</td></tr>
<tr class="separator:a6a30f4e7da8135ef0274b24a86b7fcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31a0f34a74f765998467fa30096e46b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#ad31a0f34a74f765998467fa30096e46b">le_hashmap_CountCollisions</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:ad31a0f34a74f765998467fa30096e46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff75de814b38d4c4283379acb406b65"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a3ff75de814b38d4c4283379acb406b65">le_hashmap_HashString</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *stringToHashPtr)</td></tr>
<tr class="separator:a3ff75de814b38d4c4283379acb406b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d2b6c0689ece50ce979557029b8483"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a63d2b6c0689ece50ce979557029b8483">le_hashmap_EqualsString</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *firstStringPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *secondStringPtr)</td></tr>
<tr class="separator:a63d2b6c0689ece50ce979557029b8483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcf5d26bec7e15b6ec30fec4701ce03"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a1bcf5d26bec7e15b6ec30fec4701ce03">le_hashmap_HashUInt32</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *intToHashPtr)</td></tr>
<tr class="separator:a1bcf5d26bec7e15b6ec30fec4701ce03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e3edfdbd30d06729486060a75a77c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#ab3e3edfdbd30d06729486060a75a77c7">le_hashmap_EqualsUInt32</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *firstIntPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *secondIntPtr)</td></tr>
<tr class="separator:ab3e3edfdbd30d06729486060a75a77c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12558f1e0eeb68991ffb8f8ad442ce86"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a12558f1e0eeb68991ffb8f8ad442ce86">le_hashmap_HashUInt64</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *intToHashPtr)</td></tr>
<tr class="separator:a12558f1e0eeb68991ffb8f8ad442ce86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7ac9c681fc54fb121d94ee1e6f4c40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a3b7ac9c681fc54fb121d94ee1e6f4c40">le_hashmap_EqualsUInt64</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *firstIntPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *secondIntPtr)</td></tr>
<tr class="separator:a3b7ac9c681fc54fb121d94ee1e6f4c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9fc51c9f65c44f6c78cdaf101ab0e4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a2c9fc51c9f65c44f6c78cdaf101ab0e4">le_hashmap_HashVoidPointer</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *voidToHashPtr)</td></tr>
<tr class="separator:a2c9fc51c9f65c44f6c78cdaf101ab0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecdbbdb5cc0773f0f9946e6e4dec89c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a8ecdbbdb5cc0773f0f9946e6e4dec89c">le_hashmap_EqualsVoidPointer</a> (const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *firstVoidPtr, const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *secondVoidPtr)</td></tr>
<tr class="separator:a8ecdbbdb5cc0773f0f9946e6e4dec89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853082500b05e57d899606cfc0e34fab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a853082500b05e57d899606cfc0e34fab">le_hashmap_MakeTraceable</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a853082500b05e57d899606cfc0e34fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b30e794df1c866fe39c40c7949eb29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="hashmap_8c.html#a10b30e794df1c866fe39c40c7949eb29">le_hashmap_EnableTrace</a> (<a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> mapRef)</td></tr>
<tr class="separator:a10b30e794df1c866fe39c40c7949eb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright (C) Sierra Wireless Inc.</p>
<p>Parts of this file are Copyright (C) 2007 The Android Open Source Project</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment"> http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="acec821b2e3eea469f41c390808c78f59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HASHMAP_TRACE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">mapRef, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">if</span> ((mapRef)-&gt;traceRef != NULL) \</div><div class="line">    { <a class="code" href="le__log_8h.html#a331fb6c78ccddeafc455ad9c64e42008">\</a></div><div class="line"><a class="code" href="le__log_8h.html#a331fb6c78ccddeafc455ad9c64e42008">        LE_TRACE</a>((mapRef)-&gt;traceRef, ##__VA_ARGS__); \</div><div class="line">    }</div><div class="ttc" id="le__log_8h_html_a331fb6c78ccddeafc455ad9c64e42008"><div class="ttname"><a href="le__log_8h.html#a331fb6c78ccddeafc455ad9c64e42008">LE_TRACE</a></div><div class="ttdeci">#define LE_TRACE(traceRef, string,...)</div><div class="ttdef"><b>Definition:</b> le_log.h:612</div></div>
</div><!-- fragment --><p>Trace if tracing is enabled for a given hashmap. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a988a91c4df4f165688de94e5c990e1c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t CalculateIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bucketCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a hash and a map size, calculate the index at which to store the entry</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bucketCount</td><td>The number of buckets in the map </td></tr>
    <tr><td class="paramname">hash</td><td>The hash to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the index to use in the bucket array </dd></dl>

</div>
</div>
<a class="anchor" id="a937b7dee5eae8ce295a6ed63d686ddf6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Entry_t* CreateEntry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>newKeyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newHash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>newValuePtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__mem_8h.html#a44a896f6a0a1a8c733e8038eb332989e">le_mem_PoolRef_t</a>&#160;</td>
          <td class="paramname"><em>poolRef</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new entry to put in the map. Allocates the entry from the pool which was created during construction of the map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newKeyPtr</td><td>A pointer to the key </td></tr>
    <tr><td class="paramname">newHash</td><td>The calculated hash </td></tr>
    <tr><td class="paramname">newValuePtr</td><td>A pointer to the value </td></tr>
    <tr><td class="paramname">poolRef</td><td>A memory pool reference to use for allocating memory. This pool must have been created as a pool of Entry_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the newly allocated and filled-in Entry_t </dd></dl>

</div>
</div>
<a class="anchor" id="a19b20356dad41e586198defe1f8cb78e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool EqualKeys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyAPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hashA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyBPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hashB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#adfe15673aeaa2400d3147d62abffee40">le_hashmap_EqualsFunc_t</a>&#160;</td>
          <td class="paramname"><em>equalsFuncPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if 2 keys are equal (or are actually the same key)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyAPtr</td><td>Pointer to the first key </td></tr>
    <tr><td class="paramname">hashA</td><td>The hash of the first key </td></tr>
    <tr><td class="paramname">keyBPtr</td><td>Pointer to the second key </td></tr>
    <tr><td class="paramname">hashB</td><td>The hash of the second key </td></tr>
    <tr><td class="paramname">equalsFuncPtr</td><td>The equality function in use by the map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the keys are identical, false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="adbd47824b26347b65083969c01b06a75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t HashKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_hashmap__t.html">Hashmap_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate a hash. First this calls the user-supplied hash function. Then it does some defensive coding to avoid bad hashes from outside hash functions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">map</td><td>A pointer to the hashmap instance </td></tr>
    <tr><td class="paramname">key</td><td>A pointer to the key to hash </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new hash </dd></dl>

</div>
</div>
<a class="anchor" id="af42bc33eaed4e6183edfbded3203beb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_ContainsKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests if the HashMap contains a particular key</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the key is found, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be searched for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad31a0f34a74f765998467fa30096e46b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t le_hashmap_CountCollisions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Counts the total number of collisions in the map. A collision occurs when more than one entry is stored in the map at the same index.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns The sum of the collisions in the map </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ade79896a5b2ceec82c570fe21f7efe3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a> le_hashmap_Create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>nameStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a354b7f0a30dd40266d367351a4b248b7">le_hashmap_HashFunc_t</a>&#160;</td>
          <td class="paramname"><em>hashFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#adfe15673aeaa2400d3147d62abffee40">le_hashmap_EqualsFunc_t</a>&#160;</td>
          <td class="paramname"><em>equalsFunc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a HashMap</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a reference to the map.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Terminates the process on failure, so no need to check the return value for errors. </dd></dl>
<p>0.75 load factor. We have more buckets than expected keys as we want to reduce the chance of collisions. 1-1 would assume a perfect hashing function which is rather unlikely. Also, ensure that the capacity is at least 3 which avoids strange issues in the hashing algorithm</p>
<p>The memory pool is required to store entries. We set a default size and expansion size to reduce the number of forced allocations. Initial entries for each hash are actually doubly linked list objects which store where the starting entry is in the pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nameStr</td><td>Name of the HashMap </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">capacity</td><td>Expected capacity of the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hashFunc</td><td>The hash function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">equalsFunc</td><td>The equality function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10b30e794df1c866fe39c40c7949eb29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_hashmap_EnableTrace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately enables tracing on a particular hashmap object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a63d2b6c0689ece50ce979557029b8483"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_EqualsString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>firstStringPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>secondStringPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>String equality function. This can be used as a paramter to le_hashmap_Create if the key to the table is a string</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the strings are identical, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstStringPtr</td><td>Pointer to the first string for comparing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondStringPtr</td><td>Pointer to the second string for comparing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3e3edfdbd30d06729486060a75a77c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_EqualsUInt32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>firstIntPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>secondIntPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integer equality function. This can be used as a paramter to le_hashmap_Create if the key to the table is a uint32_t</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the integers are equal, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIntPtr</td><td>Pointer to the first integer for comparing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondIntPtr</td><td>Pointer to the second integer for comparing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3b7ac9c681fc54fb121d94ee1e6f4c40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_EqualsUInt64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>firstIntPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>secondIntPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Long integer equality function. This can be used as a paramter to le_hashmap_Create if the key to the table is a uint64_t</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the integers are equal, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIntPtr</td><td>Pointer to the first long integer for comparing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondIntPtr</td><td>Pointer to the second long integer for comparing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ecdbbdb5cc0773f0f9946e6e4dec89c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_EqualsVoidPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>firstVoidPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>secondVoidPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer equality function. This can be used as a parameter to <a class="el" href="hashmap_8c.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is an pointer or reference.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the pointers are equal, false otherwise </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstVoidPtr</td><td>First pointer for comparing. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondVoidPtr</td><td>PSecond pointer for comparing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af142213c63ebac35b0d0e474f0d9c2f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_ForEach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#acae181524ccab8958e1c8fd5855995b1">le_hashmap_ForEachHandler_t</a>&#160;</td>
          <td class="paramname"><em>forEachFn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterates over the whole map, calling the supplied callback with each key-value pair. If the callback returns false for any key then this function will return.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if all elements were checked; or false if iteration was stopped early </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">forEachFn</td><td>Callback function to be called with each pair </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>Pointer to a context to be supplied to the callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4322a312a2e4b00112022c2cb04eb416"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* le_hashmap_Get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a value from a HashMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the value or NULL if the key is not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be retrieved </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeec5d4c2a49b8d0304efdfd469a1b2a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_hashmap_GetFirstNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **&#160;</td>
          <td class="paramname"><em>firstKeyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **&#160;</td>
          <td class="paramname"><em>firstValuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the key and value of the first node stored in the hashmap. The hashmap is not sorted so this will simply return the first node stored in the map. There is no guarantee that a subsequent call to this function will return the same pair if new keys have been added to the map. If NULL is passed as the firstValuePointer then only the key will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the first node is returned or LE_NOT_FOUND if the map is empty. LE_BAD_PARAMETER if the key is NULL. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">firstKeyPtr</td><td>Pointer to the first key </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">firstValuePtr</td><td><blockquote class="doxtable">
<p>[out] Pointer to the first key&gt; [out] Pointer to the first value </p>
</blockquote>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8fb1d3a3d4c4b1b52a45205ac11a12c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a> le_hashmap_GetIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets an interator for step-by-step iteration over the map. In this mode the iteration is controlled by the calling function using the le_hashmap_NextNode function. There is one iterator per map, and calling this function resets the iterator position to the start of the map.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns A reference to a hashmap iterator which is ready for le_hashmap_NextNode to be called on it </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea0e64b3fee37053bba166c8a283f387"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* le_hashmap_GetKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a pointer to the key which the iterator is currently pointing at</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the current key, or NULL if the iterator has been invalidated </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6a30f4e7da8135ef0274b24a86b7fcb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_hashmap_GetNodeAfter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **&#160;</td>
          <td class="paramname"><em>nextKeyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> **&#160;</td>
          <td class="paramname"><em>nextValuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the key and value of the node after the passed in key. The hashmap is not sorted so this will simply return the next node stored in the map. There is no guarantee that a subsequent call to this function will return the same pair if new keys have been added to the map. If NULL is passed as the nextValuePtr then only the key will be returned.</p>
<dl class="section return"><dt>Returns</dt><dd>LE_OK if the next node is returned. If the keyPtr is not found in the map then LE_BAD_PARAMETER is returned. LE_NOT_FOUND is returned if the passed in key is the last one in the map. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be searched for </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nextKeyPtr</td><td>Pointer to the first key </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">nextValuePtr</td><td><blockquote class="doxtable">
<p>[out] Pointer to the first key&gt; [out] Pointer to the first value </p>
</blockquote>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9645e5b363c335e1dd324f536e2b754c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* le_hashmap_GetStoredKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a stored key from a HashMap.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the key that was stored in the HashMap by <a class="el" href="hashmap_8c.html#a68759fb8291c487a507eae6d92710fc7">le_hashmap_Put()</a> or NULL if the key is not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be retrieved. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf4761be6e9bf5a58155296e32c35c4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* le_hashmap_GetValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves a pointer to the value which the iterator is currently pointing at</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the current value, or NULL if the iterator has been invalidated </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ff75de814b38d4c4283379acb406b65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t le_hashmap_HashString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>stringToHashPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>String hashing function. This can be used as a parameter to le_hashmap_Create if the key to the table is a string</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the string pointed to by stringToHash </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stringToHashPtr</td><td>Pointer to the string to be hashed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1bcf5d26bec7e15b6ec30fec4701ce03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t le_hashmap_HashUInt32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>intToHashPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integer hashing function. This can be used as a paramter to le_hashmap_Create if the key to the table is a uint32_t</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the uint32_t pointed to by intToHash </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intToHashPtr</td><td>Pointer to the integer to be hashed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12558f1e0eeb68991ffb8f8ad442ce86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t le_hashmap_HashUInt64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>intToHashPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Long integer hashing function. This can be used as a paramter to le_hashmap_Create if the key to the table is a uint64_t</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the uint64_t pointed to by intToHash </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intToHashPtr</td><td>Pointer to the long integer to be hashed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2c9fc51c9f65c44f6c78cdaf101ab0e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t le_hashmap_HashVoidPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>voidToHashPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pointer hashing function. This can be used as a parameter to <a class="el" href="hashmap_8c.html#ade79896a5b2ceec82c570fe21f7efe3a">le_hashmap_Create()</a> if the key to the table is an pointer or reference. Simply pass in the address as the key.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the hash value of the pointer pointed to by voidToHashPtr </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">voidToHashPtr</td><td>Pointer to be hashed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5530fc9656f5e49f891541900bc21f34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool le_hashmap_isEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tests if the HashMap is empty (i.e. contains zero keys).</p>
<dl class="section return"><dt>Returns</dt><dd>Returns true if empty, false otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a853082500b05e57d899606cfc0e34fab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_hashmap_MakeTraceable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a particular hashmap traceable without enabling the tracing. After this is called, when the trace keyword for this hashmap (the hashmap's name) is enabled for the "framework" component in the process, then tracing will commence. If that keyword was already enabled before this function is called, then tracing will commence immediately when this function is called. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a601b7d3e5d92e91e4090d726e5b190ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_hashmap_NextNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the iterator to the next key/value pair in the map. Order is dependent on the hash algorithm and the order of inserts and is not sorted at all.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns LE_OK unless you go past the end of the map, then returns LE_NOT_FOUND </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad5cdb7a6d36d28699b255814c0d639d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="le__basics_8h.html#a1cca095ed6ebab24b57a636382a6c86c">le_result_t</a> le_hashmap_PrevNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#a8ab2021261a368add28c1be14f248459">le_hashmap_It_Ref_t</a>&#160;</td>
          <td class="paramname"><em>iteratorRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the iterator to the previous key/value pair in the map. Order is dependent on the hash algorithm and the order of inserts, and is not sorted at all.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns LE_OK unless you go past the beginning of the map, then returns LE_NOT_FOUND. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">iteratorRef</td><td>Reference to the iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a68759fb8291c487a507eae6d92710fc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* le_hashmap_Put </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>valuePtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a key-value pair to a HashMap. If the key already exists in the map then the previous value will be replaced with the new value passed into this function.</p>
<p>The process will terminate if this fails as it implies an inability to allocate any more memory </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">valuePtr</td><td>Pointer to the value to be stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64eab4c096da5b66aa54c70ec5d5a776"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a>* le_hashmap_Remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> *&#160;</td>
          <td class="paramname"><em>keyPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a value from a HashMap.</p>
<dl class="section note"><dt>Note</dt><dd>If the iterator is currently on the item being removed, then it's value is invalidated. The iterator will have to be moved before values and keys can be read from it again.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the value or NULL if the key is not found. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyPtr</td><td>Pointer to the key to be removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a27e3af23871a2f9e8adffb748111aab2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_e_m_p_l_a_t_e__cdef_8h.html#ac9c84fa68bbad002983e35ce3663c686">void</a> le_hashmap_RemoveAll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes all the entries held in the hashmap. This will not delete the data pointed to by the key and value pointers. That cleanup is the responsibility of the caller. This allows the map to be re-used. Currently maps cannot be deleted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a481e3fa6b0fe8319074140a2cb2ae1cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t le_hashmap_Size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="le__hashmap_8h.html#ae81c60860dbdb8c59beaf25985e5605a">le_hashmap_Ref_t</a>&#160;</td>
          <td class="paramname"><em>mapRef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the number of keys in the HashMap.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of keys in the HashMap. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapRef</td><td>Reference to the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
   <div class="footer">
        <div>
            <a href="https://www.sierrawireless.com/">
                <img src="swi-ico-medium.png" width="24" alt="" />
                &nbsp;Sierra Wireless
            </a>
            &nbsp;-&nbsp;
            Generated by Doxygen 1.8.11
        </div>
    </div>
</body>
</html>
